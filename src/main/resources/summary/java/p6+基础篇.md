# 一、基础篇

## 1. 网络基础

### 1.1. TCP是什么？

TCP，Transmission Control Protocol，传输控制协议，是一种面向连接的、面向字节流的、可靠的传输层通信协议。

### 1.2. UDP是什么？

UDP，User Datagram Protocol，用户数据报协议，是一种无连接的、面向报文的、不可靠的传输层协议，为应用程序提供一种无需建立连接就可以发送封装好的IP数据包的方法。

### 1.3. TCP与UDP的差别？

|                     | TCP                                          | UDP                                  |
| ------------------- | -------------------------------------------- | ------------------------------------ |
| 是否连接            | 面向连接的                                   | 无连接的                             |
| 传输方式            | 面向字节流的（流入进程或进程流出的字节序列） | 面向报文的（完整的报文）             |
| 连接对象个数        | 只能 一对一、可全双工通信                    | 支持一对一、一对多、多对一和多对多   |
| 是否使用拥塞控制    | **<u>流量控制和拥塞控制</u>***               | 无流量控制和拥塞控制                 |
| 是否可靠            | 可靠的                                       | 不可靠的，尽最大努力交付             |
| **<u>首部开销</u>** | 8个字节                                      | 20~60字节（选项可达40个字节）        |
| 性能                | 传输效率低，所需资源多                       | 传输效率高，所需资源少               |
| 适用场景            | 文件、邮件                                   | 语音、视频、直播                     |
| 应用的协议          | HTTP、FTP、SMTP                              | **<u>RIP</u>**、DNS、**<u>SNMP</u>** |

### 1.4. TCP与UDP应用的协议？



![1620099899187](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620099899187.png)

### 1.5. TCP如何保证数据可靠传输？

> 思路：当出现差错时能让发送方重传出现差错的数据，同时在接收方来不及处理收到的数据时，及时告诉发送方适当降低发送数据的速度。
>
> TCP主要通过确认应答和超时重传机制、检验和、最大报文长度、滑动窗口控制、流量控制以及拥塞控制等方法实现数据的可靠性传输。

#### **1. 确认应答和超时重传机制**

1. 作用：发送方通过对字节流每个字节进行顺序标号发送，接收方需要对接收到的数据中最高需要给出确认（不应超过0.5s），如果在规定的时间内，发送方没有收到确认应答，则需要重传已发送的报文段。
2. 工作原理：

- **序号**：占4个字节，范围[0，2^32  - 1]，使用mod 2^32运算，n序号表示第n字节，共可表示2^40位（4GB）数据。
- **确认号**：占4个字节，表示期望收到对方下一个报文段的第一个数据字节的序号。若确认号=N，则表明到序号N-1为止的所有数据都已正确收到。
- **确认ACK**：占1位，仅当ACK=1时确认号有效，TCP规定，在连接建立后，所有传送的报文都必须把ACK置为1。

#### **2. 检验和**

1. 作用：通过检验和的方式，接收端可以检测出数据是否有差错和异常，假如有差错，报文段就会被直接丢弃，发送方需要重新发送报文段。
2. 工作原理：

- **二进制反码求和运算**：
  - 0+0=0，但要产生进位1
  - 0+1=1，不需要产生进位1
  - 1+1=0，不需要产生进位1
  - 最高位产生进位1，最后结果需要+1
- 发送方：取12位TPC伪首部+TCP首部+TCP报文段数据部分，对其16位字使用**二进制反码求和运算**， 把结果**取反**写入检验和字段。
- 接收方：取12位TPC伪首部+TCP首部（此时检验和已经不是全0了）+TCP报文段数据部分，对其16位字使用**二进制反码求和运算**，当无差错时结果应为全1，否则就表明有差错出现。

![1620126724402](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620126724402.png)

#### **3. 最大报文段长度**

MSS，Maximum Segment Size，是指每一个TCP报文段中数据字段的最大长度 = TCP报文段长度 - TCP首部长度 

1. 作用：在连接建立过程中，双方选项上写入自己能支持的MSS（默认536字节），要保证在IP层传输时不需要再分片，减少网络开销，提高网络利用率。
2. 工作原理：

- MSS较小时，传输时加上TCP首部+IP首部+链路层首部，造成花费大开销实现少量数据传输，网络利用率低下。
- MSS较大时，TCP报文段非常长，在IP层传输被分解成多个短的数据报片，造成在终点时要把收到的各个短数据报片装配成原TCP报文段，而且分片多传输出错的概率大，还需要重传，使得花销增大。

#### **4. 以字节为单位的滑动窗口控制**

1. 作用：在没有收到接收方确认的情况下，发送方可以连续把窗口内的数据都发送出去，凡是已经发送过的数据，在未收到确认之前都必须暂时保留以便在超时重传时使用。这样可以提高超时重传机制下的发送效率和信道利用率。
2. 工作原理：

- 发送窗口里面的序号表示允许发送的序号，后沿后面部分表示已发送且已收到的确认，前沿前面部分表示不允许发送。*后沿变化有两种可能即不动（没有收到新的确认）和前移（收到了新的确认）。前沿通常是不断向前的，但也可能不动（收到通知窗口变小），还有可能向后收缩（不推荐）*。
- 接收窗口后沿部分表示已经发送过确认，已经交付主机了，不需要再保留这些数据，窗口内的需要是允许接收的。

![1620130103782](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620130103782.png)

#### **5. 利用滑动窗口实现的流量控制**

1. 作用：控制发送方速率不要太快，要让接收方来得及接收。*是点对点通信量的控制，是个端对端的问题（接收端控制发送端）。*
2. 工作原理：

- rwnd，receiver window，即通知窗口，发送方的发送窗口不能超过接收方给出的接收窗口数值。
- *持续计时器，persistence timer，收到零窗口通知时开启，时间到期后会发送一个零窗口探测报文段（仅携带1字节的数据），对方在这个探测报文段给出现在窗口值，如果仍然是零，则还会重新设置持续计时器。以解决零窗口互相等待问题。*

![1620130650215](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620130650215.png)

#### 6. 拥塞控制

1. 作用：防止过多的数据注入到网络中，避免网络中的路由器和链路过载。*拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的因素。*
2. 工作原理：

- cwnd，congestion window，拥塞窗口，发送方维持的一个状态变量，大小取决于网络的拥塞程度，并且动态变化。**发送方窗口上限值 = Min[rwnd，cwnd]**
- SMSS，Sender Maximum Segment Size，最大报文段。
- 慢开始门限，ssthresh，cwnd < ssthresh => 慢开始算法，cwnd > ssthresh时 => 拥塞避免算法。
- 慢开始，slow-start，先发送小字节探测一下（2~4个SMSS），由小到大逐渐增大拥塞窗口。在每收到一个对新的报文段的确认后，就可以把拥塞窗口增多一个SMSS数值（△cwnd = min[N，SMSS]，N指原先未被确认的、但现在刚刚收到确认的字节数）。
- 拥塞避免，congestion avoidance，cwnd缓慢增大，每经过1个往返时间RTT只把cwnd+1，不像慢开始阶段那样指数规律增长，而是按线性规律增长增长。如果网络出现了超时，发送方判断为网络拥塞，需要调整ssthresh为原来的一半，同时cwnd设置为1，重新进入慢开始阶段。
- 快重传，fast retransmit，接收方没收到某报文段时，需要立即返回3个缺失报文段的重复确认给发送方。发送方只要一收到3个重复确认（3 - ACK），则认为接收方确实没有收到该报文段，则进行重传，而不会误认为是网络拥塞。
- 快恢复，fast recovery，发送方知道只是丢失个别报文段后，不启动慢开始而是执行快恢复算法，调整ssthresh为cwnd/2，同时设置cwnd=ssthresh，并执行拥塞避免算法。

![1620132158175](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620132158175.png)

### 1.6. TCP三次握手？

*服务端TCP进程先创建传输控制块TCB（TCP连接表、指向发送和接收缓存的指针、指向重传队列的指针、当前发送和接收序号等），处于LISTEN（收听）状态，等待客户端的连接请求。*

*客户端TCP进程创建传输控制块，打算建立TCP连接，向服务端发起连接请求报文段。*

- TCP规定，SYN报文段不能携带数据，但要消耗一个序号。
- TCP规定，ACK报文段可以携带数据，如果不携带数据则不用消耗序号。

1. 一次握手：客户端发送SYN=1，seq=x的请求报文段，随后客户端进入SYN-SENT（同步已发送）状态。
2. 二次握手：服务端返回ACK=1，ack=x+1，SYN=1，seq=y的确认报文段，随后服务器进入SYN-RECD（同步收到）状态。
3. 三次握手：客户端返回ACK=1，ack=y+1，seq=x+1的确认报文段，此时TCP连接已建立，客户端进入ESTABLISHED（已建立连接）状态。

*当服务端收到客户端的确认报文段后，也进入ESTABLISHED（已建立连接）状态。*

![1620138485517](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620138485517.png)

### 1.7. 为什么TCP需要三次握手，两次行吗？

- 三次握手的原因：主要是为了建立可靠的全双工通信信道，保证客户端与服务端同时具备发送与接收数据的能力。
- 两次握手不行的原因：

1. **两次握手只能保证单向连接是通畅的**。根据TCP确认应答和超时重传机制，通信双方必须维护一个序列号，发送方根据序列号标识哪些报文段是已经发送出去的，接收方也要根据序列号应答哪些报文段是已经确认的。**而三次握手的过程就是双方互相告知起始序列号的过程**，即客户端标记服务端确认，服务端标记客户端确认。如果只是两次握手，那么至多只有客户端的起始序列号得以确认，而另一方的序列号得不到确认，即只能确保单向连接是顺畅的。
2. **第三次握手可以防止已失效的连接请求报文段突然又传送到服务端，建立了多余的连接，造成资源的浪费。**

### 1.8. TCP四次挥手？

*客户端TCP进程先发起TCP释放报文段，并停止发送数据，主动关闭TCP连接。*

- TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
- TCP规定，ACK报文段可以携带数据，如果不携带数据则不用消耗序号。
- MSL，Maximum Segment LifeTime，最长报文段寿命，建议设置为2分钟。

1. 一次挥手：客户端发起FIN=1，seq=u的连接释放报文段，随后进入FIN-WAIT-1（终止等待1）状态，等待服务端确认。
2. 二次挥手：服务端返回ACK=1，ack=u+1，seq=v的确认报文段，随后进入CLOSE-WAIT（关闭等待）状态，此时客户端到服务端方向的连接已释放，TCP连接处于HALF-CLOSE（半关闭）状态。接着，客户端收到确认报文段后，进入FIN-WAIT-2（终止等待2）状态，等待服务端发出连接释放报文段。
3. 三次挥手：服务端TCP进程发起ACK=1，ack=u+1，FIN=1，seq=w的连接释放报文段，随后进入              LAST-ACK（最后确认）状态，等待客户端的确认。
4. 四次挥手：客户端返回ACK=1，ack=w+1，seq=u+1的确认报文段，随后进入TIME-WAIT（时间等待）状态，服务端接收到确认报文段后，进入CLOSE（关闭）状态。此时TCP连接还没有释放掉，必须经过时间等待计时器（TIME-WAIT timer）设置的2MSL时间后，客户端才进入CLOSED（关闭）状态。

![1620141320603](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620141320603.png)

### 1.9. 为什么TCP需要四次挥手？

- 四次挥手的原因：因为需要确保客户端与服务端的数据能够完成传输。前两次挥手后，关闭客户端到服务端方向的连接，服务端通知上层应用程序做好最后的准备，进入CLOSE-WAIT（等待关闭）状态。第三次挥手由服务端TCP进程发起连接释放报文段，根据TCP确认应答和超时重传机制，客户端必须返回确认报文段，所以产生第四次挥手。

### 2.0. 为什么TCP客户端需要等待2MSL才进入关闭状态？

- MSL，Maximum Segment LifeTime，最长报文段寿命，建议设置为2分钟。

1. **为了保证客户端发送的最后一个确认报文段能够达到服务器。**如果上一个确认报文丢失，设置2MSL能够在这个时间内，客户端再次收到服务端的FIN+ACK连接释放报文段，保证服务端释放TCP连接。
2. **还为了防止已失效的连接请求报文段突然又传送到服务端，建立了多余的连接，造成资源的浪费。**设置2MSL，可以使本次TCP连接持续的时间内所产生的报文段在网络中消失，确保下一个新的连接不会出现这种旧的连接请求报文段。

### 2.1. 如何查看TIME-WAIT状态的连接数量？

netstat -an | grep TIME_WAIT | wc -l

### 2.2. 为什么会TIME-WAIT过多？如何解决？

- 可能原因：在**高并发短连接**的TCP服务器上，当服务器处理完请求后立刻主动正常关闭连接时，会出现大量socket处于TIME-WAIT状态。此时如果客户端的并发量持续很高，那么部分客户端就可能显示连接不上。
- 解决：

1. vim /etc/sysctl.conf，打开系统的TIME-WAIT重用和快速回收。

```shell
# 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；
net.ipv4.tcp_tw_reuse = 1
# 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。
net.ipv4.tcp_tw_recycle = 1
```

2. /sbin/sysctl -p，使参数生效。

### 2.3. TCP报文段格式？

![1620179962619](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620179962619.png)

> TCP报文首部占用20~60字节。

- **源端口和目的端口**：各占2个字节，分别写入源端口号和目的端口号，实现TCP分功能。两个值分别加上IP首部的源端IP地址和目的端IP地址，可以唯一确定一个TCP连接。
- **序号**：占4个字节，范围[0，2^32  - 1]，使用mod 2^32运算，n序号表示第n字节，共可表示2^40位（4GB）数据。
- **确认号**：占4个字节，表示期望收到对方下一个报文段的第一个数据字节的序号。若确认号=N，则表明到序号N-1为止的所有数据都已正确收到。
- **数据偏移**：占4位，指TCP报文段的数据起始处，距离TCP报文段的起始处有多远即TCP报文段的**首部长度**。单位是32位字（4个字节），而4位二进制最大表示15，意味着**TCP首部长度最大长度为60字节**（即选项长度不能超过40字节）。
- **保留**：占6位，保留为今后使用，目前应置为0。
- **标志字段**：各占1位，共6位
  - **紧急URG**：URGent，当URG=1时，表名**紧急指针**有效，需要与**紧急指针**配合使用。URG告诉系统，此报文段中有紧急数据，应尽快传送（相当于高优先级的数据），而不要按原来的排队顺序来传送。
  - **确认ACK**：ACKnowledgment，仅当ACK=1时确认号有效，TCP规定，在连接建立后，所有传送的报文都必须把ACK置为1。
  - **推送PSH**：PuSH，发送方TCP把PSH置为1，则应该立即创建一个报文段发送出去。接收方TCP收到PSH=1的报文段，则应该尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。
  - **复位RST**：ReSeT，当RST=1时，表明TCP连接出现严重差错，必须释放连接再重新建立连接。
  - **同步SYN**：SYNchronization，在连接建立时用来同步序号。SYN=1，表示这是一个连接请求或连接接受报文。
  - **终止FIN**：FINish，用来释放一个连接。当FIN=1时，表明此报文段发送方的数据已发送完毕，并要求释放连接。
- **窗口**：占2个字节，[0, 2^16 - 1]，指的是发送本报文段的一方的接收窗口，指明从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量（以字节为单位）。窗口值作为接收方让发送方设置其发送窗口的依据，经常动态变化着。
- **检验和**：占2个字节，通过检验和的方式，接收端可以检测出数据是否有差错和异常，假如有差错，报文段就会被直接丢弃，发送方需要重新发送报文段。
  - **二进制反码求和运算**：
    - 0+0=0，但要产生进位1
    - 0+1=1，不需要产生进位1
    - 1+1=0，不需要产生进位1
    - 最高位产生进位1，最后结果需要+1
  - 发送方：取12位TPC伪首部+TCP首部+TCP报文段数据部分，对其16位字使用**二进制反码求和运算**， 把结果**取反**写入检验和字段。
  - 接收方：取12位TPC伪首部+TCP首部（此时检验和已经不是全0了）+TCP报文段数据部分，对其16位字使用**二进制反码求和运算**，当无差错时结果应为全1，否则就表明有差错出现。

![1620126724402](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620126724402.png)

- **紧急指针**：占2个字节，紧急指针仅在**URG=1**时才有意义，指出本报文段中紧急数据的字节数（序号值+字节数=偏移量），即指出了紧急数据的末尾在报文段中的位置。窗口为零时也可发送紧急数据。
- **选项**：长度可变，最大可达40字节。常见的有**最大报文段长度MSS**、**窗口扩大选项**、**时间戳选项**、**选择确认选项**等。

### 2.4. UDP用户数据报格式？

![1620182389880](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620182389880.png)

> UDP报文首部占8个字节。

- **源端口**：占2字节，源端口号，在需要对方回信时选用，否则全0。

- **目的端口**：占2个字节，目的端口号，在终点交付报文时必须使用。

- **长度**：占2个字节，UDP用户数据报的长度，最小值是8（仅有首部时），最大表示2^16 - 1=65535个字节。

- **检验和**：占2个字节，通过检验和的方式，接收端可以检测出数据是否有差错和异常，假如有差错，报文段就会被直接丢弃，发送方需要重新发送报文段。

  - **二进制反码求和运算**：
    - 0+0=0，但要产生进位1
    - 0+1=1，不需要产生进位1
    - 1+1=0，不需要产生进位1
    - 最高位产生进位1，最后结果需要+1
  - 发送方：取12位UDP伪首部+UDP首部+UDP用户数据报的数据部分，对其16位字使用**二进制反码求和运算**， 把结果**取反**写入检验和字段。
  - 接收方：取12位UDP伪首部+UDP首部（此时检验和已经不是全0了）+UDP用户数据报的数据部分，对其16位字使用**二进制反码求和运算**，当无差错时结果应为全1，否则就表明有差错出现。

  ![1620182690813](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620182690813.png)

### 2.5. IP数据报格式？

![1620185300666](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620185300666.png)

> IP报文首部占20~60字节。

- **版本**：占4位，指IP协议的版本。通信双方使用的IP协议版本必须一致。IPv4的版本号为4，IPv6的版本号为6。
- **首部长度**：占4位，IP分组的首部长度，单位是32位字（4个字节），最小值是5，而4位二进制最大表示15，意味着**IP分组首部长度最大长度为60字节**（即选项字段不能超过40字节）。IP分组的首部长度如果不是4字节的整数倍时，必须利用最后的填充字段加以补充。
- **区分服务**：DS，Differentiated Services，也叫服务类型。占8位，用来获得更好的服务：*最小时延、最大吞吐量、最高可靠性、最小费用*。一般情况下都不使用这个字段。
- **总长度**：占16位，[0, 2^16 - 1]，指**首部和数据之和的长度**，最大长度为65535个字节。若所传送的数据报长度超过**数据链路层MTU（最大传送单元，默认1500字节）**，就必须把过长的数据报进行分片处理，分片该字段的值也会发生改变，即此时指**分片后的每一个分片的首部长度与该分片的数据长度的总和**。*IP协议规定，在互联网中所有的主机和路由器，必须能够接受长度不超过576字节的数据报，MSS+TCP固定首部+IP固定首部=536+20+20=576字节。*
- **标识**：identification，占16位，IP软件在存储器中维持了一个计数器，每产生一个数据报计数器就+1，并将此值赋给标识字段。**相同的标识字段的值可以使分片后的各数据报片重装为原来的数据报**。
- **标志**：flag，占3位，目前只有两位有意义。
  - **最低位MF**：More Fragment，MF=1表示后面还有分片的数据报，MF=0表示这个已经是若干数据报片中的最后一个了。
  - **中间位DF**：Don't Fragment，DF=1表示不能分片，DF=0表示允许分片。
- **片偏移**：占13位，指较长的分组经过分片后，某片在原分组中的相对位置，以8个字节为偏移单位，即原偏移1400字节，偏移量=1400/8=175。
- **生存时间**：TTL，Time to Live，占8位，指数据报在网络中的寿命。现表示跳数限制，单位是**跳数**，指路由器每次转发数据报之前需要把TTL值-1，若TTL值减小到零，就丢弃这个数据报不再转发。即**TTL表明数据报在互联网中至少可经过多少个路由器**，最大值为255。
- **协议**：占8位，协议字段指出此数据报携带的数据使用何种协议，以便使目的主机IP层知道应该将数据部分上交给哪个协议进行处理。TCP为6，UDP为17。
- **首部检验和**：占16位，通过检验和的方式，接收端可以检测出数据是否有差错和异常，假如有差错，报文段就会被直接丢弃，发送方需要重新发送报文段。**只检验数据报的首部部分，不检验数据部分。**ICMP、IGMP、UDP、TCP均同时检验首部部分和数据部分。
  - **二进制反码求和运算**：
    - 0+0=0，但要产生进位1
    - 0+1=1，不需要产生进位1
    - 1+1=0，不需要产生进位1
    - 最高位产生进位1，最后结果需要+1
  - 发送方对首部部分16位字使用**二进制反码求和运算**， 把结果**取反**写入首部检验和字段。
  - 接收方对首部部分16位字使用**二进制反码求和运算**（此时首部检验和已经不是全0了），当无差错时结果取反应为全0，否则就表明有差错出现。
- **源地址**：占32位。
- **目的地址**：占32位。
- **可选字段**：最大占40个字节，用来支持排错、测量以及安全检测等措施。必要时需要用全0的填充字段来补齐成为4字节的整数倍。实际上很少被使用。

### 2.6. 以太网MAC帧格式？

![1620190340385](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620190340385.png)

> 常用的以太网MAC帧格式有两种标准，一种是DIX Ethernet V2标准（即以太网V2标准），另一种是IEEE的802.3标准，现在市场上流行的都是以太网V2的MAC帧，但大家也常常把它称为IEEE 802.3标准的MAC帧。

MAC帧首部固定长度18个字节，有效MAC帧长度=首部长度+数据长度=64~1518字节。

- **目的地址**：6个字节，是指网卡的硬件地址（MAC地址），占48位，在网卡出厂时固化。
- **源地址**：6个字节，是指网卡的硬件地址（MAC地址），占48位，在网卡出厂时固化。
- **类型字段**：2个字节，用来标志上一层使用的是什么协议，以便把收到的MAC帧的数据上交给上一层的协议。*如值为0x0800，就表示上层的是IP数据报。*
- **数据字段**：长度在46~1500字节，46=64-18，1500=**以太网最大传输单元MTU**。当数据字段的长度小于46字节时，MAC子层会在数据字段后面加入一个整数字节的填充字段，以**保证以太网MAC帧不小于64字节**。上层协议具有识别有效的数据长度长度的功能，比如IP层就可以把填充的字节丢弃掉。
- **帧检验序列FCS**：使用CRC检验。

从MAC子层向下传到物理层时，还要在帧的前面插入8个字节（由硬件生成）

- 前7个字节是**前同步码**（1和0交替码），作用是使接收端的适配器在接收MAC帧时能够迅速调整其时钟频率，使它和发送端的时钟同步，也就是实现位同步（比特同步）。
- 最后一个字节是**帧开始界定符**，定义为10101011，最后两个连续的1表示MAC帧马上要开始了。

> 在以太网上传送数据时是以**帧**为单位传送的，各帧之间还必须有一定的间隙。
>
> 由于存在**帧开始界定符**，所以以外网不需要使用帧结束定界符，也不需要使用字节插入来保证透明传输。
>
> **以太网不负责重传丢弃的帧。**

### 2.7. 子网掩码的作用？

为了能够从IP数据报的首部看出源主机或目的主机所连接的网络是否进行了子网划分。

### 2.8. OSI与TCP/IP模型？

![1620196369515](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620196369515.png)

> OSI七层体系协议结构概念请求、理论完整，但既复杂又不使用。
>
> TCP/IP四层体系结构使用更为广泛。
>
> 五层协议体系结构总和了OSI和TCP/IP的优点，为介绍网络原理而设计出来的。

- OSI七层模型：物理层、数据链路层、网络层、运输层、会话层、表示层、应用层
- TCP/IP四层模型：网络接口层、网际层、运输层、应用层
- 五层协议模型：物理层、数据链路层、网络层、运输层、应用层
  - **物理层**：physical layer，以**比特**为单位，负责在发送双方**传送1和0**。
  - **数据链路层**：data link layer，以**帧**为单位，负责在两个相邻结点之间的链路上**传送帧**，包括控制信息（如同步信息、地址信息、差错控制等）。
  - **网络层**：network layer，以**IP数据报**为单位，负责为在分组交换网上的不同主机提供**通信服务**。在发送数据时，把运输层产生的报文或用户数据报封装成IP数据报进行传送。
  - **运输层**：transport layer，TCP以**报文段**为单位，UDP以**用户数据报**为单位，负责向两台主机中进程之间的通信提供**通用的数据传输服务**。
  - **应用层**：application layer，以**报文**为单位，负责通过应用进程之间的交互来完成**特定网络应用**。

### 2.9 常见的网络服务分层示例

| 分层       | 示例                                |
| ---------- | ----------------------------------- |
| 物理层     | 中继器、集线器                      |
| 数据链路层 | 网卡、网桥、交换机                  |
| 网络层     | 路由器、防火墙、ARP、IP、ICMP、IGMP |
| 运输层     | TCP、UDP                            |
| 应用层     | HTTP、SMTP、DNS、FTP                |

- **ARP**：Address Resolution Protocol，地址解析协议，从网络层使用的IP地址，解析出在数据链路层使用的硬件地址。
- **ICMP**：Internet Control Message Protocol，网际控制报文协议，允许主机或路由器报告差错情况和提供有关异常情况的报告，可以更有效地转发IP数据报，提高交付成功的机会。
- **IGMP**：Internet Group Management Protocol，网际组管理协议，让连接在本地局域网上的多播路由器**知道**本局域网上是否有主机（即主机中的某个进程）参加或退出了某个多播组。

### 3.0. TCP拆包、粘包？原因？解决方法？

- **TCP拆包**：

  - **概念**：如果要发送的数据包过大，就会被拆分成多个TCP报文分开传输，即**一个完整的包可能会被TCP拆分成多个包进行发送**。
  - **直接原因**：
    - 应用程序写入的数据大于套接字缓冲区的大小。
    - TCP报文段的数据部分长度大于MSS(536字节)，导致在IP层传输被分解成多个短的数据报片。
  - **根本原因**：网络层所收到上层交付的数据报长度，超过**数据链路层MTU（最大传送单元，默认1500字节）**，需要把过长的数据报进行IP分片处理。

- **TCP粘包**：

  - **概念**：**多个小的包可能会被TCP封装成一个大的数据包发送**。
  - **直接原因**：
    - 应用程序写入的数据小于套接字缓冲区的大小
    - 接收方不及时读取套接字缓冲区数据
  - **根本原因**：
    - **发送方原因**：TCP默认使用**Nagle算法**（通过减少必须发送包的个数，来增加网络软件系统的效率），即TCP会收集多个小分组，在一个确认到来时才一起发送，导致可能在发送方出现粘包问题。
    - **接收方原因**：TCP将接收到的数据包保存在接收缓存里，如果TCP接收数据包到缓存的速度，大于应用程序从缓存中读取数据包的数据，那么多个包就会被缓存起来，而应用程序就有可能读取到多个首尾相连粘在一起的包。
    - **TCP原因**：TCP是**面向字节流**的协议，报文格式不像UDP那样有专门的长度字段来记录实际报文的长度，交付上层的数据没有边界，导致粘包的发生。

- **解决方法**：

  最本质的原因在于**接收方无法分辨消息与消息之间的边界在哪**，因此，思路就是，通过某种方案给出边界。

  - **消息定长，空格补位**：每个消息的大小都一样，接收方只要累计接收数据，直到数据等到一个定长的指就将它作为一个消息。
  - **包尾加特殊字符作为边界**：比如FTP协议就是在包尾加上\r\n标记作为边界的。但问题在于通信双方要约定在数据正文中，不出现该特殊字符，否则会误判为消息的边界。
  - **包首部记录包体长度**：每个包首部至少包含数据包的长度，这样接收方可以通过读取包首部的长度字段，就知道每一个包的实际长度。

### 3.1. HTTP是什么？

HTTP，hypertext Transfer Protocol，超长文本传输协议，是一个**通常运行在TCP之上的**应用层协议，定义了浏览器怎么向万维网服务器请求万维网文档以及服务器怎么把文档传送给浏览器。

- **事务**：指一系列的信息交换是一个不可分割的整体，即要么所有的信息交换都完成，要么一次交换都不进行。
- **无连接**：指通信双方在交换HTTP报文之前不需要先建立HTTP连接。
- **无状态**：指同一个客户第二次访问同一个服务器上的页面时，服务器的响应与第一次访问时的相同（假设不会更新）。

### 3.2. HTTP协议/1.0/1.1/2.0？

- **HTTP/1.0**：
  - **概述**：每一个请求建立一个TCP连接，请求完成后立马断开连接（**短连接**）。
  - **缺点**：
    - **连接无法复用**，每次请求都要经历三次握手和慢启动，导致在并发量大的情况下服务器的压力负担大，以及带宽无法被充分利用。
- **HTTP/1.1**：
  - **概述：**多个http请求可以复用一个TCP连接，使用Connection Header（close/keep-alive）来区分**短/长连接**。服务器按照FIFO原则来处理不同请求。
  - **缺点**：在同一时间，针对同一域名下的请求有一定的限制，超过限制数目的请求会被阻塞。
- **HTTP/2.0**：
  - **概述**：**多路复用**（二进制帧的设计）允许同时通过单一的连接发起多重的请求-响应信息，可以很容易地去实现并行地在同一个TCP连接上双向交换信息，而不用依赖建立多个TCP连接。
  - **缺点**：普及速度慢，与HTTP1.1并存。

### 3.3. HTTP/1.0/1.1的主要区别？

1. **长连接**：减少了建立和关闭连接的消耗和延迟。
2. **Host头处理**：支持Host头域，不在以IP为请求方标志，解决一台物理机存在多个虚拟主机，共享IP地址的问题。
3. **错误状态码增多**：1.1新增了24个错误状态响应码，更加明确各个状态，如409（表示请求的资源与资源当前状态发生冲突）、410（表示服务器某个资源被永久性的删除）。
4. **网络连接的优化**：1.1支持断点续传，在请求头引入range头域（允许只请求资源的某个部分，返回码206），方便充分利用带宽和连接。
5. **提供更多的缓存控制策略**：

| 缓存控制头          | 解释                                                         | 备注     |
| ------------------- | ------------------------------------------------------------ | -------- |
| If-Modified-Since   | 允许在对应的资源未被修改的情况下，返回304未修改              | 1.0、1.1 |
| Expires             | 指定一个日期/时间，超过该时间则认为此响应已过期              | 1.0、1.1 |
| ETag                | Entity tag，对于某个资源的某个特定版本的一个表示符，通常是一个消息三列 | 1.1新增  |
| If-Unmodified-Since | 仅当该实体某个特定时间以来未被修改的情况下，才发送响应。     | 1.1新增  |
| If-Match            | 仅当客户端提供的实体与服务器对应的实体相匹配时，才进行对应的操作。主要用于PUT这样的方法中，仅当从用户上次更新某个资源后，该资源未被修改的情况下，才更新该资源。 | 1.1新增  |
| If-None-Match       | 允许在对应的内容未被修改的情况下，返回304未修改              | 1.1新增  |

### 3.4 HTTP/1.1/2.0的主要区别？

1. **多路复用**：2.0连接共享，不同的Request可以使用同一个连接传输，最后根据每个Request id组合成正常的请求。
2. **新的传输格式**：2.0使用二进制格式（基于二进制帧的设计），1.0依然使用基于文本的格式（基于文本分割解析）。
3. **Header压缩**：由于1.X中Header带有大量的信息，并且得重复传输，2.0使用Encoder来减少需要传输的Header大小。
4. **服务端推送**：2.0中，服务器可以对客户端的一个请求发送多个响应。

### 3.5. HTTPS连接的建立过程？

> HTTPS，Hyper Text  Transfer Protocol over SecureSocket Layer，是以安全为目标的HTTP通道，在HTTP的基础上通过传输加密和身份认证保证传输过程的安全性。

- HTTPS在内容传输的加密上使用的是**对称加密**（速度快），在证书验证阶段使用**非对称加密**（安全性高）。
- **对称加密**：双方持有**相同的密钥**，加密速度快。典型的对称加密算法有：DES、AES**。**
- **非对称加密**：**密钥成对出现（私钥和公钥）**。私钥只有自己知道，不在网络中传输。公钥可以公开，A使用B公钥加密后，B使用B的私钥解密。加密速度慢。典型的非对称加密算法有：RSA、DSA。

1. **发起请求**：首先客户端将它所支持的算法列表和一个用作产生密钥的**随机数1**发送给服务器。
2. **返回证书**：服务器从算法列表中选择一种算法，并将它和一份包含**服务器公钥**的证书以及**随机数2**返回给客户端，包含用于认证目的的服务器标识。
3. **证书验证**：客户端对服务器的证书进行验证（**数字签名**），抽取**服务器公钥**，再产生一个**预主密钥（pre_master_secret）**的随机密码串 + **服务器公钥**，使用非对称加密，将**加密后的信息**发送给服务器。此时，客户端使用**随机数1、随机数2、预主密钥**，独立计算出**加密和MAC密钥**，作为接下来的**会话密钥**。
4. **服务器解密**：服务器通过**服务器私钥**对传送过来的加密信息进行解密，得到**预主密钥**，与**随机数1、随机数2**独立计算出**加密和MAC密钥**，作为接下来的**会话密钥**。
5. **客户端发起测试**：客户端将握手消息经过**会话密钥**使用对称加密得到的MAC值发送给服务端，验证服务器能否正常接受客户端加密的消息。
6. **服务器响应测试**：服务器将握手消息经过**会话密钥**使用对称加密得到的MAC值返回给客户端，如果客户端能够接受并返回确认报文的MAC值，则SSL层建立完成。

### 3.6. HTTP与HTTPS的区别？

| HTTP                           | HTTPS                                     |
| ------------------------------ | ----------------------------------------- |
| 默认端口80                     | 默认端口443                               |
| URL以http://开头               | URL以https://开头                         |
| 明文传输、数据未加密、安全性差 | 传输过程SSL加密、安全性好、需要用到CA证书 |
| 消耗资源少、响应速度快         | 消耗资源多、响应速度慢                    |

### 3.7. HTTP请求报文有哪些方法？

| 方法    | 描述                                                     |
| ------- | -------------------------------------------------------- |
| GET     | 向特定资源发送请求，查询数据并返回实体                   |
| POST    | 向服务器添加信息，可能会导致新的资源建立或已有资源的修改 |
| PUT     | 向服务器上传新的内容                                     |
| HEAD    | 类似于GET请求，返回的响应中没有具体的内容，用于获取报头  |
| DELETE  | 请求服务器删除特定的资源                                 |
| OPTIONS | 可以用来向服务器发送请求，来测试服务器的功能特性         |
| TRACE   | 回显服务器收到的请求，用于测试或者诊断                   |
| CONNECT | 用于代理服务器                                           |

### **3.8. Get和Post请求区别**？

|          | GET                                                          | POST                                                         |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 可见性   | 数据在URL中，所有人可见                                      | 数据不会显示在URL中                                          |
| 安全性   | 发送的数据是URL的一部分，安全性较差                          | 参数不会被保存在浏览器历史或者web服务器日志中，安全性较好    |
| 数据长度 | 受限制，最大2KB=2^10字节                                     | 无限制                                                       |
| 编码类型 | application/x-www-form-urlencoded                            | multipart/form-data                                          |
| 缓存     | 能被缓存，会保存在浏览器的浏览记录中，URL能够被作作为书签保存 | 不能被缓存                                                   |
| 意义     | 用于向特定资源发送请求，查询数据并返回实体                   | 用于向服务器添加信息，可能会导致新的资源建立或已有资源的修改 |

### 3.9. HTTP常见响应状态码？

> 1xx表示通知信息，如请求收到了或者正在进行处理。
>
> 2xx表示成功，如已接受或已知道。
>
> 3xx表示重定向，如要完成请求还必须采取进一步的行动。
>
> 4xx表示客户的差错，如请求中有错误的语法或者不能完车。
>
> 5xx表示服务器的差错，如服务器失效无法完成请求。

- 100：Continue，继续，客户端应继续请求。
- 200：OK，请求成功，一般用于GET和POST请求。
- 301：Move Permanently，资源永久重定向。
- 302：Found，资源暂时重定向。
- 400：Bad Request，客户端请求的语法错误，服务器无法理解。
- 403：Forbidden，服务器理解客户端的请求，但是拒绝执行此请求。
- 404：Not Found，服务器无法根据客户端的请求找到资源。
- 500：Internal Sever Error，服务器内容错误，无法完成请求。
- 502：Bad Gateway，作为**网关或者代理服务器**尝试执行请求时，从远程服务器中接收到了无效的响应。

### 4.0. 重定向与转发的区别？

|            | 重定向（Redirect）                                     | 转发（Forward）                                   |
| ---------- | ------------------------------------------------------ | ------------------------------------------------- |
| 地址栏路径 | 发生变化                                               | 不变                                              |
| 其他站点   | 可以访问其他站点（服务器）的资源                       | 只能访问当前服务器下的资源                        |
| 请求的次数 | 是两次请求，不能使用Request域对象来共享数据            | 是同一次请求，共享同一个Request域对象             |
| 效率       | 速度慢                                                 | 速度快                                            |
| 执行主体   | web容器，在同一个web容器中转发，对于客户端来说是透明的 | 客户端，服务器返回302状态码，客户端执行重定向操作 |

### 4.1. Cookie与Session的区别？

|          | Cookie                                                       | Session                                                      |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 共同点   | 用来跟踪浏览器用户身份                                       | 用来跟踪浏览器用户身份                                       |
| 位置     | 保存在客户端（浏览器）                                       | 保存在服务端                                                 |
| 安全性   | 不是很安全，可以分析本地的Cookie进行欺骗                     | 较安全                                                       |
| 作用     | 一般用来保存信息                                             | 记录用户的状态                                               |
| 产生机制 | 服务器通过设置响应头提示浏览器生成或者直接使用客户端脚本产生，然后请求时可以发送给服务器 | 客户端请求时，一般服务器会创建JSessionId标识，存放session值到散列表中 |

### 4.2. 在浏览器输入URL再回车确认后发生了什么？

URL判断、DNS查询、TCP连接、浏览器发起HTTP请求、服务器处理并响应HTTP请求、浏览器渲染页面

| 过程              | 过程                                                         | 使用的协议 |
| ----------------- | ------------------------------------------------------------ | ---------- |
| 1、URL判断        | 浏览器判断URL是否合法                                        | 无         |
| 2、DNS查询        | 浏览器查找DNS得到域名对应的IP地址，查找过程：浏览器缓存 -> 操作系统缓存 -> 路由器缓存 -> DNS缓存 -> 域名服务器 | DNS        |
| 3、TCP连接        | 根据IP地址与端口建立TCP连接                                  | TCP        |
| 4、HTTP请求       | 浏览器向服务器发送HTTP请求                                   | HTTP       |
| 5、响应HTTP请求   | 服务器处理并响应HTTP请求                                     | HTTP       |
| 6、浏览器渲染页面 | 浏览器接收HTTP响应并渲染页面                                 | 无         |

### 4.3. HTTP请求与响应报文格式？

![1620215152917](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620215152917.png)

- **开始行**：用于区分是请求报文还是响应报文。在请求报文中的开始行叫做**请求行**，在响应报文中的开始行叫**状态行**。开始行的**三个字段都以空格隔开**，最后的“CR”与"LF”分别代表"回车"和“换行”。
  - 请求报文：方法、URL、版本
  - 响应报文：版本、状态码、短语
- **首部行**：用来说明浏览器、服务器或者主体的一些信息，可以有好几行，也可以不用。每一个首部行都以CRLF结尾。在整个首部行结束时，**还有一空行将首部行和实体主体分开**。
- **实体主体**：请求包体或者响应包体。



## 2. 加解密基础

### 1.1. 常见签名与加密相关用语？

#### 1. 转义

转义字符能使其开头的序列具有不同于普通字符数列的语义。常见作用有：

- 如果不进行转义就可能与语法规定的某些**内容产生混淆**，所以某些内容需要转义。如Java的转义字符"\\"，用来区分字符串中，哪些是分割符，哪些是字符本身。
- 字符引用，用于转义键盘录入的字符，如字符串中的回车符和换行符，使其不可见，从而更容易表达其他内容。

#### 2. 编码解码

编码是采用一种新的载体来表示前一个载体所表达的信息，本质上是信息形式的转换，并没有保密的作用（因为编解码算法是公开的），目的是将信息转换成统一的格式，方便在不同系统中传输。

eg：信息 -> 编码 -> 二进制 -> 解码 -> 信息

*如果解码之后无法正确还原原来所表达的信息，此时就出现了**乱码**。通常是因为选用的解码和编码方式不同所导致的。*

常见编码类型有：

- **文本文件编码**：
  - 作用：将文本内容编码为**二进制数据**，以实现二进制数据进行存储或者传输的目的。
  - 相关技术：ASCII（1字节）、ISO8859-1、GBK（汉字2字节）、GBK2312、UTF-8（汉字0到4字节）、UTF-16、UTF-32等。
- **可打印字符编码**：
  - 作用：将二进制数据编码为**可打印的字符**，以实现通过可打印字符的形式进行存储或者传输的目的。
  - 场景：Web场景（图片）、公钥证书、电子邮件附件等（因为ASCII码128~255字符不可见，不方便路由传输）。
  - 相关技术：HEX、Base64等。
    - HEX：16进制字符，只有字母A~F，4位一组。
    - Base64：a-zA-Z0-9+=，64个字符，6位一组，再对照ASCII码表。

![1620302838656](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620302838656.png)

```java
        // 1、编码技术: 很多消息摘要、加解密算法都是针对二进制的
        try {
            // Base64编码: Q0FG => 6位一组, 3 * 8 = 4 * 6, 压缩率比HEX高, 可能会出现+、=符号
            String base64Str = Base64.getEncoder().encodeToString("CAF".getBytes("ASCII"));
            System.err.println(base64Str);

            // Base64解码: CAF
            String base64Org = new String(Base64.getDecoder().decode(base64Str), "ASCII");
            System.err.println(base64Org);
        } catch (UnsupportedEncodingException e) {
            // do nothing
        }
```

- **URL编码**：
  - 作用：通过使用安全的字符去表示不安全字符从而达到适合传输的目的。
  - 场景：作为URL参数时：中文、空格、&、？、=

#### 3. 消息摘要

- 作用：为了校验**信息的完整性**，保证信息在传输过程中不被篡改。
- 场景：校验密码是否正确、校验下载文件是否完整无损。
- 相关技术：MD5（32字符16字节定长）、SHA、SHA256等。
- 特点：无法逆推、（优秀的Hash算法）结果定长、碰撞率低、相同输入相同输出、不同输入输出千差万别。
- 缺点：简单的摘要可通过穷举、撞库的方式得到原文，因此需要加盐增加算法的安全度。

```java
        // 2、消息摘要: 16字节, MD5、SHA, 哈希的算法, 单向的不能逆推, 优秀的哈希产生的结果是定长的, 碰撞率比较低, 少量Hash就千差万别
        // 作用: 用于验证原消息是否有改变、不同输入不同输出、相同输入相同输出、在数字签名中可以用来证明消息没被别人篡改过
        String input = "hello world";

        // MD5国内一般都使用HEX格式编码, 但事实上Base64也可
        System.err.println(MD5(input));// HEX是一个字符占4位, 16个字节, 共32个字符 => 5EB63BBBE01EEED093CB22BB8F5ACDC3
        System.err.println(MD5(MD5(input) + "加盐"));// MD5加盐(随机字符串), 极大加强安全性: 1FEED1AECF760C313879517FA3A8F2B6
        System.err.println(SHA1(input));// HEX是一个字符占4位, 20个字节, 共40个字符 => 2AAE6C35C94FCFB415DBE95F408B9CE91EE846ED
        System.err.println(SHA256(input));// HEX是一个字符占4位, 32个字节, 共64个字符 => B94D27B9934D3E08A52E52D7DA7DABFAC484EFE37A5380EE9088F7ACE2EFCDE9
```

```java
// MD5消息摘要
    public static String MD5(String str) {
        try {
            MessageDigest md5 = MessageDigest.getInstance("MD5");// 算法类型
            md5.update(str.getBytes("UTF-8"));// 字符集
            byte[] digest = md5.digest();// MD5范围到此为止
            return DatatypeConverter.printHexBinary(digest);
        } catch (NoSuchAlgorithmException e) {
            // do nothing
        } catch (UnsupportedEncodingException e) {
            // do nothing
        }

        return null;
    }

    // SHA1不太安全
    public static String SHA1(String str) {
        try {
            MessageDigest SHA1 = MessageDigest.getInstance("SHA");
            SHA1.update(str.getBytes("UTF-8"));
            byte[] digest = SHA1.digest();// SHA1范围到此为止
            return DatatypeConverter.printHexBinary(digest);
        } catch (NoSuchAlgorithmException e) {
            // do nothing
        } catch (UnsupportedEncodingException e) {
            // do nothing
        }

        return null;
    }

    // SHA256比较安全
    public static String SHA256(String str) {
        try {
            MessageDigest SHA256 = MessageDigest.getInstance("SHA-256");
            SHA256.update(str.getBytes("UTF-8"));
            byte[] digest = SHA256.digest();// SHA256范围到此为止
            return DatatypeConverter.printHexBinary(digest);
        } catch (NoSuchAlgorithmException e) {
            // do nothing
        } catch (UnsupportedEncodingException e) {
            // do nothing
        }

        return null;
    }
```

#### 4. 加密解密

对原来的明文按照某种算法进行处理，使其成为不可读的一段代码，即密文。

- 作用：保护数据不被非法人窃取、阅读，保证发送**消息的保密性**。

- 算法类型：

  - **对称加密**：
    - 概念：加密和解密时使用的**密钥是同一个**，因此又称为共享密钥加密算法。
    - 优点：算法公开、计算量小、速度快、效率高。
    - 缺点：发送双发使用相同的密钥，密钥容易泄露，安全性较弱。
    - 相关技术：DES（速度快、容易被破解）、AES（难以被破解）等。
  - **非对称加密**：
    - 概念：加密和解密使用**不同的密钥**，包含一个公开密钥（公钥）和一个私有密钥（私钥），因此又称为公开密钥加密算法。
    - 优点：密钥成对出现，且私钥存在传输泄露的风险，大大增加了安全性。
    - 缺点：算法复杂，速度远远低于对称加密算法、不适用于数据量较大的场景。
    - 相关技术：RSA等。

  *注意点：算法类型、字符集、使用哪个密钥、编码类型*

```java
        // 3、加密算法: RSA跨平台, 不推荐使用JAVA方式(PKCS8)来生成私钥和公钥, 推荐用OPEN SSL(Git Hub)方式生成(PKCS1 | PKCS8)
        //      1) 对称加密: 收发双方约定同一个Key, Key被劫持了就不安全了
        //      2) 非对称加密: 收发双发约定一对Key, 只把一半在网上流传, 另一半不流传
        // RSA非对称加密默认使用Base64格式编码
        String publicKeyStr = "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDTse/HAlvTdgaUn4uCFiC6o++G\n" +
                "SPQ9XN3DjBOyitzOO0atlTG68KZnhEoUMZGJ2grKgWu49xjV8XY+8AUziAZfFJ5g\n" +
                "LXN/e9QuJ+yLm7hPfEmOAZorGLLxUV1ms266RqD9V9l2UJGlmVqo4ZV9pRnbxW8a\n" +
                "7sh2iR/2pIM5p3atiwIDAQAB";
        String privateKeyStr = "MIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBANOx78cCW9N2BpSf\n" +
                "i4IWILqj74ZI9D1c3cOME7KK3M47Rq2VMbrwpmeEShQxkYnaCsqBa7j3GNXxdj7w\n" +
                "BTOIBl8UnmAtc3971C4n7IubuE98SY4BmisYsvFRXWazbrpGoP1X2XZQkaWZWqjh\n" +
                "lX2lGdvFbxruyHaJH/akgzmndq2LAgMBAAECgYEAgKkZeNNXKdsGvteEu4hlVeoC\n" +
                "zpOSVaUWZx3Abvf0oSbnmuIdOme+SxXczA8gTC8H9fHYna8YGhdJ7ZCFKL+YVqA3\n" +
                "y3ytx3VPcUR/DIexfsUKTQwxWbmwFOXjimHd1EOWglhP16jX+JqJdcYO8WUDaYJY\n" +
                "fII+52w4IBqXQzV0ROECQQDsjP6eVx+ocT3vPWKuO4k68xNIbJYv0rI6OUirq+iW\n" +
                "fEyt+qQg46p7cVcwjVy+smTEOcALljGp3qvBF+c9cEgbAkEA5RnFOnG4OWfEkzPF\n" +
                "bJPqZ49E59Yt6Gh0EC163IzFtirB/GMumrT70Gs1vItrZb8iYuhaK1uZB0lJLJPB\n" +
                "ppdnUQJBAKVa2hHtbR/eKSE3k+efjoo6qNwTq9i6PAQfTwFSJkArm55yepDTFLU9\n" +
                "wWkbKB3VrkLM68Yts4G/Oei8wNRdzMkCQE6LwE/iTzv3NLEXLdek+teYihJGHyUw\n" +
                "MqKdRSM6bEqhbDKguoi2BiOVri2/SwnuNtbcPJXi6JtT5++NlPYNsJECQAsU+Ama\n" +
                "zDNyx8oq/s/JmB/jk6HmNMUaujsBd4N3yvO9awaLEgeghD02lIa0smd9qgqLVhm8\n" +
                "rl0xPQV91p5pcFU=";

        // 如果不采用读文件的, 需要手动清理IDE加的"\n"
        publicKeyStr = publicKeyStr.replace("\n", "");
        privateKeyStr = privateKeyStr.replace("\n", "");

        String rsaEncryptStr = rsaEncrypt(input, toPublicKey(publicKeyStr));
        System.err.println(rsaEncryptStr);// UdYxJbZirWPDAHhIaTLA4q6jrdh0MWNu+OFZaAP5rZqvR9Vzynl53uyUe6OisyRxHS++q8EnHu6hEaFGdJNimuZ99yo0Lpq8AxudlUd7j9JvFd2EmAo+phA1KnC+SHn1BOF6qYVymhjxnsWnB2IHACIcFhWcHinC7txSVjZHQo0=
        String rsaDecryptStr = rsaDECRYPT(rsaEncryptStr, toPrivateKey(privateKeyStr));
        System.err.println(rsaDecryptStr);// hello world
```

```java
// Java生成RSA非对称加密公钥对象
    public static PublicKey toPublicKey(String str) {
        try {
            KeyFactory keyFactory = KeyFactory.getInstance("RSA");// 算法类型
            byte[] bytes = Base64.getDecoder().decode(str);// OPENSSL 生成的RSA公钥采用Base64编码
            X509EncodedKeySpec x509EncodedKeySpec = new X509EncodedKeySpec(bytes);// 公钥统一标准X509编码
            return keyFactory.generatePublic(x509EncodedKeySpec);
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (InvalidKeySpecException e) {
            e.printStackTrace();
        }

        return null;
    }

    // Java生成RSA非对称加密私钥对象
    public static PrivateKey toPrivateKey(String str) {
        try {
            KeyFactory keyFactory = KeyFactory.getInstance("RSA");// 算法类型
            byte[] bytes = Base64.getDecoder().decode(str);// OPENSSL 生成的RSA公钥采用Base64编码
            PKCS8EncodedKeySpec pkcs8EncodedKeySpec = new PKCS8EncodedKeySpec(bytes);// JAVA私钥只能读PKCS8格式
            return keyFactory.generatePrivate(pkcs8EncodedKeySpec);
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (InvalidKeySpecException e) {
            e.printStackTrace();
        }

        return null;
    }

   // RSA非对称加密
    public static String rsaEncrypt(String str, Key key) {
        try {
            Cipher cipher = Cipher.getInstance("RSA");// 算法类型
            cipher.init(Cipher.ENCRYPT_MODE, key);// 加密模式
            byte[] bytes = str.getBytes("UTF-8");// 字符集
            byte[] doFinal = cipher.doFinal(bytes);// RSA范围到此为止

            // RSA通常使用Base64编码
            return Base64.getEncoder().encodeToString(doFinal);
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (NoSuchPaddingException e) {
            e.printStackTrace();
        } catch (InvalidKeyException e) {
            e.printStackTrace();
        } catch (BadPaddingException e) {
            e.printStackTrace();
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        } catch (IllegalBlockSizeException e) {
            e.printStackTrace();
        }

        return null;
    }

    // RSA非对称解密
    public static String rsaDECRYPT(String str, Key key) {
        try {
            Cipher cipher = Cipher.getInstance("RSA");// 算法类型
            cipher.init(Cipher.DECRYPT_MODE, key);// 解密模式
            byte[] bytes = Base64.getDecoder().decode(str);// RSA通常使用Base64编码
            byte[] doFinal = cipher.doFinal(bytes);// RSA范围到此为止

            // 这里采用UAT-8字符集
            return new String(doFinal,"UTF-8");
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (NoSuchPaddingException e) {
            e.printStackTrace();
        } catch (InvalidKeyException e) {
            e.printStackTrace();
        } catch (BadPaddingException e) {
            e.printStackTrace();
        } catch (IllegalBlockSizeException e) {
            e.printStackTrace();
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }

        return null;
    }
```

#### 5. 数字签名

- 作用：身份认证发送方，具有消息的不可抵赖性，同时保证消息的完整性。
- 相关技术：消息摘要算法 + 加密解密算法。

```java
        // 4、数字签名: 散列+加密 = 消息摘要 + 非对称加密
        //      1) 证明消息没被别人篡改过 => 消息摘要
        //      2) 证明确实是发送方发过来的 => 非对称加密, 使用自己的私钥加密消息
        String sign = rsaSign(toPrivateKey(privateKeyStr), input);
        System.err.println(sign);// PDhFYAx3FSIajHFYwP35PInipQxmFA/qtuCJXPALOoUf2nZlIC3Xt9qfSK/hovhhXBIuOSReTnKLCHDuvXJ0rfNVC1SqO4yYl5PXeiHgOjUj18VLxKyId0H9Z4+L47Uhb3JSsNv+X8trE6Q4dDj29xjVeVEBkfsKYdqjc8QxSPQ=
        boolean res = rsaVerifySign(toPublicKey(publicKeyStr), input, sign);
        System.err.println(res);// true
```

```java
    // Java利用MD5WithRSA实现数字签名, 一定要用自己的私钥进行数字签名
    public static String rsaSign(PrivateKey privateKey, String str) {
        try {
            Signature signature = Signature.getInstance("MD5WithRSA");// 算法类型
            signature.initSign(privateKey);// 初始化私钥
            signature.update(str.getBytes("UTF-8"));// 数据字符集采用UTF-8
            byte[] sign = signature.sign();// 数字签名范围到此为止
            return Base64.getEncoder().encodeToString(sign);// 通常数字签名使用Base64编码
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (InvalidKeyException e) {
            e.printStackTrace();
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        } catch (SignatureException e) {
            e.printStackTrace();
        }

        return null;
    }

    // Java利用MD5WithRSA实现数字验签, 一定要用对方的公钥进行验签
    public static boolean rsaVerifySign(PublicKey publicKey, String str, String sign) {
        try {
            Signature signature = Signature.getInstance("MD5WithRSA");// 算法类型
            signature.initVerify(publicKey);// 初始化公钥
            signature.update(str.getBytes("UTF-8"));// 数据字符集采用UTF-8
            byte[] bytes = Base64.getDecoder().decode(sign);// 通常数字签名使用Base64编码
            return signature.verify(bytes);// 数字验签范围到此为止
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (InvalidKeyException e) {
            e.printStackTrace();
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        } catch (SignatureException e) {
            e.printStackTrace();
        }

        return false;
    }
```

### 1.2. 数字签名与数据加密的区别？

- **数字签名**：

![1620308002223](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620308002223.png)

1. 发送方先使用Hash函数对将要发送的明文生成**消息摘要**。
2. 发送方使用**自己的私钥**签名消息摘要，生成**已签名的消息摘要**。
3. 发送方把将要发送的**明文**和**已签名的消息摘要**，一起发送给接收方。
4. 接收方再使用**发送方的公钥**对收到的**已签名的消息摘要**进行验证，验证通过可以得到原始的消息摘要。此步验证了**发送方的身份**。
5. 接收方使用相同的Hash函数对收到的**明文**生成**消息摘要**，与解密出来的消息摘要进行比对，判断两者是否一致。此步验证了**消息的完整性**。

- **数据加密**：

（基于大质数分解数学原理的非对称加密，一般大的数值对作为私钥，小的数值对作为公钥）

![1620305224976](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620305224976.png)

![1620305447877](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620305447877.png)

1. 发送方先生成一个**对称密钥**，使用此密钥将对称加密将要发送的明文，生成密文。
2. 发送方使用**接收方的公钥**非对称加密上述生成的**对称密钥**，生成加密后的密钥。
3. 发送者将**密文**与**加密后的密钥**（*成为数字信封*），一起发送给接收方。
4. 接收者使用**自己的私钥**解密加密后的密钥得到原始的**对称密钥**，再用该对称密钥解密密文，得到真正的明文。

- **数字签名与数据加密的区别**：（共同点：都使用了公开密钥体系）

|                    | 数字签名                                                     | 数据加密                                                     |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 加密方式（发送时） | 使用发送方的私钥                                             | 使用接收方的公钥                                             |
| 解密方式（接收时） | 使用发送方的公钥                                             | 使用接收方的私钥                                             |
| 映射关系           | 一对多，只有拥有私钥的才能代表发送，任何拥有公钥的人都可以解密 | 多对一，任何拥有公钥的人都可以加密发送，只有拥有私钥的才能解密成功 |
| 使用的算法         | 非对称加密                                                   | 对称加密明文、非对称加密**对称密钥**                         |
| 作用               | 保证发送的消息的**完整性、身份认证和不可抵赖性**             | 发送的消息的**保密性**                                       |

### 1.3. PKCS1与PKCS8的区别？

使用OPEN SSL生成私钥和公钥：

- **PKCS1**：
  - 概念：一种标准的生成私钥Key的方法，是RSA的密钥的原本格式。
  - 特点：BEGIN 开头：BEGIN RSA PUBLIC KEY
  - 作用：生成私钥。
  - 语法：
    - 生成私钥：genrsa -out private 1024
    - 生成公钥：rsa -in private -pubout -out public

![1620305778221](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620305778221.png)

![1620305830513](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620305830513.png)

![1620305962240](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620305962240.png)

- PKCS8：
  - 概念：用于转换私钥，在PKCS1数据上增加了一些信息，使其可存储更多的元信息。
  - 特点：与PKCS1能够相互转换、可以用于非RSA对称加密算法、JAVA只认PKCS8。
  - 语法：
    - KCS1转换成PKCS8：pkcs8 -topk8 in private -nocrypt -out private_pkcs8

![1620306139689](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620306139689.png)



## **3. 操作系统基础**

### 1.1. 进程和线程的区别？

- **进程**：是**资源分配的最小单位**。
  - 在Java中，启动main函数相当于启动一个进程，而main函数所在的线程该进程中的线程，称为主线程。
- **线程**：是**任务调度和执行的最小单位**，线程并行执行，会存在资源竞争和上下文切换的问题。
  - 在Java中，一个进程可以有多个线程，多个线程共享进程的堆和方法区资源，但不共享栈和程序计数器，每个线程有自己的本地方法栈、虚拟机栈和程序计数器。各个线程之间切换工作时，负担要比进程小得多，所以线程也被称为轻量级进程。
- **协程**：是一种比线程更加轻量级的存在，一个线程可以拥有多个协程，协程没有增加线程数量，只是在线程的基础之上通过**分用复用**的方式运行多个协程。**协程只有和异步I/O结合起来才能发挥出最大的威力**，这是因为：
  - 对于计算密集型任务本身并不需要大量的线程切换（一般只需要C + 1），此时使用协程的作用非常有限，反而还增加了协程切换的开销。
  - 由于操作线程是任务调度和执行的最小单位，即操作系统只知道线程，并不知道协程的存在，所以在协程调用阻塞I/O时，操作系统会让线程进入阻塞状态，导致绑定在该线程之上的其他协程都会陷入阻塞而得不到调度（应该启动个新的线程或者封装I/O为异步非阻塞/O）。
- *管程：指的是管理共享变量以及对共享变量的操作过程，以让他们支持并发，是一种进程同步互斥工具。*
  - 作用：解决信号量机制变成麻烦，容易出错的问题。
  - 特点：各外部进程/线程只能通过管程提供的特定入口才能访问共享数据，且每次仅允许一个进程在管程内执行某个内部过程。
  - 场景：Java中的synchronized、wait()、notify()、notifyAll()等。

### 1.2. 进程间的通信方式？

1. **管道**：亲缘关系使用无名管道，非亲缘关系使用有名管道，遵循FIFO，是**半双工**通信方式，数据只能单向流动。
   - 无名管道：pipe，管道是一种半双工的通信方式，数据只能单向流动，且只能在具有亲缘关系的进程间使用（如父子进程）。
   - 高级管道：popen，指在当前程序进程中启动另一个程序进程，把其当做是当前程序进程的子进程。
   - 有名管道：named pipe，同样是半双工，但允许无亲缘关系进程间通信。
2. **信号**：signal，信号是一种比较复杂的通信方式，用于**通知接收进程某个事情已经发送了**。比如用户调用kill命令将信号发送给其他进程。
3. **消息队列**：message queue，消息队列即消息的链表， 存放在内核中并由消息队列标识符标识，克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等特点。
4. **共享内存**：shared memory，共享内存就是映射一段能被其他进程所访问的内存。
   - 这段共享内存由一个进程创建，多个进程都可以直接读写，是**最快的IPC方式**，是针对其他进程间通信方式运行效率低而专门设计的。
   - 由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。
5. **信号量**，semophore，信号量是一个计数器，用于控制多个进程对共享资源的访问，常作为**进程间以及同一进程不同线程之间的同步手段**。
6. **套接字**：socket，与其他通信机制不同，它是通信双方的一种约定，用于**不同机器间的进程通信**。

### 1.3. 核心态与用户态？

> 特权指令是拥有特殊权限的指令，用于调用系统函数或系统软件等。比如内存清理、重置时钟、分配系统资源、修改虚存段表和页表、修改用户访问权限等。
>
> 非特权指令是普通权限的指令，在程序执行时都可以调用。

核心态与用户态是两种处理器状态：

- **核心态（Kernel Mode）**：
  - 当程序运行在0特权级时（RING0~3），称之为运行在**核心态**。RING0是最高的特权级。
  - 运行操作系统程序（**内核程序**），可以**执行特权指令和执行非特权指令**。CPU可以访问内存的所有数据，包括外围设备等硬件资源。
  - 处于核心态时，进程能访问所有的内存和对象，且所占有的处理器不允许被抢占。
- **用户态（User Mode）**：
  - 当程序运行在3级特权级时（RING0~3），称之为运行在**用户态**，RING3是最低的特权级，是普通用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态。
  - 运行**应用程序**，只能执行**非特权指令**。只能**受限地**访问内存。
  - 处于用户态时，进程所能访问的内存空间和对象受到限制，其所占有的处理器可能被抢占。

### 1.4. 为什么要有核心态和用户态？

- 由于特权指令权限重大，如果使用不当将会导致整个系统崩溃，为了**保证系统安全**，这类指令只能用于操作系统或者其他系统软件，不直接提供给用户使用，所以CPU状态区分为核心态和用户态：
  - 特权指令必须在核心态执行，且内核态可以使用全部指令。
  - 用户态只能使用非特权指令，当用户态下使用特权指令时，将产生中断以阻止用户使用特权指令。

### 1.5. 用户态与核心态之间的切换？

- **用户态 -> 核心态**：通过**中断**实现，且**中断是用户态到核心态的唯一途径**。
  - *这里的中断指的是广义的中断，包括异常和狭义的中断。*
  - 因为发生中断意味着需要操作系统介入，开展管理工作，而操作系统的管理工作（如进程切换、分配I/O设备等）需要使用特权指令，所以CPU需要从用户态转为核心态。**中断可以使CPU从用户态切换为核心态，使操作系统获得计算机的控制权。**
- **核心态 -> 用户态**：通过执行一个特权指令，将程序状态字（PSW）标志位设置为用户态即可。

### 1.6. 内中断与外中断？

广义的中断可以分为内中断和外中断：

- **内中断**：也称为**异常**、例外、陷入，信号来源于CPU内部，与当前执行指令有关。
  - **陷阱、陷入**：trap，有意而为之的异常，如系统调用。
  - **故障**：fault，由错误条件引起的，可能被故障处理程序修复，如缺页中断。
  - **终止**：abort，不可修复的致命错误造成的结果，终止处理程序不再将控制返回给引入终止的应用，如整数除以0。
- **外中断**：是**狭义的中断**，信号来源于CPU外部，与当前执行的指令有关。
  - **外设请求**：如外围设备的中断，即I/O操作完成发出的中断信号。
  - **人工干预**：如用户强行终止一个进程。

### 1.7. Linux的进程地址空间？

![1620546981765](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620546981765.png)

- **栈**：stack，进程运行的栈，存储局部变量、临时变量，函数调用时，存储函数的返回指针，用于控制函数调用和返回。在程序块开始时自动分配内存，结束时自动释放内存，其操作方式类似于数据结构中的栈。
- **内存映射段**：memory mapping space（mmap），系统调用使用的空间，通常用于文件映射到内存，在进程创建时，会将程序用到的平台、动态链接库加载到该区域。
- **堆**：heap，是能够动态分配的内存空间，需要程序员手工分配，分配方式类似于链表。
- **未初始化过的数据**：bss segment，存储未初始化的全局或者静态变量。
- **初始化过的数据**：data segment，存储已经初始化的全局或者静态变量。
- **程序段**：text segment，是程序代码在内存中的映射，存放函数体的二进制代码。

### 1.9. 内存保护、覆盖技术、内存交换、紧凑技术、虚拟内存技术？

- **内存保护**：保护各进程在自己的内存空间内运行，不会越界访问。
- **覆盖技术**：将程序分为多个段（即多个模块），常用的段常驻固定区，不常用段在需要时才调入覆盖区，替换覆盖区中原有的段。
- **内存交换**：内存紧张时，换出某些进程以腾出内存空间，再换入某些进程。
- **紧凑技术**：用于解决分区分配遗留碎片的问题，通过在内存中移动程序，将所有小的空闲区域合并为大的空闲区域。
- **虚拟内存技术**：允许一个作业分多次调入内存，其实现建立在离散分配的内存管理方式基础上，分为**请求分页存储管理**、**请求分段存储管理**以及**请求段页式存储管理**。
  - **请求调页功能**：访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存。
  - **页面置换功能**：内存空间不够时，将内存暂时用不到的信息换出到外存。

### 2.0. 外部碎片与内部碎片？

- **外部碎片**：指内存中某些空闲分区由于太小而难以利用上。
- **内部碎片**：指分配给某进程的内存区域中，如果有些部分没有用上，那么就说有内部碎片。

### 2.1. 操作系统内存管理方式？

> 连续分配管理，指为一个用户程序分配一个**连续的内存空间**，分为单一连续分配、固定分区分配和动态分区分配。
>
> 非连续分配管理，允许一个程序**分散**地装入到不相邻的内存分区中，分为基本分页存储管理、基本分段存储管理和基本段页式管理方式。

#### 连续分配管理

##### 1. 单一连续分配

- 思想：内存被分为**系统区和用户区**，系统区通常位于内存的低地址部分，用于存放操作系统相关数据。用户区用于存放用户进程相关数据。
- 特点：内存中只能有一道用户程序，用户程序独占整个用户区。
- 优点：实现简单、无外部碎片、无需进行内存保护。
- 缺点：只能用于单用户、单任务的操作系统中，有内部碎片，存储器利用率极低。
- ![1620549393027](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620549393027.png)

##### 2. 固定分区分配

- 思想：将整个用户空间划分为若干个**固定大小的分区**，在每个分区中只装入一道作业。
- 特点：该方式是最早、最简单的一种可运行多道程序的内存管理方式。
- 分类：分区大小相等、分区大小不等（需要有分区说明表）。
- 优点：实现简单、无外部碎片。
- 缺点：
  - 当用户程序太大时，可能所有的分区都满足不了要求，此时不得不采用覆盖技术来解决，降低性能。
  - 会产生内部碎片、内存利用率低。
- ![1620549849883](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620549849883.png)

##### 3. 动态分区分配

- 思想：又称可变分区分配，该方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小**动态地建立分区**，使分区大小适合程序的需要。
- 特点：系统分区大小和数目可变。
- 内存使用记录方式：
  - 空闲分区表：每个空闲分区对应一个表项，包含分区号、分区大小、分区起始地址信息等。
  - 空闲分区链：每个分区的起始部分和末尾部分分别设置前向指针和后向指针，其中起始部分可记录分区大小等信息。
- 动态分区分配算法：
  - 首次适应算法：First Fit，空闲分区按**地址递增**的次序链接，分配内存时顺序查找，找到满足要求的第一个空闲分区。
    - 优点：最简单、性能最好。
    - 缺点：低地址部分会出现很多很小的空闲分区，增加查找的开销。
  - 最佳适应算法：Best Fit，空闲分区按**容量递增**的次序链接，分配内存时顺序查找，找到满足要求的第一个空闲分区。
    - 缺点：会产生很多、很小、难以利用的外部碎片。
  - 最坏适应算法：Worst Fit，又称最大适应算法，空闲分区按**容量递减**的次序链接，分配内存时顺序查找，找到满足要求的第一个空闲分区。
    - 缺点：每次都选择最大的分区分配，会导致后面的大进程无大分区可分配。
  - 邻近适应算法：Next Fit，空闲分区以**地址递增**的次序链接（循环链表），分配内存时从**上次查找结束的位置**开始查找，找到满足要求的第一个空闲分区。
    - 缺点：相比首次适应算法，会出现高地址部分被分割成多个小分区，导致后面的大进程无大分区可配。
- 优点：可根据装入进行大小动态分配、没有内部碎片、支持多道程序。
- 缺点：有外部碎片，可以通过**紧凑技术**来解决外部碎片。
- ![1620550822833](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620550822833.png)

#### 非连续分配管理

##### 1. 基本分页存储管理

- 思想：把**内存分为一个个相等的小分区**，再按照分区大小把**进程拆分一个个小部分**。

- 相关概念：

  ![1620554821838](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620554821838.png)

  - 页框：又称页帧、内存块、物理块，是指将内存空间分为一个个大小相等的分区。
  - 页框号：又称页帧号、内存块号、、物理块号，是指每个页框的编号，是从0开始的。
  - 页面：又称页，是指将用户进程的地址空间分为与页框大小相等的一个个区域。
  - 页号：是指每个页面的编号，也是从0开始的。注意的是，进程最后一个页面可能没有一个页框那么大，所以当页框过大时，会产生过大的内部碎片。
  - 页面长度：又称页面大小，每个页面的内存大小，一般要为2的整数幂，且等同于页框大小。
  - 页面始址：对应页面在内存中的起始物理地址。
  - 页内偏移量：又称页内地址，逻辑地址在页面内的偏移量。
  - 页表：负责记录进程页面和实际存放的内存块之间的对应关系。
  - 页表长度：指这个页表中一共有几个页表项，即一共有几页。
  - 页表项：进程每一页对应一个页表项，页表项 = 页号 + 块号。而**每个页表项长度是相同的，所以页号是隐含的**（因为可以算出来最大页表项长度）。页表项也是存放在页框中的，实际应用中，往往会使得每个页框恰好可以装得下整数个页表项（这样不会有内部碎片）。
  - 页表项长度：每个页表项的内存大小。最大页表项长度 = 总内存大小 / 页面长度。

- 特点：

  - 操作系统以页框为单位，为各个进程分配内存空间，进程的每个页面分别放入一个页框中，即进程的页面和内存的页框是一一对应的关系。
  - 各个进程页面不必连续存放，也不必按照先后顺序来存放，可以放到不相邻的各个页框中。
  - 页面外的实际物理地址是离散的，页面内的实际物理地址是连续的。
  - **页式管理中的地址是一维的**，即只要给出了一个逻辑地址，系统就可以自动算出页号、页内偏移量，并不需要显示告诉页内偏移量占多少位，因为页面大小是系统确定好了的（页面大小确定则逻辑地址结构也确定了）。

- **物理地址转换**：

  - 页号 = 逻辑地址 / 页面长度
    - M位内存，K位页面大小时，高（M - K）位表示页号。
  - 页内偏移量 = 逻辑地址 % 页面长度
    - M位内存，K位页面大小时，低K位表示页内偏移量。
    - K位页内偏移量，则页面大小为2^K大小。
  - 页面始址 = 内存块号 * 内存块大小
  - 物理地址 = 页面始址 + 页内偏移量

- **基本地址变换机构**：

  - 作用：用于实现逻辑地址到物理地址转换的一组硬件机构，即**硬件实现物理地址转换**。
  - 相关概念：
    - 页表寄存器：PTR，存放页表在内存中的起始地址F和页表长度M。在进程未执行时，页表始址和页表长度放在进程控制块PCB中，当进程被调度时，操作系统内核才会把它们放到PTR中。
  - 计算过程：

  ![1620555134892](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620555134892.png)

  1. 根据逻辑地址，计算出页号（高M-K位）和页内偏移量（低K位）。
  2. 判断页号是否越界：页号 <= 页表长度 - 1。
  3. 第一次访存（可用快表优化）：查询页表，找到页号对应的页表项，确定页面的内存块号：页表项地址 = 页表起始地址 + 页号 * 页表项长度。
  4. 用内存块号和页内偏移量，计算得到物理地址：物理地址 = 页面始址 + 页内偏移量 = 内存块号 * 页面大小 + 页内偏移量。
  5. 第二次访存：访问目标内存单元。

- **具有快表的地址变换机构**：

  - 作用：是基本地址变换机构的改进版本，**加快访存速度**。
  - 相关概念：
    - **局部性原理**：
      - **时间局部性**：如果执行了程序中的某条指令，那么在不久之后很可能再被执行。如果某个数据被访问过，那么在不久之后很可能再被访问。（因为程序中存在大量的循环）
      - **空间局部性**：如果程序访问了某个存储单元，那么在不久之后其附近的存储单元很有可能被访问。（因为很多数据在内存中都是连续存放的）
      - 应用：由于局部性原理，程序很有可能连续多次查询同一个页面，即同一个页表项，因此产生了**快表**机制。
    - 快表：TLB，联想寄存器，是一种访问速度比内存快很多的高速缓冲存储器，用来存放当前访问的**若干页表项**，以加速地址变换的过程。而内存中的页表成为慢表。
  - 计算过程：

  ![1620559002478](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620559002478.png)

  1. 根据逻辑地址，计算出页号（高M-K位）和页内偏移量（低K位）。
  2. 判断页号是否越界：页号 <= 页表长度 - 1。
  3. **先查询快表**，如果要访问的页表项在快表中有副本，则直接取出，否则需要第一次访存：查询页表，找到页号对应的页表项，再**把页表项拷贝一份到快表中**。接着确定页面的内存块号：页表项地址 = 页表起始地址 + 页号 * 页表项长度。
  4. 用内存块号和页内偏移量，计算得到物理地址：物理地址 = 页面始址 + 页内偏移量 = 内存块号 * 页面大小 + 页内偏移量。
  5. 第二次访存：访问目标内存单元。

- **两级页表**：

  - 作用：**离散存储页表项**、页表项需要是调入内存（**虚拟内存技术**：页表项中增加是否已调入的标志位）。

  - 相关概念：

    ![1620560132360](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620560132360.png)

    - 二级页表：用于将常常的页表项分页。
    - 页目录表：又称外层页表、顶层页表，用于记录分页页表项后的二级页表的目录。
    - 逻辑地址结构：32位 = 10位一级页号 + 10位二级页号 + 页内偏移量

##### 2. 基本分段存储管理

- 思想：按照程序自身的逻辑关系，划分程序为若干个段，每一段都有一个段名（从0开始）。内存分配时，以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻。

- 相关概念：

  - 段号：段名，段号的位数决定了每个进程最多可以分几个段。
  - 段内地址：即段内偏移量，段内地址的位数决定了每个段的最大长度是多少。
  - 段表：记录进程各个逻辑的段在内存中的存放位置，每个进程一张，包括段号、段长、段基址。
  - 段表项：进程的每一段逻辑段对应一个段表项。每个段表项长度是相同的，所以段号是可以隐含的，不需要占存储空间。
  - 段表项长度：每个段表项的内存大小。最大段表项长度 = 最大段长位数 + 最大地址位数。

- 物理地址变换过程：

  ![1620561048183](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620561048183.png)

  1. 根据逻辑地址，得到段号（高M/2位）、段内地址（低M/2位）。
  2. 判断段号是否越界：段号 <= 段表长度 - 1。
  3. 第一次访存（可用快表优化）：查询段表，找到对应的段表项：段表项始址 = 段表始址 + 段号 * 段表项长度。
  4. 检查段内地是否超过段长：段内地址 <= 段长。
  5. 计算得到物理地址：物理地址 = 段基址 + 段内地址。
  6. 第二次访存：访问目标内存单元。

##### 3. 段页式管理

- 思想：将进程按逻辑模块分段，接着将各段分页，再将内存空间分为大小相同的内存块，最后进程将各页面分别装入各内存块中。

- 作用：结合分段管理的优点和分页管理的优点，既能有效提高内存利用率，也容易实现信息的共享与保护。

- 物理地址变换过程：

  ![1620562681599](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620562681599.png)

  1. 根据逻辑地址，得到段号（高M/2位）、页号（低M/2-K位）、页内偏移量（低K位）。
  2. 判断段号是否越界：段号 <= 段表长度 - 1。
  3. 第一次访存（可用快表优化）：查询段表，找到对应的段表项：段表项始址 = 段表始址 + 段号 * 段表项长度。
  4. 检查页号是否越界：页号 <= 页表长度 - 1。
  5. 第二次访存（可用快表优化），根据段表中的页表存放块号、页号查询页表，找到对应的页表项：页表项始址 = 页表始址 + 页号 * 页表项长度。
  6. 根据页表项中的内存块号、页内偏移量，计算得出物理地址：物理地址 = 页面始址 + 页内偏移量 = 内存块号 * 页面大小 + 页内偏移量。
  7. 第三次访存，访问目标内存单元。

### 2.2. 分页管理与分段管理的区别？

|                  | 分页管理                                           | 分段管理                                                     |
| ---------------- | -------------------------------------------------- | ------------------------------------------------------------ |
| 管理维度         | 内存分区、进程分页，页是信息的物理单位             | 进程分段，段是信息的逻辑单位                                 |
| 透明度           | 对用户是透明的                                     | 对用户可见，用户编程需要显示给出段名                         |
| 单位大小         | 页大小固定，由系统决定                             | 段长度不固定，取决于编写的程序                               |
| 用户进程地址空间 | 是一维的，用户只需要给出一个助记符表示逻辑地址即可 | 是二维的，用户既要给出段名，也要给出段内地址                 |
| 目的             | 为了实现离散分配，提高内存利用率                   | 为了更好地满足用户需求                                       |
| 共享与保护       | 不容易实现信息共享与保护                           | 纯代码或可重入代码，更容易实现信息的共享与保护，只需要各进程指向同一个段即可实现共享 |
| 优点             | 内存空间利用率高、不会产生外部碎片                 | 没有内部碎片、容易实现信息共享与保护                         |
| 缺点             | 会产生少量的页内碎片、不容易实现信息共享与保护     | 段长过大难以分配连续空间、会产生外部碎片（可通过紧凑技术解决） |

### 2.3. 请求分页管理？

> **虚拟内存技术**：允许一个作业分多次调入内存，其实现建立在离散分配的内存管理方式基础上，分为**请求分页存储管理**、**请求分段存储管理**以及**请求段页式存储管理**。
>
> **请求调页功能**：访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存。
>
> **页面置换功能**：内存空间不够时，将内存暂时用不到的信息换出到外存。

- 特点：请求分页存储管理与基本分页存储管理的主要区别：需要操作系统提供**请求调页**（调入）以及**页面置换**（调出）功能。

- **页表机制**：也叫请求页表，是实现请求调页和页面置换功能的基础。对比基本分页存储管理的页表增加了4个字段：

  - 状态位：表示当前页面是否已经调入了内存。状态位为0代表当前页面还没有存在内存中。
  - 访问字段：用于记录当前页面最近被访问过几次，或者上次访问的时间，以供置换算法选择换出页面时参考。
  - 修改位：用于标记当前页面调入内存后是否被修改过（没有被修改过的页面是不需要写会外存的）。
  - 外存地址：表示当前页面在外存中的存放位置。

- **缺页中断机构**：**请求调页**的基础，在请求分页系统中，当要访问的页面不存在时，会产生一个**缺页中断**（内中断-故障），然后操作系统的缺页中断处理程序处理该中断。此时的缺页进程会**阻塞**，被放入阻塞队列，在调页完成后，操作系统才将其唤醒，放回就绪队列。

  缺页中断机构处理中断逻辑如下：

  - 如果内存中有空闲块，则为进程分配一个空闲块，将所缺失的页面装入该块，并修改请求页表中相应的页表项。
  - 如果内存中没有空闲块，则由**页面置换算法**选择一个页面淘汰，同时若该页面在内存期间被修改过，则还需要将其写回外存，而未修改过的页面则不需要写回外存。

- **地址变换机构**：

  与基本分页存储管理的页表不同的是：

  - 找到页表项时，需要判断页面是否在内存中。
  - 若页面不在内存中，则需要请求调页。
  - 如果调入页面内存空间不够时，需要进行页面置换。
  - 页面被访问、页面调入以及页面调出后，需要修改请求页表中相应的页表项。

![1620573633869](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620573633869.png)

### 2.4. 页面置换算法？

请求分页系统中，在内存空间不够时，由操作系统负责将内存中暂时用不到的信息换出到外存。

页面置换算法用于决定应该换出**哪个页面**到外存。

**页面的换入、换出**需要磁盘I/O，开销比较大，因此好的页面置换算法应该追求**更少的缺页率**，以减少页面换入、换出的次数。

缺页不等于页面置换，只有在缺少空闲内存块才需要发生页面置换。

#### 1. 最佳置换算法OPT

- 概念：optimal，每次淘汰**未来永不使用**或者**未来最长时间不再被访问**（顺方向）的页面。
- 优点：可以保持**最低的缺页率**。
- 缺点：**实际上无法实现**，因为操作系统无法提前预判未来的页面访问序列。

![1620648468359](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620648468359.png)

#### 2. 先换先出置换算法FIFO

- 概念：first in first out，每次淘汰**最早进入内存**的页面。
- 实现方法：把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时，只需要选择对头页面即可。
- **Belady异常**：贝拉底异常，指当为进程分配的内存块增大时，缺页的次数不减反增的异常现象。FIFO算法是唯一一个会出现Belady异常的页面置换算法。
- 优点：实现简单。
- 缺点：会有Belady异常，与运行时的规律不适应（因为先进入的页面后面也有可能最经常被访问），性能极差。 

![1620650037437](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620650037437.png)

![1620650005876](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620650005876.png)

#### 3. 最近最久未使用算法LRU

- 概念：least recently used，每次淘汰**最近最久未使用**（逆方向）的页面。
- 实现方法：在每个页面对应的页表项中，用**访问字段**来记录该页面从上次被访问到现在经历的时间t，当要淘汰页面时，选择页面中t值最大的，就是最近最久未使用的页面了。
- 优点：考虑到了时间局部性，性能好，实际应用较多。
- 缺点：实现困难，开销大，实现需要专门的硬件支持。

![1620649947028](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620649947028.png)

```java
/**
 * @program: Java
 * @description: LRU最近最久未使用置换算法，通过LinkedHashMap实现
 * @author: Mr.Li
 * @create: 2020-07-17 10:29
 **/
public class LRUCache {
    private LinkedHashMap<Integer,Integer> cache;
    private int capacity;   //容量大小

    /**
     *初始化构造函数
     * @param capacity
     */
    public LRUCache(int capacity) {
        cache = new LinkedHashMap<>(capacity);
        this.capacity = capacity;
    }

    // 使用过则需要放到链表尾部, 代表经常被使用，而链头代表的是最近最久未被使用的结点
    public int get(int key) {
        //缓存中不存在此key，直接返回
        if(!cache.containsKey(key)) {
            return -1;
        }

        int res = cache.get(key);
        cache.remove(key);   //先从链表中删除
        cache.put(key,res);  //再把该节点放到链表末尾处
        return res;
    }

    // 使用过则需要放到链表尾部, 代表经常被使用，而链头代表的是最近最久未被使用的结点
    // 在链表满时，还需要删除最近最久未被使用的结点，即链头结点
    public void put(int key,int value) {
        if(cache.containsKey(key)) {
            cache.remove(key); //已经存在，在当前链表移除
        }
        if(capacity == cache.size()) {
            //cache已满，删除链表头位置
            Set<Integer> keySet = cache.keySet();
            Iterator<Integer> iterator = keySet.iterator();
            cache.remove(iterator.next());
        }
        cache.put(key,value);  //插入到链表末尾
    }
}

```

```java
/**
 * @program: Java
 * @description: LRU最近最久未使用置换算法，通过LinkedHashMap内部removeEldestEntry方法实现
 * @author: Mr.Li
 * @create: 2020-07-17 10:59
 **/
class LRUCache {
    private Map<Integer, Integer> map;
    private int capacity;
	
    /**
     *初始化构造函数
     * @param capacity
     */
    public LRUCache(int capacity) {
        this.capacity = capacity;
        map = new LinkedHashMap<Integer, Integer>(capacity, 0.75f, true) {
            @Override
            protected boolean removeEldestEntry(Map.Entry eldest) {
                // 容量大于capacity 时就删除，删除最近最久未被使用的空闲结点
                return size() > capacity;
            }
        };
    }
    public int get(int key) {
        //返回key对应的value值，若不存在，返回-1
        return map.getOrDefault(key, -1);
    }

    public void put(int key, int value) {
        map.put(key, value);
    }
}
```

#### 4. 时钟置换算法CLOCK

- 概念：又称最近未用算法（NRU，not Recently Used），对比OPT和LRU，这是一种**性能和开销较平衡**的算法。
- 实现方法：

1. 为每个页面设置访问位（**访问位为1表示最近访问过，访问位为0表示最近没有访问过**），再将内存中的页面通过链表指针链接成一个循环队列。
2. 当页面被访问时，访问位将置为1。
3. 在淘汰页面时，循环检查访问位，把为1的置为0，为0的淘汰，如果第一轮全为1，则置换为0后进行第二轮扫描，所以**最多会经过2轮扫描**。
4. 而被置换进行的页面会被置为1，且扫描指针指向下一个页面。

- 优点：实现简单、算法开销小。
- 缺点：未考虑页面是否被修改过。

![1620651040375](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620651040375.png)

#### 5. 改进型时钟置换算法

- 概念：由于淘汰被修改过的页面时，需要写回外存，所以在时钟置换算法CLOCK的基础上，应该优先淘汰**最新没被修改过、没被访问过的**页面，避免写回外存的I/O操作。
- 实现方法：

1. 每个页面增加修改位（**修改位为0表示没有被修改过，修改位为1表示页面被修改过**），用（访问位，修改位表示），将所有可能被置换的页面排成一个循环队列。
2. 第一轮扫描：扫描第一个（0，0）即**最近没被修改过、没被访问过**的页面，本轮扫描不修改任何标志位。
3. 第二轮扫描：第一轮失败后，需要重新扫描。扫描第一个（0，1）即**最近被修改过、没被访问过**的页面用于替换，本轮扫描过的访问位置为0。
4. 第三轮扫描：第二轮失败后，需要重新扫描。扫描第一个（0，0）即**最近没被修改过、但被访问过**的页面用于替换，本轮扫描不修改任何标志位。
5. 第四轮扫描：第三轮失败后，需要重新扫描。扫描第一个（0，1）即**最近被修改过、也被访问过**的页面用于替换。改进型CLOCK算法淘汰一个页面**最多经过4轮扫描**。

- 优点：算法开销较小、性能也不错、考虑了页面是否被修改过（有修改位和访问位）。

![1620652055064](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620652055064.png)

### 2.5. 死锁的条件与解决方式？

> 哲学家进餐问题：每位哲学家都在等待自己右边的人放下筷子，即这些哲学家进程都因等待筷子资源而被阻塞，这就是发生了死锁。

- **死锁**：指在并发环境，**各进程因竞争资源而造成的一种互相等待对方手里资源**，导致各进程都阻塞，无法向前推进的现象。发生死锁后，若无外力干涉，这些进程都将无法向前推进。

- **死锁产生的必要条件**：产生死锁必须**同时满足**以下四个条件，只要其中任一条件不成立，死锁就不会发生。

  - **互斥条件**：进程对所分配的**资源不允许其他进程访问**，若其他进程访问该资源，只能等待至占有该资源的进程释放该资源。
  - **不剥夺条件**：进程所获得的资源在未使用完之前，**不可被剥夺**，只能主动释放。
  - **请求和保持条件**：进程获得一定的资源后，又对其他资源发出请求，且由于互斥条件进入阻塞状态后，还对自己占有的资源**保持不放**。
  - **循环等待条件**：存在一种**进程资源的循环等待链**，链中的每一个进程占有的资源被下一个进程所等待。
    - 注意！发生死锁时一定有循环等待，但发生循环等待时未必发生死锁（循环等待是死锁的必要不充分条件）。但如果系统中每类资源都只有一个，那循环等待则是死锁的充分必要条件。

- **死锁场景**：**对不可剥夺资源的不合理分配，可能会导致死锁。**

  - 对系统资源的竞争：各进程对不可剥夺资源的竞争可能引起死锁（如打印机），而对可剥夺资源的竞争是不会引起死锁的（如CPU）。
  - 进程推进顺序非法：请求和释放资源的顺序不当从而导致死锁。

- **死锁的处理策略**：

  - **预防死锁**：是**不允许死锁发生的静态策略**，破坏死锁的四个必要条件中的某一个。

    - **破坏互斥条件**：
      - 操作系统层面：采用SPOOLING技术，指操作系统用于把独占设备在逻辑上改造成共享设备。
      - 缺点：并不是所有的资源都可以改造成可共享使用的资源。很多时候都无法破坏互斥条件。
      - **Java层面**：乐观锁，CAS。
    - **破坏不可剥夺条件**：
      - 操作系统层面：进程请求不到其他资源时，必须立即释放保持的所有资源，或者考虑进程优先级强行剥夺想要的资源。
      - 缺点：实现比较复杂、释放资源可能会造成进程前一阶段的工作失效、反复申请和释放资源会增加系统开销，降低系统吞吐量、方案一可能会导致进程饥饿的发生。
      - **Java层面**：悲观锁，synchronized、ReentrantLock。
    - **破坏请求和保持条件**：
      - 操作系统层面：采用**静态分配方式**，进程运行需要一次申请完所有需要的资源，未满足则不能投入运行。一旦运行后，资源一直归它所有，且它不会再请求其他资源。
      - 缺点：资源利用率极低、可能会导致别的进程发生饥饿。
      - **Java层面**：数据库deadLock超时，即数据库通过锁定等待超时解决死锁。
    - **破坏循环等待条件**：
      - 操作系统层面：采用**顺序资源分配方式**，对系统该资源编号，规定每个进程必须按编号递增的顺序请求资源，对于编号相同的资源会一次申请完。
      - 缺点：不方便增加新的设备、实际使用资源的顺序可能和编号递增顺序不一致，可能会导致资源浪费、用户变成麻烦。

  - **避免死锁**：是**不允许死锁发生的动态策略**，避免系统进入**不安全状态**。

    - **安全序列**：指如果系统按照这种序列分配资源，每个进程都能顺利完成（安全序列可能有多个）。此时系统为**安全状态**，一定不会发生死锁。而如果分配资源后，系统中找不出任何一个安全序列，则系统进入了**不安全状态**，意味着之后可能发生死锁。

    - **银行家算法**：在资源分配之前先预判本次分配是否会导致系统进入不安全状态，从而决定是否答应该分配的请求，用于**避免死锁**。

      - 实现思路：保证优先分配资源给进程后，进程能够顺利执行完并归还资源，确保是安全状态。
      - 实现方法：Max矩阵、Allocation矩阵、Need矩阵、Available数组、Request数组、预判计算、回溯资源。

      ![1620737316076](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620737316076.png)

  - **死锁的检测和解除**：**允许死锁发生**，系统负责检测出死锁并解除。

    - 死锁的检测：

      - 数据结构：两种结点（进程结点、资源结点），两种边（请求边、分配边）。
      - 算法思想：最终能消除所有变，则称这个图是可完全被简化的，此时一定没有发生死锁（相当于找到了一个安全序列）。反之，如果**最终不能消除所有边，那么此时就发生了死锁（死锁定理）**。
      - 实现方法：找到孤点进程（有向边相连以及不阻塞的进程）、简化边、继续简化...

      ![1620737385049](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620737385049.png)

    - **死锁的解除**：

      - 死锁的进程：用死锁检测算法化简资源分配图后，还连着边的那些进程才是死锁进程。
      - **主要方法有**：
        - **资源剥夺法**：**挂起（暂时放到外存上）某些死锁进程，并抢占它的资源**，将这些资源分配给其他死锁的进程。
          - 缺点：需要防止进程挂起过久导致出现饥饿问题。
        - **撤销进程法**：又称**终止进程法**，强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。
          - 缺点：虽然实现简单，但付出的代价是很大的。
        - **进程回退法**：让一个或者多个死锁进程回退到足以避免死锁的地步。
          - 缺点：操作系统需要记录进程的历史记录，设置还原点。
      - **考虑的维度**：进程优先级低的、执行时间少的、距离完成时间较久的、持有资源多的、批处理式的死锁进程。 

### 2.6. 死锁、饥饿、死循环？

- **死锁**：指各进程互相等待对方手里资源，导致各进程都阻塞，无法向前推进的现象。比如哲学家进餐问题。

- **饥饿**：指由于长期得不到想要的资源，某进程无法向前推进的现象。比如短进程优先（SPF）算法，会导致长进程饥饿问题。

- **死循环**：指某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug导致的，有时是程序员故意设计的。

  |          | 死锁                                                         | 饥饿                                                         | 死循环                                 |
  | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------------------------- |
  | 共同点   | 都是进程无法向前顺利推进的现象                               | -                                                            | -                                      |
  | 进程数量 | 至少有两个或者两个以上的进程                                 | 可能只有一个进程                                             | 可能只有一个进程                       |
  | 进程状态 | 一定处于阻塞状态                                             | 可能是阻塞状态（长期得不到I/O设备），也可能是就绪状态（长期得不到处理机） | 可以是运行状态                         |
  | 原因     | 由于**操作系统**分配资源策略不合理导致的（各进程互相等待对方手里的资源） | 由于**操作系统**分配资源策略不合理导致的                     | 由代码逻辑错误导致的（**管理者问题**） |



## 4. 设计模式基础

### 1.1. 六大原则

|              | 总结                                                     |
| ------------ | -------------------------------------------------------- |
| 单一职责原则 | 实现类要职责单一                                         |
| 里氏替换原则 | 不要破坏继承体系                                         |
| 依赖倒置原则 | 要面向接口编程                                           |
| 接口隔离原则 | 设计接口时要精简单一                                     |
| 迪米特法则   | 要减少对其他类的直接依赖、减少类对外暴露的方法，降低耦合 |
| 开放原则     | 要对扩展开放，对修改关闭                                 |

#### 1. 单一职责原则

- 概念：**一个类只负责一项职责**，不要存在本职责外导致类发生变更的原因。
- 问题由来：如果类T负责两个不同的职责P1和P2，当职责P1需求发生改变修改T时，可能会导致P2功能发生故障。
- 原因分析：出现了职责扩散。
- 解决方案：
  - 根据P1和P2职责，划分为类1和类2。
  - 在职责扩散到无法控制之前，对代码进行部分重构。
- 优点：
  - 可以降低类的复杂度，一个类只负责一项职责，逻辑简单清晰。
  - 可提高类的可读性和系统的可维护性。
  - 减少需求变更时对其他功能的影响，减少出现的风险。
- 总结：
  - 只有逻辑足够简单，才可以在代码级别上违反单一职责原则。
  - 只有类中方法数量足够少，才可以在方法级别上违反单一职责原则。
  - 模块化的程序设计以及在员工工作安排上面，都适合单一职责原则。

#### 2. 里氏替换原则

- 概念：子类可以扩展父类的功能，但不能改变父类原有的功能；子类可以替换父类，但方法或者行为不能发生改变。即**子类可以扩展父类的功能，但不能改变父类原有的功能**。
- 问题由来：子类B在扩展新功能时，有可能会导致父类原有的功能发生故障。
- 原因分析：继承的弊端，会给程序代理侵入性，使得程序的可移植性减低，增加了对象的耦合性。
- 解决方案：
  - 类B扩展新功能时，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。
  - 如果子类对父类实现的方法进行修改，会对整个继承体系造成破坏，当子类要修改时，必须考虑所有的子类。并且，如果修改了父类，那么所有的子类功能可能都会发生故障。
- 优点：如果不遵循里氏替换原则，一开始程序可能是好好的，但是在之后的迭代过程中，代码出现问题的几率会大大增加，尤其当另外一个人接手项目之后。
- 总结：
  - 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。
  - 子类中可以增加自己独特的方法。
  - 当子类的方法重载父类的方法时，方法的前置条件（形参）要比父类方法更宽松。
  - 当子类的方法实现父类的抽象方法时，方法的后置条件（返回值）要比父类更严格。

#### 3. 依赖倒置原则

- 概念：**高层模块不能依赖底层模块**，二者都应该依赖其抽象；**抽象不应该依赖细节**，细节应该依赖抽象。
- 问题由来：类A（高层模块）本来依赖类B（低层模块），但现在要修改类A依赖类C（低层模块），修改程序时可能会导致不必要的风险。
- 解决方案：将类A改为依赖接口T，而类B和类C分别实现接口T，此时**类A可以通过接口T，间接访问类B和类C，大打降低了修改类A的几率**。
- 总结：
  - 相对于细节的多变性，抽象的东西要稳定得多。依赖倒置原则的核心思想是面向接口编程，通过使用接口或者抽象类来制定好规范和契约，不用去涉及任何具体的操作，将展开细节的任务交给实现类去完成，以达到解耦的目的。
  - 低层模块尽量都要有接口或者抽象类，高层模块尽量通过接口或者抽象类的形式访问低层模块。
  - 使用抽象类时，要遵循里氏替换原则。

#### 4. 接口隔离原则

- 概念：客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖都应该建立在**最小的接口**上面。
- 问题由来：类A通过接口T依赖了类B和类D，但类D不是类A想要依赖的。
- 解决方案：将臃肿的接口T拆分为独立的Tb和Td接口，类A只需要依赖Tb即可。
- 优点：提高内聚，减少对外交互，用最少的方法完成最多的事情。
- 总结：
  - 尽量细化接口，建立单一接口，使得接口中的方法尽量少。但要有限度，过小则会导致接口数量过多，增加复杂度。
  - 为单个类建立专用的接口，不要包含太多。依赖几个专用的接口要比依赖一个综合的接口灵活得多，即可以提高系统的灵活性和可维护性。
  - 为依赖接口的类定制服务，只暴露给调用类需要的方法，建立最小的依赖关系。
- 区别单一职责：
  - 单一职责注重的是职责；接口隔离注重的是接口依赖的隔离。
  - 单一职责约束的是实现类，其次才是接口和方法，针对的是程序中的实现细节；接口隔离约束的是接口，针对的是抽象和整体框架的构建。

#### 5. 迪米特法则

- 概念：又称**最少知道原则**，要求一个对象应该对其他对象有最少的了解。
- 优点：降低类之间的耦合，每个类尽量减少对其他类的依赖，尽量减少对外暴露的方法，使得功能模块独立，低耦合。
- 总结：
  - 减少对其他类的依赖，只通过成员变量、方法的输入输出参数来对类进行注入，减少方法体内部类的直接使用。
  - 减少类对外暴露的方法。
  - 虽然遵循迪米特法则可以避免和非直接的类通信，但如果要通信，则必然会通过一个中介发生联系，而过分地使用迪米特法则，会产生大量的中介和中间传递类，导致系统复杂度变高。

#### 6. 开闭原则

- 概念：软件中的对象（类、模块、函数等）应该**对于扩展是开放的，对与修改是关闭的**。
- 问题由来：对软件原有代码进行修改时，可能会将错误引入原本已经测试过的代码中，破坏原有系统。
- 解决方案：当软件需求发生变化时，尽量通过扩展实体的行为实现需求变化，而不是通过修改原有的代码来应对变化。

### 1.2. UML图

#### 1. 类UML

![1620827681262](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620827681262.png)

#### 2. 接口UML

![1620827737253](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620827737253.png)

#### 3. 类图UML

![1620827711036](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620827711036.png)

#### 4. 实现关系UML

![1620827793083](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620827793083.png)

#### 5. 泛化（继承）关系UML

![1620827830674](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620827830674.png)

#### 6. 依赖关系UML

![1620827777826](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620827777826.png)

#### 7. 一般关联关系UML

![1620827947066](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620827947066.png)

#### 8. 组合关系UML

![1620827976361](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620827976361.png)

#### 9. 聚合关系UML

![1620827988535](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620827988535.png)

### 1.3. 单例模式

某个类只能生成一个实例，该实例被全局访问，比如Spring容器一级缓存里的单例池。

- 优点：唯一访问、提高性能
- 缺点：不适合有状态且需要变更的实例
- 实现方式：**所有方式都会被反序列破坏，但是都可以通过单例对象添加Object#readResolve() 方法, 直接返回单例对象即可防止破坏。**

|                       | 懒加载 | 线程安全 | 其他优点     | 缺点                       | 推荐 |
| --------------------- | ------ | -------- | ------------ | -------------------------- | ---- |
| 饿汉式                | 否     | 是       | 简单、速度快 | 提早占用内存、不可参数构造 | 是   |
| 懒汉式                | 是     | 否       | 可参数构造   | 线程不安全                 | 否   |
| 懒汉式-锁实现         | 是     | 是       | 可参数构造   | 加锁导致效率低下           | 否   |
| 懒汉式-静态内部类实现 | 是     | 是       | -            | 不可参数构造               | 是   |
| 双重检查锁            | 是     | 是       | 可参数构造   | 实现较复杂、可被反射破坏   | 是   |
| 枚举类                | 是     | 是       | 不被反射破坏 | 实现较复杂、不可参数构造   | 是   |

#### 1. 饿汉式

```java
/**
 * 1、饿汉式
 */
public class Singleton1 implements Serializable {
    private static final Singleton1 instance = new Singleton1();

    public static Singleton1 getInstance(){
        return instance;
    }
    
    private Singleton1() {
        // 防⽌反射获取多个对象的漏洞 true
        if(instance != null){
            throw new RuntimeException("获取单例异常!");
        }
    }
    
    // 防止反序列化获取多个对象的漏洞
    private Object readResolve() throws ObjectStreamException {
        return instance;
    }

}
```

#### 2. 懒汉式

```java
/**
 * 2、懒汉式-线程不安全
 */
public class Singleton2 implements Serializable {

    private static Singleton2 instance;// 类初始化为null

    public static Singleton2 getInstance(int code){
        if(instance == null){
            instance = new Singleton2(code);
        }
        return instance;
    }
}
```

#### 3. 懒汉式-锁实现

```java
/**
 * 3、懒汉式-线程安全-锁方法实现
 */
public class Singleton3 implements Serializable {
    
    private static Singleton3 instance;// 类初始化为null

    public static synchronized Singleton3 getInstance(int code){
        if(instance == null){
            instance = new Singleton3(code);
        }
        return instance;
    }
}
```

#### 4. 懒汉式-静态内部类实现

```java
/**
 * 4、懒汉式-线程安全-静态内部类
 */
public class Singleton4 implements Serializable {
    
    private static class Holder {
        private static final Singleton4 SINGLE_TON = new Singleton4();
    }
    
    public static Singleton4 getInstance(){
        return Holder.SINGLE_TON;
    }
}

```

#### 5. 双重检查锁

```java
/**
 * 5、双重检查锁
 */
public class Singleton5 implements Serializable {

    // volatile防止重排序导致实例化未完成
    private volatile static Singleton5 instance;// 必须要保证可见性

    public static Singleton5 getInstance(int code){
        // 第一次减少锁的开销
        if(instance == null){
            synchronized (Singleton5.class){
                // 第二次防止重复
                if(instance == null){
                    instance = new Singleton5(code);
                }
            }
        }

        return instance;
    }
}
```

#### 6. 枚举类

```java
/**
 * 6、枚举(JDK 1.5后)
 */
public class Singleton6 implements Serializable {

    private static enum SingletonEum {
        INSTANCE;// 创建一个枚举类, 天生就是单例的

        private Singleton6 singleton6;

        SingletonEum() {// 创建时创建singleton6单例对象
            singleton6 = new Singleton6();
        }

        public Singleton6 getInstance(){
            return singleton6;
        }
    }

    // 调用getInstance()才使用枚举类, 才对枚举类进行加载, 再枚举类的构造方法中创建了单例
    public static Singleton6 getInstance() {
        return SingletonEum.INSTANCE.getInstance();
    }
}
```

### 1.4. 工厂模式

#### 1. 简单工厂模式

简单工厂模式是**由一个工厂对象决定创建出哪一种产品类的实例**，是工厂模式家族中最简单实用的模式，可以理解为是不同工厂模式的一个特殊实现。

- 组成：
  - 工厂类角色：简单工厂类，即是根据类型创建具体产品，是具体产品的逻辑封装。
  - 抽象产品角色：一般是指具体产品继承的父类或实现的接口。
  - 具体产品角色：具体的实现类，相当于抽象业务的落地。
- 优点：
  - 解耦：实现了对责任的分割，专门的工厂类用于创建产品，客户类免除了除直接创建产品对象的责任，而仅仅是消费产品。
  - 简单：客户类无须知道所创建的具体产品类的类名，只需要知道具体产品类的对应参数即可。
  - 可配置（解决方案）：通过引入配置文件，可以在不修改任何客户类代码的情况下，更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。
- 缺点：
  - 中心化：由于工厂类集中了所有产品的创建逻辑，一旦不能工作, 整个系统都要受到影响。
  - 类爆炸：使用简单工厂模式将会增加系统中类的个数，在一定程度上增加了系统的复杂度和理解度。
  - 不灵活：系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。
  - 不够体系化：由于使用了静态工厂方法，造成了工厂角色无法形成基于继承的等级结构。
- 使用场景：
  - 工厂类负责创建的对象比较少时。
  - 客户类只知道传入工厂的参数，对于如何创建对象逻辑不关心时。
  - 由于简单工厂很容易违反高内聚责任分配原则，因此一般只在很简单的情况下应用。

```java
// 客户类
public class Customer {

    public static void main(String[] args) {
        SimpleFatory simpleFatory = new SimpleFatory();
        simpleFatory.createProduct("HighLvA");
        simpleFatory.createProduct("B");
    }
}

// 抽象接口
public abstract class Product {

    public Product() {

    }
}

// 具体产品实现类
public class ProductA extends Product{

    public ProductA() {
        System.out.println("制造产品A: Product HighLvA...");
    }
}

// 简单工厂类
public class SimpleFatory {

    public Product createProduct(String type){
        switch (type){
            case "HighLvA":
                return new ProductA();
            case "B":
                return new ProductB();
            default:
                break;
        }

        return null;
    }
}
```

#### 2. 工厂方法模式

工厂方法模式的核心思想是**封装类中变化的部分**，提取其中个性化善变的部分为独立类，通过依赖注入以达到解耦、复用和方便后期维护拓展的目的。工厂方法模式是对简单工厂模式的**工厂做了抽象**。

- 组成：
  - 抽象工厂角色：工厂方法模式的核心，是具体工厂角色必须实现的接口或必须继承的父类，也就是对具体工厂的抽象。
  - 具体工厂角色：含有和具体业务逻辑有关的代码, 由客户类指明创建, 用于创建对应具体的产品对象。
  - 抽象产品角色：对比简单工厂模式，抽象逻辑没变。一般是指具体产品继承的父类或实现的接口。
  - 具体产品角色：对比简单工厂模式，抽象逻辑没变。具体的实现类，相当于抽象业务的落地。
- 优点：
  - 去中心化：工厂方法模式去掉了简单工厂模式中工厂的静态属性，使得它可以被子类继承，这样在简单工厂模式里集中在工厂方法上的压力，就可以由工厂方法模式里不同的工厂子类分担。
  - 开闭原则： 当有新的产品产生时，只要按照抽象产品角色、抽象工厂角色提供的合同来生成，那么就可以被客户使用，而不必去修改任何已有的代码。
- 缺点：
  - 类爆炸：在添加新产品时需要编写新的具体产品类，而且还要提供与之对应的具体工厂类。可见系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，而更多的类需要编译和运行，会给系统带来一些额外的开销。
- 使用场景：
  - 对于某种产品，调用者清楚地知道应该使用哪个具体工厂服务，从而实例化该具体工厂，生产出具体的产品。比如Java Collection中的iterator()方法。
  - 只是需要一种产品，而不想知道，也不需要知道究竟是哪个工厂生产的，即最终选用哪个具体工厂的决定权在生产者一方，生产者根据当前系统的情况来实例化一个具体的工厂返回给使用者，而这个决策过程对于**使用者来说是透明的**。

```java
// 客户类
public class Customer {

    public static void main(String[] args) {
        FactoryProductA factoryProductA = new FactoryProductA();
        factoryProductA.createProduct();

        FactoryProductB factoryProductB = new FactoryProductB();
        factoryProductB.createProduct();
    }
}

// 抽象产品类
public abstract class Product {

    public Product() {

    }
}

// 产品实现类
public class ProductA extends Product {

    public ProductA() {
        System.out.println("制造产品A: Product HighLvA...");
    }
}

// 抽象工厂类
public interface AbstractFatory {

    public Product createProduct();
}

// 工厂实现类
public class FactoryProductA implements AbstractFatory{

    @Override
    public Product createProduct() {
        return new ProductA();
    }
}
```

#### 3. 抽象工厂模式

抽象工厂是指当有**多个抽象角色**时使用的一种工厂模式，可以向客户提供提供一个接口，使客户在不必指定产品的具体参数情况下（工厂方法模式），创建**多个产品族中**的产品对象（由于有抽象工厂角色对多个工厂进行聚合, 暴露各种产品生产的接口）。

> 工厂方法模式，针对的是多个产品系列结构（同一个抽象产品角色, 同一个产品族）。
>
> 抽象工厂模式，针对的是多个产品族结构（多个抽象产品角色,多个产品族）。
>
> 一个产品族内有多个产品系列（同一个抽象产品角色, 同一个产品）。

- 核心思想：在抽象工厂中，增加创建其他产品族的生产接口，并在具体子工厂中实现。
- 优点：
  - 抽象工厂：也是工厂方法模式的优点，分离了具体的类，客户通过抽象接口操纵实例，产品的类名也在具体工厂的实现中被分离，它们不出现在客户代码中。
  - 多产品族：易于交换产品系列，只需要改变具体工厂或者调用不同的接口，即可生产不同的产品。
  - 产品一致：有利于产品的一致性，当一个系列的产品对象被设计成一起工作时，抽象工厂很容易实现一个应用一次只能使用同一个系列的对象。
- 缺点：
  - 难以支持新种类的产品：产品族扩展费力，因为抽象工厂接口确定了可以被创建的产品集合，假如产品族需要增加一个新的产品，则几乎所有的工厂类都需要进行修改。因此使用抽象工厂模式时，对产品等级结构的划分非常重要。
- 使用场景：
  - 一个系统要独立于它的产品创建、组合和表示时（无关性）。
  - 一个系统要由**多个产品系列**中的一个来配置时。
  - 需要强调一系列相关的产品对象的设计以便进行联合使用时。
  - 提供一个产品类库, 而只想显示它们的接口而不是实现时。
  - 如果创建的产品是一系列相互关联或者相互依赖的产品组时，可以使用抽象工厂模式。而如果产品间不存在关联或约束时，则使用多个独立的工厂来对产品进行创建，则更适合一点。

```java
// 客户类
public class Customer {

    public static void main(String[] args) {
        FactoryProductA factoryProductA = new FactoryProductA();
        factoryProductA.createProduct();
        factoryProductA.createNewProduct();

        FactoryProductB factoryProductB = new FactoryProductB();
        factoryProductB.createProduct();
        factoryProductB.createNewProduct();
    }
}

// 抽象产品类
public abstract class Product {

    public Product() {

    }
}

// 产品实现类
public class ProductA extends Product {

    public ProductA() {
        System.out.println("制造产品A: Product HighLvA...");
    }

}

// 抽象工厂类
public interface AbstractFatory {

    public Product createProduct();

    public NewProduct createNewProduct();
}

// 工厂实现类
public class FactoryProductA implements AbstractFatory {

    @Override
    public Product createProduct() {
        return new ProductA();
    }

    @Override
    public NewProduct createNewProduct() {
        return new NewProductA();
    }
}
```

### 1.5. 策略模式

定义一组算法，将**每一种算法**封装起来，从而使它们可以相互切换。

- 组成：
  - 策略封装角色：上层访问策略入口，持有抽象策略的引用（聚合关系）。
  - 抽象策略角色：提供接口或抽象类，定义策略组必须拥有的方法和属性。
  - 具体策略角色：实现抽象策略，定义具体的算法逻辑。
- 优点：
  - 重用：策略模式提供了管理相关**算法族**的方法，其等级结构定义了一个算法或者行为族，恰当使用继承和接口可以把公共的代码进行抽取，避免代码重复。
  - 减少嵌套：if-else语句不易维护，使用策略模式可以避免使用多重条件if-else语句。如果把采取哪一种算法或行为的逻辑与算法或行为本身的逻辑混合在了一起，统统列在一个语句里面，那这样比使用继承的办法还要原始和落后。
- 缺点：
  - 算法列表：客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择适当的算法类，因此，策略模式只适用于客户端知道算法或者行为的情况。
  - 类爆炸：由于策略模式把每个具体的策略实现都单独封装成类，如果备选的策略很多，那么对象的数目就会很可观。

```java
// 客户类
public class Client {

    public static void main(String[] args) {
        Context context = new Context(new StrategyB());
        context.useStrateyAlgorithmLogic();
    }
}

// 策略封装上下文对象
public class Context {

    private Strategy strategy;

    public Context(Strategy strategy) {
        this.strategy = strategy;
    }

    /**
     * 调用策略
     */
    public void useStrateyAlgorithmLogic(){
        strategy.algorithmLogic();
    }
}

// 策略抽象接口
public interface Strategy {

    // 具体算法逻辑
    public void algorithmLogic();
}

// 具体策略A
public class StrategyA implements Strategy{

    @Override
    public void algorithmLogic() {
        System.out.println("这是策略A...");
    }
}
```

### 1.6. 命令模式

将一个请求封装为一个对象，从而可以使用不同的请求对客户进行**参数化、请求排队、记录请求日志、命令撤销**等操作。

- 特点：当需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个时使用命令模式时使用，可以使得请求发送者与请求接收者相解耦。
- 组成：
  - 抽象命令类：Command，抽象出命令对象，可以根据不同的命令类型，写出不同的实现类。
  - 具体命令类：ConcreteCommand，实现了抽象命令对象的具体实现。
  - 调用者/请求者：Invoker，请求的发送者，通过命令对象来执行请求。一个调用者并不需要在设计时确定其接收者，因此它只与抽象命令之间存在关联。
  - 接收者：Receiver，执行与请求相关的操作，真正执行命令的对象，具体实现对请求业务的处理。
  - 客户类：Client，在客户类中创建调用者对象，具体命令类对象，在创建具体命令对象时指定对应的接收者。
- 优点：
  - 解耦：可以降低系统的耦合度。
  - 易用：可以容易地将新的命令加入到系统中。
  - 设计方便：可以容易地设计一个命令队列和宏命令（组合命令）。
  - 可撤销与重试：可以方便地实现对请求的Undo和Redo。
- 缺点：
  - 类爆炸：由于针对每一个命令都需要设计一个具体命令类，所以在使用命令模式时，可能会导致某些系统有过多的具体命令类。当某些系统可能需要大量具体命令类时，将会影响命令模式的使用。
- 使用场景：
  - 网络传输：命令的调用者和命令执行者之间存在不同的生命周期，意味着命令发送了并不是立即执行。即命令发送出去后，原先的请求发出者可能已经不存在了，而命令对象本身还在，可以通过网络传输到另一台机器，给执行者执行。比如, Struts2中的action调用。
  - 统一管理：命令需要进行各种管理逻辑，比如对多个命令的统一控制。
  - 撤销重试：系统需要支持撤销（反撤销)）或者重试操作时。命令对象可以把状态存储起来，等到客户端需要撤销命令所产生的效果时，可以调用undo（）方法，把命令所产生的效果撤销掉。命令对象还可以提供redo()方法，以供客户端在需要时再重新实施命令效果。比如数据库中的事务机制底层实现。
  - 回调：回调callBack（）系统的使用，其中callBack（）讲的就是先将一个函数登记上，然后在以后调用此函数。
  - 命令日志：将系统中所有命令记录在日志里，待系统奔溃时，可以根据日志中一条一条命令重新调用execute（）， 从而恢复系统在崩溃前所做的数据更新。

```java
// 客户类
public class Client {

    public static void main(String[] args) {
        Receiver receiver = new Receiver();
        RemoteInvoker remoteInvoker = new RemoteInvoker(new TurnUpCommand(receiver), new TurnDownCommand(receiver));

        // 操作遥控器
        remoteInvoker.turnDownButton();
        remoteInvoker.turnUpButton();
        remoteInvoker.undoButton();
        remoteInvoker.undoButton();
        remoteInvoker.redoButton();
        remoteInvoker.redoButton();
    }
}

// 接收者实现类-电视机
public class Receiver {

    public void turnUp(){
        System.out.println("跳转到上一个台...");
    }

    public void turnDown(){
        System.out.println("跳转到下一个台...");
    }
}

// 请求发送实现类-遥控器
public class RemoteInvoker {

    private Command turnUpCommand;
    private Command turnDownCommand;

    private Stack<Command> undoCommadStack;
    private Stack<Command> redoCommadStack;

    public RemoteInvoker(Command turnUpCommand, Command turnDownCommand) {
        this.turnUpCommand = turnUpCommand;
        this.turnDownCommand = turnDownCommand;

        undoCommadStack = new Stack<>();
        redoCommadStack = new Stack<>();
    }

    // 遥控器-切上一个台的按钮实现
    public void turnUpButton(){
        turnUpCommand.execute();
        undoCommadStack.push(turnUpCommand);
        if(!redoCommadStack.isEmpty()){
            redoCommadStack.clear();
        }
    }

    // 遥控器-切下一个台的按钮实现
    public void turnDownButton(){
        turnDownCommand.execute();
        undoCommadStack.push(turnDownCommand);
        if(!redoCommadStack.isEmpty()){
            redoCommadStack.clear();
        }
    }

    // 遥控器-undo按钮实现
    public void undoButton(){
        if(!undoCommadStack.isEmpty()){
            Command command = undoCommadStack.pop();
            command.undo();
            redoCommadStack.push(command);
        }else {
            System.out.println("按钮无效...");
        }
    }

    // 遥控器-redo按钮实现
    public void redoButton(){
        if(!redoCommadStack.isEmpty()){
            redoCommadStack.pop().execute();
        }else {
            System.out.println("按钮无效...");
        }
    }
}

// 命令接口
public interface Command {

    // 执行命令
    public void execute();

    // 撤销命令
    public void undo();
}

// 转上一个台具体命令
public class TurnUpCommand implements Command{

    private Receiver receiver;

    public TurnUpCommand(Receiver receiver) {
        this.receiver = receiver;
    }

    @Override
    public void execute() {
        receiver.turnUp();
    }

    @Override
    public void undo() {
        receiver.turnDown();
    }
}

// 转下一个台具体命令
public class TurnDownCommand implements Command{

    private Receiver receiver;

    public TurnDownCommand(Receiver receiver) {
        this.receiver = receiver;
    }

    @Override
    public void execute() {
        receiver.turnDown();
    }

    @Override
    public void undo() {
        receiver.turnUp();
    }
}
```

### 1.7. 代理模式

为其他对象**提供一种代理**，以控制对这个对象的访问。在某种情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到**中介**的作用。

- 组成：
  - 抽象角色：通过接口或者抽象类声明真实角色实现的业务方法。
  - 代理角色：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法，来实现抽象方法（持有真实角色对象的引用），并可以附加自己的操作。
  - 真实角色：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。
- 分类：
  - 静态代理：静态代理，是由程序员创建或者工具生成代理类的源码，再在编译生成代理类。所谓静态，也就是程序运行前就已经存在**代理类的字节码文件**，这时代理类和委托了类的关系在运行前就确定了。
  - 动态代理：动态代理在实现阶段不用关心代理类，而在**运行阶段**才指定哪一个对象。
    - 分类：JDK动态代理、CGLIB动态代理。
    - [2.6. 动态代理？](#2.6. 动态代理？)
- 优点：
  - 职责清晰：真实角色就是实现实际业务逻辑的，不用去关心其他非本职的业务。而通过后期的代理去完成那些非真实角色本职的业务，编程简洁清晰。
  - 保护目标对象：在客户端和目标对象中间存在代理对象，起到中介以及保护目标对象的作用。
  - 高扩展性：符合开闭原则，代理类的实现不是通过修改原有的代码，而是通过扩展的方式，织入新的业务代码。符合对修改关闭，对扩展开放的原则。

```java
// 客户类(静态代理)
public class Client {

    public static void main(String[] args) throws Throwable {
        UserService userService = new UserServiceImplStaticProxy(new UserServiceImpl());
        userService.save();       
    }
}

/**
 * 抽象角色: 用户服务接口
 */
public interface UserService {

    public void save();
}

/**
 * 真实角色: 用户服务接口实现类
 */
public class UserServiceImpl implements UserService {

    @Override
    public void save() {
        System.out.println("保存用户信息...");
    }
}

/**
 * 代理角色: 用户服务实现静态代理类
 */
public class UserServiceImplStaticProxy implements UserService{

    private UserService userService;

    public UserServiceImplStaticProxy(UserService userService) {
        this.userService = userService;
    }

    @Override
    public void save() {
        System.out.println("静态代理前...");
        userService.save();
        System.out.println("静态代理后...");
    }
}
```

### 1.8. 模板方法模式

定义一个操作中算法的骨架，将一些步骤延迟到子类中，使得子类可以不改变算法结构即可**重定义**该算法的某些特定步骤。

- 组成：
  - 抽象父类：实现了模板方法，定义了算法的骨架。
  - 具体类：实现抽象类的抽象方法，即不同对象实现不同的具体细节。
- 优点：
  - 灵活：具体细节步骤实现定义在子类中，子类定义详细处理算法不会改变算法整体结构。
  - 代码复用：代码复用的基本技术，在数据库设计中尤为重要。
  - 开闭原则：存在一种反向的控制结构，通过一个父类调用其子类的操作，通过子类对父类进行扩展增加新的行为，符合开闭原则。
- 缺点：
  - 类爆炸：每个不同的实现都需要定义一个子类，会导致类的个数增加，系统更加庞大。
- 使用场景：Spring、JDBC等各种框架中均有使用。

```java
// 客户类
public class Client {

    public static void main(String[] args) {
        /**
         * 模板方法模式:
         * a. 假设做菜有3步: 备料、做菜、上菜, 这三步是算法的骨架
         * b. 然后做不同菜需要不同的料, 做时不同的方法, 以及如何盛装给客人, 这些就是不同的实现细节
         */
        // 番茄炒蛋
        DodishTemplate eggsWithTomato = new EggsWithTomato();
        eggsWithTomato.dodish();

        // 红烧肉
        DodishTemplate braisedPork = new BraisedPork();
        braisedPork.dodish();
    }
}

// 抽象角色: 做菜的抽象父类
public abstract class DodishTemplate {

    /**
     * 做菜, 定义算法骨架
     */
    protected void dodish(){
        this.preparation();
        this.doing();
        this.carriedDishes();
    }

    /**
     * 备菜
     */
    protected abstract void preparation();

    /**
     * 做菜
     */
    protected abstract void doing();

    /**
     * 上菜
     */
    protected abstract void carriedDishes();
}

// 具体角色: 番茄炒蛋
public class EggsWithTomato extends DodishTemplate{

    @Override
    protected void preparation() {
        System.out.println("洗并切西红柿, 打鸡蛋...");
    }

    @Override
    protected void doing() {
        System.out.println("鸡蛋倒入锅里, 然后倒入西红柿一起炒...");
    }

    @Override
    protected void carriedDishes() {
        System.out.println("将炒好的西红寺鸡蛋装入碟子里, 端给客人吃...");
    }
}
```

### 1.9. 复合模式（MVC模式）

将多个模式结合起来形成一个框架，以解决一般性问题，在形式上，**复合模式是多个模式的结合**。

- 使用场景：
  - MVC就是典型的多个模式结合：
    - 观察者模式：V和C都是M的观察者，Model的状态更新要及时通知V更新视图，或者通知C做相应逻辑处理。
    - 策略模式：C是V的策略，所以V包含的控制逻辑就是选择策略，也就是选择控制器Controller。
    - 组合模式：V的自身实现应用了组合模式，即调用顶层容器的repaint方法，容器内的所有组件都会进行重绘。
  - MVC应用了多个模式，并能够较好的解决设计上的一般性问题，所以被成为复合模式。但应用复合模式的框架远不止MVC一个。

### 2.0. 适配器模式

定义一个包装类，用于**包装不兼容接口的对象**。把一个类的接口变换成客户端所期待的另一种接口，从而使原本接口不匹配而无法工作的两个类能够一起工作。

- 组成：
  - 包装类：适配器Adapter。
  - 被包装对象：适配器Adaptee，即被适配的类。
- 分类：
  - 类的适配器模式：
    - 特点：使用对象继承的方式实现，是静态的定义方式。
    - 优点：使用方便，代码简化，仅仅引入一个对象，并不需要额外地字段来引用Power实例。
    - 缺点：高耦合，灵活性低。在需要同时适配源类和其子类时，由于类的适配器不能和Adaptee子类一起工作，所以选择对象的适配器比较合适。
  - 对象的适配器模式：
    - 特点：使用对象组合的方式，是动态组合的方式。
    - 优点：灵活性高、低耦合。
    - 缺点：使用复杂、需要引入对象实例。在需要重新定义Adaptee部分行为时，由于类适配器可以重定义Adaptee部分行为，相当于子类覆盖父类的部分实现方法，所以选择类的适配器比较合适。

```java
// 客户类
public class Client {

    public static void main(String[] args) {
        // 获取进口电视机
        ImportedTv importedTv = new ImportedTv();
        
        // 类的适配器模式
        // 获取电视机电源适配器(实际上是一个电视机插头, 但也是个电源)
        TvPlug tvPlug = new PowerAdapter();
        // 开始转换电压
        tvPlug.converTo110v();
        // 开启电视机
        importedTv.work();
        
        // 对象的适配器模式
        // 获取新的电视机电源适配器(实际上是一个电视机插头, 但也是个电源)
        NewPowerAdapter newPowerAdapter = new NewPowerAdapter(new Power());
        // 开始转换电压
        newPowerAdapter.converTo110v();
        // 开启电视机
        importedTv.work();
    }
}

// 进口电视机
public class ImportedTv {

    public void work(){
        System.out.println("电视机正在开启...");
    }
}

// 被包装对象：电视机插头
public interface TvPlug {

    public void converTo110v();
}

// 被包装对象：电源
public class Power {

    public void supply220v(){
        System.out.println("提供220v电源...");
    }
}

// 包装对象：类的适配器模式-电视机电源适配器
public class PowerAdapter extends Power implements TvPlug {

    @Override
    public void converTo110v() {
        super.supply220v();
        System.out.println("开启转换电压...");
    }
}

// 包装对象：对象的适配器模式-电视机电源适配器
public class NewPowerAdapter implements TvPlug{

    private Power power;

    public NewPowerAdapter(Power power) {
        this.power = power;
    }

    public void converTo110v() {
        power.supply220v();
        System.out.println("开启转换电压...");
    }
}
```

### 2.1. 装饰者模式

通过创建一个包装对象，也就是用装饰来包裹真实的对象，在不必改变原类文件和使用继承的情况下，**动态地扩展**一个对象的功能。

- 特点：
  - 装饰对象和真实对象具有相同的接口，这样客户端对象就能以和真实对象相同的方式和装饰对象交互了。
  - 装饰对象包含一个真实对象的引用。
  - 装饰对象接收所有来自客户端的请求，它把这些请求转发给真实的对象。
  - 装饰对象可以在转发这些请求以前或者以后增加一些附加功能，这样就确保了在运行时，不用修改指定对象的结构就可以在外部增加附加的功能。
- 组成：
  - 顶层抽象父类：具有最一般的特性，是真实对象以及装饰组件的共同抽象。
  - 真实对象：代表的是具有业务意义的，能被修饰的底层对象。
  - 组件抽象父类：具有装饰组件的一般性，是装饰组件的抽象。
  - 包装对象：代表的是能够装饰真实对象的组件，实现了组件抽象父类。
- 优点：
  - 灵活：装饰者模式与继承关系的目的都是扩展对象功能，但是装饰者模式可以提供比继承更多的灵活性。
  - 高扩展：通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。
- 缺点：
  - 复杂：这种比继承更加灵活机动的特性，也同时意味着更多的复杂性。
  - 类爆炸：装饰者模式会导致设计中出现许多小类，如果过度使用，会使程序变得很复杂。
- 使用场景：
  - 需要扩展一个类的功能，或者给一个类添加附加职责。
  - 需要动态地给一个对象添加功能，这些功能可以再动态的撤销。
  - 需要增加由一些基本功能的排列组合而产生了非常大量的功能，而如果使用继承关系变得不现实。比如JDK中的IO类便使用了装饰者模式，其中的InputStream是顶层抽象父类，FilterInputStream是组件抽象父类。

```java
// 客户类
public class Client {

    public static void main(String[] args) {
        /**
         * 开始下单
         */
        // 要一杯 深焙咖啡, 摩卡, 奶泡
        Beverage beverage1 = new DarkRoast();
        beverage1 = new Mocha(beverage1);
        beverage1 = new Whip(beverage1);
        System.out.println(getDescAndCost(beverage1.getDescription(), beverage1.cost()));
    }

    public static String getDescAndCost(String desc, BigDecimal cost){
        return String.format("Description: %s, $%f", desc, cost);
    }
}

// 顶层抽象父类-饮料抽象类
public abstract class Beverage {

    private String description = "Unkown Beverage";

    /**
     * 获取饮料描述-子类中重写
     * @return
     */
    public String getDescription() {
        return description;
    }

    /**
     * 获取饮料价格-子类中实现
     * @return
     */
    public abstract BigDecimal cost();
}

// 真实对象：深焙咖啡类-一种具体的饮料
public class DarkRoast extends Beverage {

    @Override
    public String getDescription() {
        return "深焙咖啡";
    }

    @Override
    public BigDecimal cost() {
        return new BigDecimal("3.00");
    }
}

// 组件抽象父类-因为调料叠加以后也是一种饮料, 所以能继承饮料抽象类
public abstract class CondimentDecorator extends Beverage {

    /**
     * 所有的具体调料装饰者都必须实现getDescription(), 这样才能够用递归的方式来得到所选饮料的整体描述
     * @return
     */
    public abstract String getDescription();
}

// 包装对象-摩卡调料类-一种具体的调料
public class Mocha extends CondimentDecorator {

    /**
     * 持有一个具体饮料的引用
     */
    private Beverage beverage;

    public Mocha(Beverage beverage) {
        this.beverage = beverage;
    }

    @Override
    public String getDescription() {
        return beverage.getDescription() + ", 摩卡";
    }

    @Override
    public BigDecimal cost() {
        return new BigDecimal("0.2").add(beverage.cost());
    }
}

// 包装对象-奶泡调料类-一种具体的调料
public class Whip extends CondimentDecorator {

    /**
     * 持有一个具体饮料的引用
     */
    private Beverage beverage;

    public Whip(Beverage beverage) {
        this.beverage = beverage;
    }

    @Override
    public String getDescription() {
        return beverage.getDescription() + ", 奶泡";
    }

    @Override
    public BigDecimal cost() {
        return new BigDecimal("0.4").add(beverage.cost());
    }
}
```

### 2.2. 观察者模式

一个目标物件管理所有相依于它的观察者物件，并且在它本身的**状态改变**时主动发出通知，透过呼叫各观察者所提供的方法来实现，通常被用来实现事件处理系统。

- 特点：
  - 当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新，完美地将观察者模式和被观察者的对象分离开，在模块之间划定了清晰的界限，提高了应用程序的可维护性和重用性。
  - 将一个系统分割成一些类相互协作的类有一个不好的副作用，那就是需要维护相关对象之间的一致性，当不希望为了维持一致性，而使各类紧密耦合导致会给维护、扩展和重用都带来不便时，可以使用观察者模式来解决这类耦合关系。
- 组成：
  - 抽象主题：Subject，抽象主题提供一个接口，可以增加和删除观察者对象。它把所有观察者对象的引用保存到一个聚集里，每个主题都可以有任意数量的观察者。
  - 具体主题：Concrete Subject，将有关状态存入具体观察者对象，在具体主题内部状态改变时，给所有登记过的观察者发出通知。
  - 抽象观察者：Observer，为所有具体的观察者定义一个接口，在得到主题通知时更新自己。
  - 具体观察者：Concrete Observer，实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题状态协调。
- 优点：
  - 解耦：观察者模式解除了主题和具体观察者的耦合，让耦合的双方都依赖于抽象，不依赖具体，从而使得各自的变化都不会影响另一边的变化。
- 缺点：
  - 需考虑异步：在应用观察者模式时需要考虑以下开发短路问题，程序中包括一个被观察者和多个观察者，开发和调试比较复杂，而且Java中的消息通知默认是顺序执行的，一个观察者的卡顿会影响整体的执行效率，因此，在这种情况下，一般考虑采用异步的方式。
  - 需考虑进一步解耦：如果依赖关系未完全解除，如抽象通知者依旧依赖抽象的观察者，这时可以采用委托的方式（引用方法类型）来解决。
- 使用场景：
  - 当一个抽象模型有两个方面，其中一个方面依赖于另一个方面，需要将二者封装在独立的对象中，以使它们可以各自独立地改变和复用时。
  - 当一个对象的改变需要同时改变其他对象，但又不知道具体有多少对象需要改变时。
  - 当一个对象必须通知其他对象，但它又不知道其他对象是谁时，也就是希望这些对象之间不是紧密耦合的。

```java
// 客户类
public class Client {
    public static void main(String[] args) {
        CustomerA customerA = new CustomerA();
        customerA.addObserver(new Cashier(customerA));
        customerA.addObserver(new Accountant(customerA));
        customerA.addObserver(new Dilliveryman(customerA));
        customerA.payOrder();
    }
}

// 客户主题抽象类
public abstract class CustomerSubject {

    private Vector<JobStation> observers = new Vector<>();

    private String state;

    public void addObserver(JobStation jobStation){
        observers.add(jobStation);
    }

    public void removeObserver(JobStation jobStation){
        observers.remove(jobStation);
    }

    public abstract void payOrder();

    public Vector<JobStation> getObservers() {
        return observers;
    }

    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
    }
}

// 具体主题类：具体客户类A
public class CustomerA extends CustomerSubject {

    @Override
    public void payOrder() {
        super.setState("已付款");
        System.out.println("我是用户, 我已经完成订单付款...");
        for(JobStation jobStation : super.getObservers()){
            jobStation.updateJobState();
        }
    }
}

// 抽象观察者: 工作岗位接口
public interface JobStation {

    public void updateJobState();
}

// 具体观察者：出纳工作人员
public class Cashier implements JobStation{

    private String state;

    private CustomerSubject customerSubject;

    public Cashier(CustomerSubject customerSubject) {
        this.customerSubject = customerSubject;
    }

    @Override
    public void updateJobState() {
        if(customerSubject.getState().equals("已付款")){
            this.state = "已入账";
            System.out.println(String.format("我是出纳员, 我来登记入账 => %s.", this.state));
        }
    }
}
```

### 2.3. 建造者模式

将一个复杂对象的**构造与他的表示分离**，使同样的构建过程可以创建不同的表示。

- 特点：
  - 将一个复杂的对象分解为多个简单的对象，然后一步步构建而成，它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。
  - 当需要创建的产品具备复杂创建过程时，可以抽取公共创建过程，然后交由具体实现类自定义创建流程， 使得同样得创建行为可以生产出不同的产品，分离了创建与表示，使创建的产品灵活性大大增加。
- 组成：
  - 指挥者：Director，它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体的产品信息。
  - 抽象构造者：Builder，它是一个包含创建产品各个子部分的抽象方法的接口，通常还包含一个返回复杂产品的getResult()方法。
  - 具体构造者：Concrete Builder，实现Builder接口，完成复杂产品的各个部件的具体方法。
  - 产品：它是包含多个部件的复杂对象，由具体建造者来创建其各个零部件。
- 过程：

1. 指挥者Director直接和客户Client进行需求沟通。
2. 沟通后，指挥者将客户创建产品的需求划分为各个部件的建造请求Builder。
3. 将各个部件的建造请求委派到具体的建造者ConcreteBuilder。
4. 各个具体建造者ConcreteBuilder负责进行产品部件的构建。
5. 最终构建成具体产品Product。

- 优点：
  - 封装性好：构建和表示分离，即同样的构建过程能取到不同的表示。
  - 扩展性好：各个具体的构造者独立，有利于系统的解耦。
  - 易用：客户端不必知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其他模块产生任何影响，便于控制细节风险。
  - 灵活：改造多参数构造对象可以使得传递参数更加灵活，代码具有更高的可读性。
- 缺点：
  - 范围限制：产品的组成部分必须相同，这限制了其使用范围。
  - 维护成本高：如果产品的内部变化复杂，当产品内部发生变化时，则建造者也要同步修改，后期维护成本较大。
- 使用场景：
  - 相同的方法，当有不同的执行顺序时，产生不同的结果时。
  - 多个部件零件，都可以装配到一个对象中，但是产生的结果又不相同时。
  - 产品类非常复杂，或者产品类中不同的调用顺序产生不同的作用时。
  - 初始化一个对象特别复杂，参数多， 而且很多参数都具有默认值时。
- 建造者模式 VS 工厂模式：
  - 建造者模式注重零部件的**组装过程**，而工厂模式更注重零部件的**创建过程**，但两者可以结合使用。
  - 建造者模式注重方法的**调用顺序,** 而工厂模式注重**创建对象**。
  - **创建对象的方式不同**：建造者模式通过指挥类来指导如何生成对象，包括对象的组装过程和构造步骤。而工厂模式是通过客户端实例化工厂类，然后调用工厂方法获取所需的产品对象。
  - **关注重点不一样**：建造者模式不仅要创建出对象，还要知道对象由哪些部件组成。而工厂模式只需要把对象创建出来就可以了。
  - **创建对象的粒度不同**：建造者模式创建复杂对象，由各种复杂的部件组成，建造顺序不同最终对象部件也会不一样。而工厂模式创建出来的对象都一样或者是一系列的产品族。
  - 如果将抽象工厂模式看成**汽车配件生产工厂**，生产一个产品族的产品，那么建造者模式就相当于一个**汽车组装工厂**，通过对部件的组装生成出一辆完整的汽车。

```java
// 客户类
public class Client {

    public static void main(String[] args) {
        Director directorA =  new Director(new ConcreteBuildA());
        Director directorB =  new Director(new ConcreteBuildB());

        // 获取产品A
        directorA.assembledProduct();

        // 获取产品B
        directorB.assembledProduct();
    }
}

// 指挥者类
public class Director {

    private Builder builder;

    public Director(Builder builder) {
        this.builder = builder;
    }

    // 组装产品
    public Product assembledProduct(){
        builder.buildNilProduct();
        builder.buildPartA();
        builder.buildPartB();
        builder.buildPartC();
        return builder.getProduct();
    }
}

// 抽象Builder类
public abstract class Builder {

    // 构造空属性产品
    protected Product product;

    public abstract void buildPartA();

    public abstract void buildPartB();

    public abstract void buildPartC();

    // 获取产品
    public void buildNilProduct() {
        this.product = new Product();
    }

    // 获取产品
    public Product getProduct() {
        return product;
    }
}

// 具体建造者类A
public class ConcreteBuildA extends Builder{

    @Override
    public void buildPartA() {
        if(super.product == null){
            throw new RuntimeException("请先构建空产品");
        }

        super.product.setPartA("我是A Part A.");
        System.out.println("A建造者建造了Part A...");
    }

    @Override
    public void buildPartB() {
        if(super.product == null){
            throw new RuntimeException("请先构建空产品");
        }

        super.product.setPartB("我是A Part B.");
        System.out.println("A建造者建造了Part B...");
    }

    @Override
    public void buildPartC() {
        if(super.product == null){
            throw new RuntimeException("请先构建空产品");
        }

        super.product.setPartC("我是A Part C.");
        System.out.println("A建造者建造了Part C...");
    }
}

// 产品类
public class Product {

    private String partA;
    private String partB;
    private String partC;

    public String getPartA() {
        return partA;
    }

    public void setPartA(String partA) {
        this.partA = partA;
    }

    public String getPartB() {
        return partB;
    }

    public void setPartB(String partB) {
        this.partB = partB;
    }

    public String getPartC() {
        return partC;
    }

    public void setPartC(String partC) {
        this.partC = partC;
    }
}
```



## **5. Java基础**

### 1.1. 面向对象三大特性？

**封装、继承、多态**

- **封装**：对抽象的事物抽象化成一个对象，并对其对象的属性私有化，同时提供一些能被外界访问属性的方法。
- **继承**：子类扩展新的数据域或者功能，并复用父类的属性与功能，单继承、多实现。
- **多态**：通过继承（多个子类对同一方法的重写），也可以用过接口（实现接口）。

### 1.2. Java与C++的区别？

Java和C++都是面向对象语言，都能够实现面向对象思想（即**封装、继承、多态**）。

|          | Java                         | C++                |
| -------- | ---------------------------- | ------------------ |
| 继承     | 单继承，可通过接口实现多继承 | 多继承             |
| 访存     | 不提供指针直接访存           | 有指针的概念       |
| 内存管理 | JVM自动管理                  | 程序员需要手动管理 |

### 1.3. 多态是什么？

多态，按字面意思就是多种状态。**在面向对象语言中，接口的多种不同实现方式即为多态，允许将基类的指针或者引用指向派生类的对象，在具体访问时实现方法的动态绑定。**

- 条件：
  - 多态建立在继承的基础上，先有继承才能有多态。
  - 多态另一个条件是，在创建子类时必须使用父类指针以及new实际的子类类型。

### 1.4. static和final关键字？

- **static**：可以修饰属性和方法
  - 修饰属性：
    - 代表类级别属性，所有对象共享一份，随着类的加载而加载，只加载一次，先于对象的创建。
    - 可以使用类名直接调用。
  - 修饰方法：
    - 随着类的加载而加载。
    - 可以使用类名直接调用。
    - 在静态方法中，只能调用静态的成员，以及不可以使用this。
- **final**：最要用于变量、方法、类。
  - 修饰变量：
    - 如果变量是基本数据类型，则其数值一旦在初始化后就不能更改了。
    - 如果是引用类型的变量，则其在初始化后就不能更改指向的对象了。
  - 修饰方法：
    - 锁定方法，防止任何继承类重写其含义（类中所有的private方法都隐式地指定为了final修饰）。
  - 修饰类：
    - 表名这个类不能被继承，其中该类中的所有成员、方法都会被隐式地指定为final修饰。
    - *另：要使一个类不能被继承，除了final关键字外，还可以私有化构造器（不能继承内部类）。*

### 1.4. 抽象类和接口？

- **抽象类**：
  - 包含抽象方法的类，使用abstract修饰。
  - 抽象类不能被实例化。
  - 抽象类只能被继承，所以不能使用final修饰。
  - 使用场景：既想约束子类具有共同的行为，不在乎其如何实现，又想拥有缺省的方法以及拥有实例变量时。
- **接口**：
  - 是一个抽象类型，是抽象方法的集合。
  - 支持多继承，接口中定义的方法默认是public abstract修饰的抽象方法。
  - 使用场景：想要约束多个实现类具有统一行为，不在乎每个实现类如何实现，又想实现类各个功能之间可以没有任何联系（多继承）时。
- 相同点：都不能被实例化、都可以定义抽象方法，靠子类/实现类实现抽象方法。
- 不同点：

| 抽象类                     | 接口                                      |
| -------------------------- | ----------------------------------------- |
| 有构造方法                 | 没有构造方法                              |
| 可以包含普通方法           | JDK7前只能是"抽象方法"                    |
| 只能单继承                 | 支持多继承                                |
| 可以定义各种类型的成员变量 | 只能定义public static final修饰的静态常量 |

### 1.5. 泛型和泛型擦除？

泛型的本质是**参数化类型**。

- 使用方式：可以用在类、接口和方法上，分别成为泛型类、泛型接口和泛型方法，还可以用在方法的参数和返回值上（此时该方法只是普通方法）。
  - 泛型类：
    - 当指定了泛型类型，整个类泛型都必须同一类型。
    - 没有指定泛型类型，整个类可以为任意类型（Object类型）。
  - 泛型接口：
    - 实现泛型接口时，当接口指定泛型类型时，实现类必须保持相同的泛型类型。
    - 当接口没指定泛型类型时，实现类可以不指定泛型类型（Object类型）。
  - 泛型方法：
    - 在修饰符和返回值之间的位置，声明了泛型的才是泛型方法。
    - 而只使用泛型类型参数和返回值的，只是普通方法。
  - 泛型通配符：
    - 泛型的上限：<? extends 类型>，作为实参传递时，只能传递子类及本类类型。
    - 泛型的下限：<? super 类型>，作为实参传递时，只能传递父类级本类类型。
  - 泛型数组：
    - 不可以创建一个确切泛型类型的数组，比如不能List<String>[] ls = new ArrayList<String>[10];
    - 但可以创建一个确切通配符类型的数组，且获取时必须进行类型转换。比如可以List<?>[] ls = new ArrayList<?>[10];
- **泛型擦除**：
  - Java的泛型是伪泛型，使用泛型的时需要加上类型参数，在编译器编译生成字节码时会被去掉，这个过程称为泛型擦除。
  - 比如List<String>类型，在编译之后都会 成为List类型，JVM看到的只是List，因此泛型附加的类型信息对JVM来说是不可见的，**只在编译期间有效，在运行期间无效**。
- **泛型优点**：
  - 可以指定类型，不用强转，代码简洁，提高了编码期间的可读性
  - 保证集合中存的元素都是同一类型的元素，程序更加健壮。
- 桥接方法：
  - 概念：在子类继承泛型父类或者实现泛型接口，并且指定了泛型类型时，编译器会自动在子类中生成桥接方法。
  - 原因：如果不生成桥接方法，在泛型擦除后，父类类型变为了Object类型，而子类方法参数还是指定的类型，此时就不算实现父类或者接口方法了。因此，为了**维持多态性**，会在子类中生成Object类型的桥接方法，其实现是把Object参数强转成指定的类型，方便指向具体的实现方法。

```java
/**
 * 泛型类
 */
public class MyGeneric<T> {

    private T genericCode;

    // 静态方法-不含泛型
    public static void main(String[] args) {

    }

    // 静态泛型方法-含泛型
    public static <E> E test(E args) {
        return args;
    }

    // 构造方法-使用类的泛型
    public MyGeneric(T genericCode) {
        this.genericCode = genericCode;
    }

    // 普通方法-使用类的泛型
    public T getGenericCode() {
        return genericCode;
    }

    // 普通方法-使用类的泛型
    public void setGenericCode(T genericCode) {
        this.genericCode = genericCode;
    }
}
```

### 1.6. Java异常体系？

![1621048569059](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1621048569059.png)

- **Throwalbe**：Java中所有错误或者异常的超类。
- **Error**：指Java运行时系统内部的错误以及资源耗尽的错误。应用程序不会抛出该类对象，如果出现这样的错误，除了告知用户，剩下的就是尽力使程序安全地终止。
- **Exception**：
  - **RuntimeException**：运行时异常，程序应该从逻辑角度尽可能避免这类异常的发生。
  - **非运行时异常**：这类异常必须使用try-catch进行捕捉处理，否则编译器报错。比如IOExceptin、SQLException。

### 1.7. 反射原理以及使用场景？

指在运行状态中，对于任意一个类，都能够知道这个类所有的属性和方法，并且都能够调用它的任意一个方法。

- 原理：首先获取反射类的字节码，然后将字节码中的方法、变量、构造函数等映射成相应的Method、Field、Constructor等对象。
- 反射类Class对象获取方式：
  - **类名.class**：Class personClazz = Person.class，就一份字节码，所以是同一个Class对象。
  - **Object#getClass（）**：每一个对象都有getClass（）方法，用于返回对象真实的Class对象（对象的元数据）。
  - **Class.forName（String）**：根据一个类的权限定名来构建Class对象。
- 使用场景：通用框架开发、动态代理、自定义注解。

### 1.8. Java构造方法？

构造方法，也叫构造函数，是Java中一种特殊的函数，函数名与类名相同，无返回值。

- 一般用于**初始化成员属性和成员方法**，在对象创建时运行，只运行一次。
- 构造方法可以被重载，只有当类中没有显式声明任何构造方法时，才会有默认的无参构造方法。

### 1.9. Java初始化块？

代码初始化块是类的成员之一，每次类的创建会隐式调用它，本质上是一个代码块或者方法体。

初始化块分为**静态初始化块**和**非静态初始化块**，其好处是减少多个构造器内重用的代码。

- **静态初始化**块优先级最高，会在类第一次被加载时最先执行（也在main方法前），在**非静态初始化块**之前执行。

### 2.0. Java this关键字？

- 关键字this代表**当前对象的引用**：当前对象指的是调用类中的属性或者方法的对象。
- 关键字this不可以在静态方法中使用：因为静态方法不依赖于当前类的实例。

### 2.1. 重载与重写的区别？

- **重载**：指可以在同一个类中定义多个同名方法，但要求参数列表不同，与方法返回值无关。成员方法和构造方法都可以进行重载，可以通过重载构造方法来实现多种初始化行为。重载要求如下：
  - 方法必须都在同一个类中。
  - 方法名相同。
  - 方法参数个数或者参数类型不同。
  - 与方法返回值、返回类型、方法修饰符无关。
- **重写**：指子类中方法签名与父类相同的方法，使用@override注解标识。重写要写如下：
  - 方法在父类和子类不同的类中。
  - 方法名相同。
  - 方法参数个数和参数类型都要相同。
  - 方法返回值类型相同，或者子类方法返回值类型是父类方法返回值的一个子类类型。
  - 子类方法不能缩小方法的访问权限。

### 2.2. 基本数据类型与包装类？

**三类八种基本数据类型**，每个基本类型都有对应的包装类。包装类变量是个指针，没初始化前默认为null。

| 种类   | 基本数据类型           | 存储位数 | 取值范围                                                     | 默认值         | 包装类    |
| ------ | ---------------------- | -------- | ------------------------------------------------------------ | -------------- | --------- |
| 数值型 | byte（位）             | 8 bit    | -2^8到2^8 -1                                                 | 0              | Byte      |
| 数值型 | short（短整数）        | 16 bit   | -2^15到2^15 -1                                               | 0              | Short     |
| 数值型 | int（整数）            | 32 bit   | -2^31到2^31 - 1                                              | 0              | Integer   |
| 数值型 | long（长整数）         | 64 bit   | -2^63到2^63 - 1                                              | 0L             | Long      |
| 数值型 | float（单精度浮点数）  | 32 bit   | 负数范围：-3.402823E+38到-1.401298E-45，正数范围：1.401298E-45到3.402823E+38 | 0.0F           | Float     |
| 数值型 | double（双精度浮点数） | 64 bit   | 负数范围：-1.797693E+308到-4.9000000E-324，正数范围：4.9000000E-324到1.797693E+308 | 0.0D           | Double    |
| 字符型 | char（字符）           | 16 bit   | 0到2^16 - 1                                                  | '\u0000'（空） | Character |
| 布尔型 | boolean                | 1 bit    | true和false                                                  | false          | Boolean   |

### 2.3. 序列化与反序列化？

- **序列化**：
  - 指将Java对象转化为字节序列的过程，即将对象的状态转化成字节流，然后可以通过这些值再生成相同状态的对象。
  - 对象序列化，是对象持久化的一种实现方法，是将对象的属性和方法转化为一种序列化的形式，用于存储和传输。
- **反序列化**：
  - 指将字节序列转化为Java对象的过程，即将对象字节序列重建对象的过程。
- 优点：
  - 实现了数据的持久化，通过序列化可以把数据永久地保存到硬盘上，通常是放在文件里，比如Redis的RDB。
  - 利用序列化实现远程通信，即在网络上传送对象的字节序列，比如Google的ProtoBuf。
- 反序列失败场景：
  - 如果SerialVersionUID不一致，会导致反序列化失败。

### 2.4. Object类？

**Object类是所有类的父类**，在使用任何类都可以使用Object类中的方法：

- toString（）：默认是 类名+hashCode，一般需要重写。

- equals（）：

  - 默认为==，比较对象的引用地址是否相同。
  - 实际上往往需要重写，用于判断两个类的实例是否逻辑（内容）相等。

- hashCode（）：

  - 对象的哈希码，协定声明相等对象必须具有相等的哈希码，即对象equal则hashCode一定相等，hashCode不等则对象一定不equal；对象不euqal时hashCode可能相等，hashCode相等时可能不equal，比如HashMap散列冲突。

  - 因此**重写equals（）方法时必须重写hashCode（）方法**，因为HashMap#get(String)时使用

    first.hash == hash && ((k = first.key) == key || (key != null && key.equals(k)))

    即hash相等且（地址相同或者对象equal）来获取key对象的值，如果修改后，对象equal但hashCode不等，则HashMap会出错。

- finalize（）：

  - 在垃圾回收前调用，默认为空实现。
  - 子类可以重写finalize（）方法，以配置系统资源或执行其他清除。

- clone（）：深拷贝，类需要实现Cloneable接口。

- getClass（）：用于返回对象真实的Class对象（对象的元数据）。

- wait（）、wait（long）、wait（long，int）、notify（）、notifyAll（）：用于线程等待或唤醒。

### 2.5. String类？

- **String**：使用**数组**存储内容，由于数组使用final修饰，因此String定义的字符串的值是不可变的。
- **StringBuffer**：对方法都加了synchronize关键字，是线程安全的，适用于多线程环境下在字符缓冲区进行大量操作，但效率不如StringBuilder。
- **StringBuilder**：StringBuilder方法没有加synchronzie关键字，是非线程安全的，适用于单线程环境下在字符缓冲区进行大量操作，效率比StringBuffer高。

### 2.6. 动态代理？

[1.7. 代理模式](#1.7. 代理模式)&nbsp;

动态代理，指在实现阶段不用关心代理类，而在**运行阶段**才指定哪一个对象。

> **JDK动态代理**：Proxy类利用反射机制以及一个**实现InvocationHandler的处理类**，生成一个实现了原委托类接口（为了可以调用被代理方法） 和 继承了Proxy类（为了持有已经实现InvocationHandler实例的引用） 的代理类，使得在调用代理类具体方法时去调用实现InvocationHandler接口的处理类里的方法。
>
> **CGLIB动态代理**：利用ASM开源包，通过**修改委托类的Class文件的字节码生成子类**来处理，其中主要是生成的子类去覆盖原本委托类中的方法，并在覆盖方法中实现增强，但是因为采用的是继承，所以对于final类或者方法是无法继承和代理的。

#### 1. JDK动态代理 VS CGLIB动态代理

- JDK动态代理：在调用代理类方法时，是通过引用调用InvocationHandler实现类的invoke方法，然后再反射调用委托类的方法，**属于反射调用，存在一定的性能花销**。
- CGLIB动态代理：在调用代理类方法时，是通过引用调用MethodInterceptor实现类的intercept方法，然后通过方法签名的index索引，去代理类的FastClass查找到代理类中具体的方法，最后该方法调用父类（原委托类）的方法, **属于父类方法调用，性能花销小**。

|               | JDK动态代理                              | CGLIB动态代理                                                |
| ------------- | ---------------------------------------- | ------------------------------------------------------------ |
| 生成代理Class | 生成效率高                               | 每次都会生成新的FastClass文件，所以Class生成效率会比JDK动态代理的低 |
| 方法调用      | 属于反射调用，调用效率较低               | 属于父类方法调用，所以调用效率会比JDK动态代理的高            |
| 实现原理      | 如果原委托类没有实现接口时，则不可以使用 | 原委托类有无实现接口一样可以使用，但不可以代理private和final修饰的方法 |
| 使用场景      | 比较适合代理非代理对象                   | 无需频繁创建代理对象，比较适合代理单例对象                   |
| 迭代状态      | 每个JDK版本都有迭代，性能得到增强        | 止步不前                                                     |

#### **2. JDK动态代理**

为了解决静态代理中代理类接口过多的问题，可以通过JDK自带的java.lang.reflect.Proxy类，通过反射实现动态代理。

##### 使用步骤

1. 编写一个委托类的接口：如UserService，把实现方法save（）声明出去。
2. 实现一个真正的委托类：即UserServiceImpl，实现接口save（）方法。
3. 创建一个动态代理类：实现InvocationHandler接口，并重写invoke方法，在实际调用前后编写需要代理的业务逻辑。其中**动态代理类需要持有委托类的引用**，用于反射调用委托类的save()实现方法。
4. 客户端生成代理对象：在客户端中生成动态代理类对象，调用声明的save（）方法。

- **newProxyInstance（）方法参数**：
  - **ClassLoader loader**：原委托类的类加载器。
  - **Class<?>[] interfaces**：原委托类实现的接口类型数组。
  - **InvocationHandler**：事件处理类，代理对象方法调用的实际处理者。在执行原委托类方法时，会触发该事件处理器，把原委托类的方法作为Method参数传入，供代理对象使用。

```java
// 委托类接口：用户服务接口
public interface UserService {

    public void save();
}

// 真正的委托类：用户服务接口实现类
public class UserServiceImpl implements UserService {

    @Override
    public void save() {
        System.out.println("保存用户信息...");
    }
}

// 动态代理类：用户服务实现JDK动态代理类
public class UserServiceImplJdkProxy implements InvocationHandler {

    private UserService userService;

    public UserServiceImplJdkProxy(UserService userService) {
        this.userService = userService;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("JDK动态代理前...");

        Object result = method.invoke(userService, args);

        System.out.println("JDK动态代理后...");
        return result;
    }
}

// 客户端生成代理对象
public class Client {

    public static void main(String[] args) throws Throwable {
        UserServiceImplJdkProxy userServiceImplJdkProxy = new UserServiceImplJdkProxy(new UserServiceImpl());
        
        UserService userService = (UserService) Proxy.newProxyInstance(
                UserServiceImpl.class.getClassLoader(), new Class[]{UserService.class}, userServiceImplJdkProxy);
        
        userService.save();
    }
}
```

##### 实现原理

- **源码分析**：

1. newProxyInstance（）通过反射生成含有接口方法的Proxy Class，其中Proxy Class又继承了Proxy类。
2. $Proxy0构造方法中，调用父类的构造方法，Proxy父类得到InvocationHandler的实例引用。
3. 最后该代理对象的所有方法调用，都会反射转发到InvocationHandler.invoke（）方法。
4. InvocationHandler.invoke（）：允许在原委托类的业务方法的反射调用前后，织入其他代码，从而实现动态代理。

```java
// com/sun/proxy/$Proxy0.java
public final class $Proxy0 extends Proxy implements UserService
{
    private static Method m3;// com.jsonyao.cs.proxyPattern.UserServic => save()

    static
    {
            // 反射获取UserService接口的save()方法
            m3 = Class.forName("com.jsonyao.cs.proxyPattern.UserService").getMethod("save", new Class[0]);
            ...
    }
    
    // 20201112 构造方法
    public $Proxy0(InvocationHandler invocationhandler)
    {
        // 20201112 调用父类构造器, 赋值自定义InvocationHandler
        super(invocationhandler);
    }
    
    // 20201112 实现了UserService的save()方法
    public final void save()
    {
            // 20201112 调用父类注入的invocationHandler实例实现的invoke()方法
            // 20201112 参数分别为Object proxy, Method method, Object[] args
            super.h.invoke(this, m3, null);
            return;
    }
    
    ...
}
```

#### 3. CGLIB动态代理

解决委托类没有实现任何接口时的动态代理。

##### 使用步骤

1. 实现一个MethodInterceptor：方法调用会被转发到该类的intercept（）方法。
2. 客户端构建CGLIB Enhacner：指定原委托类，以及回调接口实现类MethodInterceptor。
3. 客户端获取代理对象执行业务方法：调用Enhacner#create（）方法得到代理对象，使用代理对象调用业务方法。

```java
// CGLIB动态代理方法拦截类
public class MyMethodInterceptor implements MethodInterceptor {

    public static final HelloCglib helloCglib = new HelloCglib();

    /**
     * @param obj => 20201113 增强后的代理对象
     * @param method => 20201113 原始方法
     * @param objects => 20201113 参数数组
     * @param methodProxy => 20201113 可以使用methodProxy#invokeSuper调用FastClass方法
     */
    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        System.out.println("CGLIB动态代理前...");

// 20201113 实际是调用了FastClass的invoke方法, 去调用父类的原方法, 对比JDK动态代理提高了性能
        Object object = methodProxy.invokeSuper(o, objects);
     
        System.out.println("CGLIB动态代理后...");
        return object;
    }
}

public class Client {

    public static void main(String[] args) throws Throwable {
        // 设置代理类生成的目录
        System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, ".\\cglib\\classes");

        // 构建CGLIB Enhacner, 指定原委托类，以及回调接口实现类MethodInterceptor
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(HelloCglib.class);
        enhancer.setCallback(new MyMethodInterceptor());
        
        // 客户端获取代理对象执行业务方法：final方法不会被代理
        HelloCglib helloCglib = (HelloCglib) enhancer.create();
        helloCglib.helloAagin();
    }
}
```

##### 实现原理

- 利用ASM开源包，通过**修改委托类Class文件的字节码**生成子类，去覆盖原委托类的方法，并在覆盖方法中实现了增强。
- 在调用代理类方法时，通过引用调用MethodInterceptor实现类的invoke方法，然后通过**方法签名的index索引去代理类的FastClass中查找**代理类中具体的方法，最后调用该方法时调用父类即原委托类的方法，从而实现动态代理。
- **源码分析**：
  1. Enhancer#setSuperclass（Class）：设置委托类为Enhancer的成员变量。
  2. Enhancer#setCallback（Callback）：设置回调函数实例为Enhancer的成员变量。
  3. Enhancer#create（）：使用父类、接口、过滤器、回调函数、版本号等信息生成标识类的key -> 构造出multi-values key对象 => 用于获取/设置缓存。
  4. AbstractClassGenerator#create（Object key）：生成字节码增强文件，并设置multi-values key对应的缓存。
  5. Enhancer#createUsingReflection（Class）：设置代理对象的回调函数实例（其中MethodInterceptor实现了Callback接口，实际上callback就是实现的MethodInterceptor实例）以及反射生成代理对象实例。
  6. 代理对象HelloCglib$$EnhancerByCGLIB$$6bf7bfad的static初始化块：调用MethodProxy.create生成原委托类方法、代理对象代理方法的签名。
  7. MethodProxy.create（Class, Class, String，String, String）：生成原委托类方法、代理对象代理方法的签名。
  8. MethodProxy#invokeSuper(o, objects)：o: 增强后的代理对象, objects参数列表。
  9. 代理对象的FastClass HelloCglib$$EnhancerByCGLIB$$6bf7bfad$$FastClassByCGLIB$$9448a271#getIndex（Signature）：根据原委托类方法、代理对象的代理方法的签名生成FastClassInfo索引。
  10. 代理对象的FastClass HelloCglib$$EnhancerByCGLIB$$6bf7bfad$$FastClassByCGLIB$$9448a271#invoke(int , Object , Object)：根据代理方法索引、代理对象、参数列表调用FastClass方法。
  11. 代理对象HelloCglib$$EnhancerByCGLIB$$6bf7bfad#CGLIB$helloAagin$5()：调用代理对象的CGLIB$helloAagin$5()方法。
  12. 原委托类HelloCglib#helloAagin（）：调用父类HelloCglib原委托类的helloAagin方法，避免反射调用，提高性能。

```java
// Enhance类
public class Enhancer extends AbstractClassGenerator
{
    // 1. 设置委托类为Enhancer的成员变量
    public void setSuperclass(Class superclass) {
    	...
        // 如果不是接口且父类不是Object类, 则设置父类为自己本身
        this.superclass = superclass;
    }
    
    // 2. 设置回调函数为Enhancer的成员变量
    public void setCallback(final Callback callback) {
        setCallbacks(new Callback[]{ callback });
    }
    
    // 3. Enhancer#create()
    private Object createHelper() {
    	...
        // 使用父类、接口、过滤器、回调函数、版本号等信息生成标识类的key -> 构造出multi-values key对象 => 用于获取/设置缓存
        return super.create(KEY_FACTORY.newInstance((superclass != null) ? superclass.getName() : null, ReflectUtils.getNames(interfaces), 
        											filter,
                                                    callbackTypes,
                                                    useFactory,
                                                    interceptDuringConstruction,
                                                    serialVersionUID));
                                                    
    // 类abstract public class AbstractClassGenerator implements ClassGenerator
    // 4. super#create()生成字节码增强文件，并设置multi-values key对应的缓存
    protected Object create(Object key) {
    	...
		if (gen == null) {
			// 根据默认策略生成代理对象的Class文件字节流
			byte[] b = strategy.generate(this);
			// 根据字节流获取Class文件名
			String className = ClassNameReader.getClassName(new ClassReader(b));
			// 添加Class文件名到类加载器中
			getClassNameCache(loader).add(className);
			// 根据Class文件名 & Class文件字节流 & 类加载器生成代理对象的Class
			gen = ReflectUtils.defineClass(className, b, loader);
		}
		// 添加代理类Class对象到类加载器缓存中
		if (useCache) {
			cache2.put(key, new WeakReference(gen));
		}
		
		// 5. 生成代理对象实例
		return firstInstance(gen);
    }
    // 类abstract public class AbstractClassGenerator implements ClassGenerator
    
    // 5. Enhancer类生成代理对象实例
    protected Object firstInstance(Class type) throws Exception {
        if (classOnly) {
            return type;
        } else {
            return createUsingReflection(type);
        }
    }
    private Object createUsingReflection(Class type) {
        // 5. 设置代理对象的回调函数, 其中MethodInterceptor实现了Callback接口, 实际上callback就是实现的MethodInterceptor
        setThreadCallbacks(type, callbacks);
        ...
        // 5. 反射生成代理对象实例
        return ReflectUtils.newInstance(type);
    }
}

// CGLIB代理类，原委托类为HelloCglib
public class HelloCglib$$EnhancerByCGLIB$$6bf7bfad extends HelloCglib implements Factory
{
	    static void CGLIB$STATICHOOK1()
    {
    	// Method数组: 含动态代理生成的方法 & 原委托类所有非Final的方法
        Method amethod[];
        // 之前设置的回调函数
        CGLIB$THREAD_CALLBACKS = new ThreadLocal();
        // 代理对象的Class对象
        Class class1 = Class.forName("com.jsonyao.cs.proxyPattern.HelloCglib$$EnhancerByCGLIB$$6bf7bfad");
        // 原委托类的Class对象
        Class class2;
        
        // 6. 静态代码块: 调用MethodProxy#create生成原委托类方法、代理对象代理方法的签名
        CGLIB$helloAagin$5$Proxy = MethodProxy.create(class2, class1, "()V", "helloAagin", "CGLIB$helloAagin$5");
        ...
    }
    
    // 11. 调用代理对象的CGLIB$helloAagin$5()
    final void CGLIB$helloAagin$5()
    {
    	// 12. 最后一步：调用父类HelloCglib原委托类的helloAagin方法，避免反射调用，提高性能
        super.helloAagin();
    }
}

// MyMethodInterceptor#invoke（）入参：MethodProxy
public class MethodProxy {

    // 7. 生成原委托类方法、代理对象代理方法的签名
    public static MethodProxy create(Class c1, Class c2, String desc, String name1, String name2) {
        MethodProxy proxy = new MethodProxy();
        proxy.sig1 = new Signature(name1, desc);
        proxy.sig2 = new Signature(name2, desc);
        proxy.createInfo = new CreateInfo(c1, c2);
        return proxy;
    }

    // 8. Object object = methodProxy.invokeSuper(o, objects);
    // 8. o: 增强后的代理对象, objects参数列表
    public Object invokeSuper(Object obj, Object[] args) throws Throwable {
        try {
        	// 9. 根据原委托类方法、代理对象代理方法的签名生成FastClassInfo索引
            init();
            FastClassInfo fci = fastClassInfo;
            
            // 10. 根据代理方法索引、代理对象、参数列表调用FastClass方法
            return fci.f2.invoke(fci.i2, obj, args);
        } catch (InvocationTargetException e) {
            throw e.getTargetException();
        }
    }
    
    private static class FastClassInfo
    {
        FastClass f1;
        FastClass f2;
        int i1;
        int i2;
    }
    
    // 9. 根据原委托类方法、代理对象代理方法的签名生成FastClassInfo索引
    private void init()
    {
        if (fastClassInfo == null)
        {
            synchronized (initLock)
            {
                if (fastClassInfo == null)
                {
                    CreateInfo ci = createInfo;

                    FastClassInfo fci = new FastClassInfo();
                    fci.f1 = helper(ci, ci.c1);
                    fci.f2 = helper(ci, ci.c2);
                    fci.i1 = fci.f1.getIndex(sig1);
                    // 9. 根据原委托类方法、代理对象代理方法的签名生成FastClassInfo索引
                    fci.i2 = fci.f2.getIndex(sig2);
                    fastClassInfo = fci;
                    createInfo = null;
                }
            }
        }
    }
}

// FastClass抽象父类
abstract public class FastClass
{
	abstract public int getIndex(Signature sig);
    
    abstract public Object invoke(int index, Object obj, Object[] args) throws InvocationTargetException；
}

// 20201113 HelloCglib代理后的FastClass文件
public class HelloCglib$$EnhancerByCGLIB$$6bf7bfad$$FastClassByCGLIB$$9448a271 extends FastClass {
    
    // 9. 根据原委托类方法、代理对象代理方法的签名生成FastClassInfo索引
     public int getIndex(Signature var1) {
        String var10000 = var1.toString();
         switch(var10000.hashCode()) {
            ...
        	case -1512990617:
            	if (var10000.equals("CGLIB$helloAagin$5()V")) {
                	return 16;
            	}
            	break;  
            ...
         }
     }
    
    // 10. 根据代理方法索引、代理对象、参数列表调用FastClass方法
    public Object invoke(int var1, Object var2, Object[] var3) throws InvocationTargetException {
        6bf7bfad var10000 = (6bf7bfad)var2;
        int var10001 = var1;
        try {
            switch(var10001) {
                ...
                case 16:
                    // 11. 调用代理对象的CGLIB$helloAagin$5()
                	var10000.CGLIB$helloAagin$5();
                	return null;
                ...
            }
        }
    }
}
```

### 2.7. List？

List，**有序集合**（也称为序列）。此接口的用户可以精确控制列表中每个元素的插入位置。用户**可以通过其整数索引（在列表中的位置）访问元素**，并在列表中搜索元素。

```java
public interface Iterable<T> {
	Iterator<T> iterator();
    default void forEach(Consumer<? super T> action) {...}
    default Spliterator<T> spliterator() {...}
}

public interface ListIterator<E> extends Iterator<E> {
    boolean hasNext();
    E next();
    boolean hasPrevious();
    E previous();
    int nextIndex();
    int previousIndex();
    void remove();
    void set(E e);
    void add(E e);
}

public interface Collection<E> extends Iterable<E> {
    int size()；
    boolean isEmpty();
    boolean add(E e);
    boolean remove(Object o)；
    Object[] toArray()；
    <T> T[] toArray(T[] a)；
    ...
}

public interface List<E> extends Collection<E> {
    void add(int index, E element);
    E remove(int index);
    E get(int index);
    E set(int index, E element);
    ...
}
```

- **典型实现**：**ArrayList、LinkedList、CopyOnWriteArrayList、SynchronizedList、Vector、Stack**

#### ArrayList

![1621431762562](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1621431762562.png)

##### 特点

- ArrayList底层基于数组实现，**支持对元素进行快速随机访问，适合随机查找和遍历**，不适合大量插入和删除。**允许null元素**。
- **默认初始大小为10**，当数组容量不够时，会触发扩容机制（**扩大到当前的1.5倍**），需要将原来数组的数据复制到新的数组中。当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。
- 非线程安全的，如果要使用同步的List方法，可以考虑使用Collections＃synchronizedList进行包装。

- 迭代器是快速失败的。

##### 构造方法

- **无参的构造函数**：赋值初始化数组。
- **指定容量构造函数**：创建一个Object数组，并赋值给elementData成员变量。
- **指定复制集合的构造函数**：调用Collection接口toArray（）转换集合为数组，再用Arrays.copyOf（...）复制数组（底层调用的是System.arraycopy（...））。

```java
public class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, java.io.Serializable {
    
	private static final int DEFAULT_CAPACITY = 10;
	private static final Object[] EMPTY_ELEMENTDATA = {};
	private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
	transient Object[] elementData;
	private int size;
    
	// 无参的构造函数
    public ArrayList() {
        this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;// 代表初始化数组
    }

    // 指定容量的构造函数
    public ArrayList(int initialCapacity) {
        if (initialCapacity > 0) {
            this.elementData = new Object[initialCapacity];
        } else if (initialCapacity == 0) {
            this.elementData = EMPTY_ELEMENTDATA;// 代表空元素数组
        } else {
            throw new IllegalArgumentException("Illegal Capacity: "+initialCapacity);
        }
    }

    // 指定复制集合的构造函数
    public ArrayList(Collection<? extends E> c) {
        elementData = c.toArray();// 赋值数组， Collection接口的toArray()
        if ((size = elementData.length) != 0) {
            if (elementData.getClass() != Object[].class)
                // 底层调用System.arraycopy（...）
                elementData = Arrays.copyOf(elementData, size, Object[].class);
        } else {
            this.elementData = EMPTY_ELEMENTDATA;// 代表空元素数组
        }
    }
}
```

##### 迭代方法

> 此类的{@link #iterator（）}和{@link #listIterator（int）}方法返回的迭代器是**快速失败**的：即如果在创建迭代器后的任何时间都对结构进行了结构修改， 除了通过迭代器自己的{@link ListIterator＃remove（）remove}或{@link ListIterator＃add（Object）add}方法之外，迭代器都会抛出{@link ConcurrentModificationException}。 因此，面对并发修改，迭代器会快速干净地失败，而不会在未来的不确定时间内冒任意、不确定的行为的风险。 由{@link #elements（）elements}方法返回的{@link Enumeration Enumerations}不是快速失败的。
>
> 请注意，迭代器的快速失败行为无法得到保证，因为通常来说，在存在不同步的并发修改的情况下，不可能做出任何严格的保证。 **快速失败的迭代器会尽最大努力抛出{@code ConcurrentModificationException}**。 因此，编写依赖于此异常的程序的正确性是错误的：**迭代器的快速失败行为应仅用于检测错误**。

所有迭代操作都有：**并发修改检查**，检测对象有没有发生并发修改的操作。

- **iterator（）**：获取Collection迭代器。
- **listIterator（）**：获取默认的List迭代器。
- **listIterator（int）**：获取指定索引的List迭代器。

##### 扩容方法

- **扩容条件**：数组实际长度（size）大于当前数组长度（elementData.length）时。

- **grow（int）**：增长元素数组到指定容量。

1. 计算新容量： = 旧容量（当前元素数组实际长度） *  1.5。
2. 容量判断：如果新容量小于指定容量，则设置为指定容量。以及最大长度判断：Integer.MAX_VALUE - 8。
3. 移动元素到新数组：Arrays.copyOf（...）（底层调用的是System.arraycopy（...））。

```java
// 扩容条件
private void ensureExplicitCapacity(int minCapacity) {
    modCount++;
    // overflow-conscious code
    if (minCapacity - elementData.length > 0)
        grow(minCapacity);// minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);
}

// 扩容方法
private void grow(int minCapacity) {
    // 旧数组容量（当前元素数组实际长度）
    int oldCapacity = elementData.length;

    // 新容量 = 旧容量 + 旧容量/2 = 旧容量 * 1.5 => 扩容为原来的1.5倍
    int newCapacity = oldCapacity + (oldCapacity >> 1);

    if (newCapacity - minCapacity < 0)
        newCapacity = minCapacity;

    if (newCapacity - MAX_ARRAY_SIZE > 0)
        newCapacity = hugeCapacity(minCapacity);// 最大长度判断：Integer.MAX_VALUE - 8
    
    // minCapacity is usually close to size, so this is a win:
    elementData = Arrays.copyOf(elementData, newCapacity);
}
```

##### 增加元素方法

- **add（E）**：添加元素到末尾位置。

1. 扩容判断。
2. 添加元素、实际大小 + 1。
3. 返回true。

- **add（int，E）**：添加元素到指定位置。无返回值。

1. 索引越界判断。
2. 扩容判断。
3. 移动数组元素：System.arraycopy（...）。
4. 添加元素、实际大小 + 1。

```java
// 添加元素到末尾位置
public boolean add(E e) {
    ensureCapacityInternal(size + 1); // Increments modCount!! + 扩容判断
    elementData[size++] = e;
    return true;
}

// 添加元素到指定位置
public void add(int index, E element) {
    rangeCheckForAdd(index); // 索引越界校验
    ensureCapacityInternal(size + 1);  // Increments modCount!! + 扩容判断
    System.arraycopy(elementData, index, elementData, index + 1, size - index);
    elementData[index] = element;
    size++;
}
```

##### 获取元素方法

- **get（int）**：根据索引获取数组元素，O(1)。

```java
public E get(int index) {
    rangeCheck(index);// 索引越界检查
    return elementData(index);// 根据索引获取数组元素，O(1)
}

E elementData(int index) {
    return (E) elementData[index];
}
```

##### 删除元素方法

- **remove（int）**：删除指定索引元素。

1. 索引越界校验。
2. 根据索引获取数组元素，O(1)。
3. 移动数组元素：System.arraycopy（...）。
4. 清空元素、实际大小 - 1。
5. 返回旧元素。

- **remove（Object）**：删除指定元素，用equals（...）判断。

1. 元素为null：遍历数组、找到第一个为null的元素、移动数组元素、清空元素、实际大小 - 1、返回true。
2. 元素非null：遍历数组、找到第一个equal的元素、移动数组元素、清空元素、实际大小 - 1、返回true。
3. 否则代表删除失败，返回false。

- **removeRange（int，int）**：删除fromIndex~toIndex-1内的元素。无返回值。

1. 移动数组元素、清空元素、更新实际大小 。

```java
// 删除指定索引元素
public E remove(int index) {
    rangeCheck(index);// 索引越界校验
    modCount++;
    
    E oldValue = elementData(index);// 根据索引获取数组元素，O(1)

    int numMoved = size - index - 1;
    if (numMoved > 0)
        System.arraycopy(elementData, index+1, elementData, index, numMoved);
    elementData[--size] = null; // clear to let GC do its work

    return oldValue;
}

// 删除指定元素: equals判断
public boolean remove(Object o) {
    if (o == null) {
        for (int index = 0; index < size; index++)
            if (elementData[index] == null) {
                fastRemove(index);
                return true;
            }
    } else {
        for (int index = 0; index < size; index++)
            if (o.equals(elementData[index])) {
                fastRemove(index);
                return true;
            }
    }
    
    return false;
}
private void fastRemove(int index) {
    modCount++;
    int numMoved = size - index - 1;
    if (numMoved > 0)
        System.arraycopy(elementData, index+1, elementData, index,
                         numMoved);
    elementData[--size] = null; // clear to let GC do its work
}

// 删除fromIndex~toIndex-1内的元素
protected void removeRange(int fromIndex, int toIndex) {
    modCount++;

    int numMoved = size - toIndex;
    System.arraycopy(elementData, toIndex, elementData, fromIndex,
                     numMoved);

    // clear to let GC do its work
    int newSize = size - (toIndex-fromIndex);
    for (int i = newSize; i < size; i++) {
        elementData[i] = null;
    }

    size = newSize;
}
```

##### 替换元素方法

- **set（int，E）**：替换指定位置的元素。

1. 索引越界检查、根据索引获取数组元素O(1)、设置数组元素O(1)、返回旧元素。

```java
// 替换指定位置的元素
public E set(int index, E element) {
    rangeCheck(index);// 索引越界检查
    E oldValue = elementData(index);// 根据索引获取数组元素, O(1)
    elementData[index] = element;
    return oldValue;
}
```

#### LinkedList

![1621435281320](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1621435281320.png)

##### 特点

- **底层基于双向链表实现，适合数据的动态插入和删除。允许null元素。**
- 内部提供了List接口中没有定义的方法，**用于操作表头和表尾元素，可以当作栈、队列和双向队列使用**。比如jdk官方推荐使用基于LinkedList的Deque进行栈操作。
- 非线程安全的，如果要使用同步的List方法，可以考虑使用Collections＃synchronizedList进行包装。
- **实现了List、Queue、Deque接口，还提供了堆栈的方法**，所以可以把LinkedList看作是List、Queue、Deque和Stack。作为队列时，不会有替换元素的方法，且获取元素方法都是检索栈顶的元素。
- 迭代器是快速失败的。

##### 构造方法

- **空参的构造函数**：什么都不做。
- **指定复制集合的构造函数**：

1. 调用空参的构造函数：什么也不做。
2. 指针索引校验。
3. 根据索引获取插入结点的位置：succ为后结点, pred为前结点。
4. 遍历待插入的数组、插入元素，维护指针关系。
5. 更新succ、pred前后指针关系。
6. 更新实际大小。
7. 返回true。

```java
public class LinkedList<E> extends AbstractSequentialList<E> implements List<E>, Deque<E>, Cloneable, java.io.Serializable
{
    transient int size = 0;
    transient Node<E> first;
    transient Node<E> last;
    
    private static class Node<E> {
        E item;
        Node<E> next;
        Node<E> prev;

        Node(Node<E> prev, E element, Node<E> next) {
            this.item = element;
            this.next = next;
            this.prev = prev;
        }
    }
    
    // 空参的构造函数
    public LinkedList() {
    }
    
    // 指定复制集合的构造函数
    public LinkedList(Collection<? extends E> c) {
        this();
        addAll(c);
    }
    public boolean addAll(Collection<? extends E> c) {
        return addAll(size, c);
    }
    public boolean addAll(int index, Collection<? extends E> c) {
        checkPositionIndex(index);// 指针索引校验

        Object[] a = c.toArray();
        int numNew = a.length;
        if (numNew == 0)
            return false;
		
		// 根据索引获取插入结点的位置：succ为后结点, pred为前结点
        Node<E> pred, succ;
        if (index == size) {
            succ = null;
            pred = last;
        } else {
            succ = node(index);
            pred = succ.prev;
        }
		
		// 遍历待插入的数组、插入元素，维护指针关系
        for (Object o : a) {
            E e = (E) o;
            Node<E> newNode = new Node<>(pred, e, null);

            if (pred == null)
                first = newNode;
            else
                pred.next = newNode;
            pred = newNode;
        }

		// 更新succ、pred前后指针关系
        if (succ == null) {
            last = pred;
        } else {
            pred.next = succ;
            succ.prev = pred;
        }
		
		// 更新实际大小
        size += numNew;
        modCount++;
        
        return true;
    }
}
```

##### 迭代方法

- **listIterator（int）**：获取指定索引的List迭代器。没有Collection迭代器方法。
  - 所有迭代操作都有：并发修改检查，检测对象有没有发生并发修改的操作。

##### 扩容方法

双向链表结构：无需系统扩容，新增结点，维护结点指针关系即可。

- **linkFirst（E）**：插入指定元素到头结点前。

1. 构造新结点：备份头指针、创建当前结点、链接前驱、链接后继。
2. 原头结点为空：更新尾指针（头指针）。
3. 原头结点不为空：设置该结点为原头结点的前驱。
4. 更新实际大小。

- **linkLast（E）**：插入指定元素到末尾结点后。

1. 构造新结点：备份尾指针、创建当前结点、链接前驱、链接后继。
2. 原尾结点为空：更新头指针（尾指针）。
3. 原尾结点不为空：设置该结点为原尾结点的后继。
4. 更新实际大小。

- **linkBefore（E，Node< E >）**：插入元素到某个结点前。

1. 构造新结点：备份后结点（指那个某结点）的前驱指针、创建当前结点、链接前驱、链接后继。
2. 原前驱结点为空：更新头指针（尾指针）。
3. 原前驱结点不为空：设置该结点为原后前驱结点的后继。
4. 更新实际大小。

```java
// 插入指定元素到头结点前
private void linkFirst(E e) {
    final Node<E> f = first;
    final Node<E> newNode = new Node<>(null, e, f);
    first = newNode;// 更新first指针指向新结点
    if (f == null)// 原头结点为空
        last = newNode;// 更新末尾指针
    else
        f.prev = newNode;// 设置该结点为原头结点的前驱

    // 更新实际大小
    size++;
    modCount++;
}

// 插入指定元素到末尾结点后
void linkLast(E e) {
    final Node<E> l = last;
    final Node<E> newNode = new Node<>(l, e, null);
    last = newNode;// 更新last指针为当前结点
    if (l == null)// 原尾结点为空
        first = newNode;// 更新头指针
    else
        l.next = newNode;// 设置该结点为原尾结点的后继

    // 更新实际大小
    size++;
    modCount++;
}

// 插入元素到某个结点前
void linkBefore(E e, Node<E> succ) {
    // assert succ != null;
    final Node<E> pred = succ.prev;
    final Node<E> newNode = new Node<>(pred, e, succ);
    succ.prev = newNode;// 更新后结点的前驱为当前结点

    if (pred == null)// 原前驱结点为空
        first = newNode;// 更新头指针
    else
        pred.next = newNode;// 设置该结点为原后前驱结点的后继

    // 更新实际大小
    size++;
    modCount++;
}
```

##### 增加元素方法

- **add（E）**：List接口，添加元素到末尾位置。作为队列时，由于是链表实现的，所以不会触发队列已满异常。

1. 插入指定元素到尾结点后、返回true。

- **add（int，E）**：List接口，添加元素到指定位置。无返回值。

1. 索引指针校验。
2. 索引等于实际大小：插入指定元素到末尾结点后。
3. 索引小于实际大小：插入元素到某个结点前。

- **offer（E）**：Queue接口，添加元素到队尾。
- **addFirst（E）**：Deque接口，添加元素到队头，由于是链表实现的，所以不会触发队列已满异常。
- **addLast（E）**：Deque接口，添加元素到队尾，由于是链表实现的，所以不会触发队列已满异常。
- **offerFirst（E）**：Deque接口，添加元素到队头。
- **offerLast（E）**：Deque接口，添加元素到队尾。
- **push（E）**：Deque接口，作为栈的方法使用，添加元素到队头（队列方法默认是添加到队尾）。

```java
// List、Queue接口，添加元素到队尾。作为队列时，由于是链表实现的，所以不会触发队列已满异常。
public boolean add(E e) {
    linkLast(e);
    return true;
}

// List接口，添加元素到指定位置
public void add(int index, E element) {
    checkPositionIndex(index);// 索引指针校验
    if (index == size)
        linkLast(element);// 添加元素到末尾位置
    else
        linkBefore(element, node(index));// 添加元素到结点前的位置
}

// Queue接口，添加元素到队尾
public boolean offer(E e) {
    return add(e);
}

// Deque接口，添加元素到队头，由于是链表实现的，所以不会触发队列已满异常。
public void addFirst(E e) {
    linkFirst(e);
}

// Deque接口，添加元素到队尾，由于是链表实现的，所以不会触发队列已满异常。
public void addLast(E e) {
    linkLast(e);
}

// Deque接口，添加元素到队头
public boolean offerFirst(E e) {
    addFirst(e);
    return true;
}

// Deque接口，添加元素到队尾
public boolean offerLast(E e) {
    addLast(e);
    return true;
}

// Deque接口，作为栈的方法使用，添加元素到队头（队列方法默认是添加到队尾）
public void push(E e) {
    addFirst(e);
}
```

##### 获取元素方法

作为队列时，不会有替换元素的方法，且获取元素方法都是检索栈顶的元素。

- **get（int）**：List接口，根据索引获取元素。

1. 索引越界校验。
2. 根据索引获取结点O(n/2)：如果指针在链表的前半部分，则从前半部分查找，返回index位置结点；否则，则从后半部分查找，返回index位置结点。
3. 返回该结点元素。

- **element（）**：Queue接口方法，获取队头元素，如果队列为空，则会抛出异常。
- **peek（）**：Queue接口方法，获取队头元素，如果队列为空，不会抛出异常，而是返回null。
- **getFirst（）**：Deque接口方法，获取队头元素，如果队列为空，则会抛出异常。
- **getLast（）**：Deque接口方法，获取队尾元素，如果队列为空，则会抛出异常。
- **peekFirst（）**：Deque接口方法，获取队头元素，如果队列为空，不会抛出异常，而是返回null。
- **peekLast（）**：Deque接口方法，获取队尾元素，如果队列为空，不会抛出异常，而是返回null。

```java
// List接口，根据索引获取元素
public E get(int index) {
    checkElementIndex(index);// 索引越界校验 
    return node(index).item;// 根据索引获取结点, 返回该结点元素, O(n/2)
}
Node<E> node(int index) {
    // assert isElementIndex(index);
    if (index < (size >> 1)) {
        // 如果指针在链表的前半部分, 则从前半部分查找, 返回index位置结点
        Node<E> x = first;
        for (int i = 0; i < index; i++)
            x = x.next;
        return x;
    } else {
        // 否则，则从后半部分查找, 返回index位置结点
        Node<E> x = last;
        for (int i = size - 1; i > index; i--)
            x = x.prev;
        return x;
    }
}

// Queue接口，获取队头元素，如果队列为空，则会抛出异常
public E element() {
    return getFirst();
}

// Queue接口方法，获取队头元素，如果队列为空，不会抛出异常，而是返回null
public E peek() {
    final Node<E> f = first;
    return (f == null) ? null : f.item;
}

// Deque接口方法，获取队头元素，如果队列为空，则会抛出异常
public E getFirst() {
    final Node<E> f = first;
    if (f == null)
        throw new NoSuchElementException();
    return f.item;
}

// Deque接口方法，获取队尾元素，如果队列为空，则会抛出异常
public E getLast() {
    final Node<E> l = last;
    if (l == null)
        throw new NoSuchElementException();
    return l.item;
}

// Deque接口方法，获取队头元素，如果队列为空，不会抛出异常，而是返回null
public E peekFirst() {
    final Node<E> f = first;
    return (f == null) ? null : f.item;
}

// Deque接口方法，获取队尾元素，如果队列为空，不会抛出异常，而是返回null
public E peekLast() {
    final Node<E> l = last;
    return (l == null) ? null : l.item;
}
```

##### 删除元素方法

- **remove（int）**：List接口，删除指定位置元素。

1. 索引越界校验。
2. 根据索引获取结点O(n/2)：如果指针在链表的前半部分，则从前半部分查找，返回index位置结点；否则，则从后半部分查找，返回index位置结点。
3. 解除该结点：维护该结点原前驱、后继结点的指针，清空该结点、前驱、后继，更新实际大小，返回旧元素。

- **remove（Object）**：List，Deque接口，删除指定元素，使用equals（...）判断。

1. 元素为空：遍历找到第一个null，解除该结点。
2. 元素不为空：遍历找到第一个equal的元素，解除该结点。
3. 删除成功返回true，删除失败返回false。

- **remove（）**：Queue接口方法，删除队头元素，如果队列为空，则会抛出异常。
- **poll（）**：Queue接口方法，删除队头元素，如果队列为空，不会抛出异常，而是返回null。
- **removeFirst（）**：Deque接口方法，删除队头元素，如果队列为空，则会抛出异常。
- **removeLast（）**：Deque接口方法，删除队尾元素，如果队列为空，则会抛出异常。
- **pollFirst（）**：Deque接口方法，删除队头元素，如果队列为空，不会抛出异常，而是返回null。
- **pollLast（）**：Deque接口方法，删除队尾元素，如果队列为空，不会抛出异常，而是返回null。
- **removeFirstOccurrence（Object）**：Deque接口方法，删除第一个指定的元素(从头到尾找)，找到并删除成功返回true，否则返回false。
- **removeLastOccurrence（Object）**：Deque接口方法，删除最后一个指定的元素(从尾到头找)，找到并删除成功返回true，否则返回false。
- **pop（）**：Deque接口方法，作为栈的方法使用，删除队头元素（队列方法默认也是删除队头元素）。

```java
// List接口，删除指定位置元素
public E remove(int index) {
    checkElementIndex(index);// 索引越界校验
    return unlink(node(index));// 根据索引获取结点, 然后解除结点
}
E unlink(Node<E> x) {
    // assert x != null;
    final E element = x.item;
    final Node<E> next = x.next;
    final Node<E> prev = x.prev;
    
    if (prev == null) {// 原前驱为空
        first = next;// 更新头结点为原后继
    } else {// 否则，更新原前驱的后继为原后继，清空该结点的前驱
        prev.next = next;
        x.prev = null;
    }

    if (next == null) {// 原后继为空
        last = prev;// 更新尾结点为原前驱
    } else {// 否则，更新原后继的前驱为原前驱，清空该结点的后继
        next.prev = prev;
        x.next = null;
    }

    // 20201118 清空该节点，更新实际大小
    x.item = null;
    size--;
    modCount++;

    // 返回旧元素
    return element;
}

// List，Deque接口，删除指定元素：equals判断
public boolean remove(Object o) {
    if (o == null) {
        // 遍历找到第一个null, 解除该结点
        for (Node<E> x = first; x != null; x = x.next) {
            if (x.item == null) {
                unlink(x);
                return true;
            }
        }
    } else {
        // 遍历找到同一个元素, 解除该结点
        for (Node<E> x = first; x != null; x = x.next) {
            if (o.equals(x.item)) {
                unlink(x);
                return true;
            }
        }
    }

    return false;
}

// Queue接口方法，删除队头元素，如果队列为空，则会抛出异常
public E remove() {
    return removeFirst();
}

// Queue接口方法，删除队头元素，如果队列为空，不会抛出异常，而是返回null
public E poll() {
    final Node<E> f = first;
    return (f == null) ? null : unlinkFirst(f);
}

// Deque接口方法，删除队头元素，如果队列为空，则会抛出异常
public E removeFirst() {
    final Node<E> f = first;
    if (f == null)
        throw new NoSuchElementException();
    return unlinkFirst(f);
}

// Deque接口方法，删除队尾元素，如果队列为空，则会抛出异常
public E removeLast() {
    final Node<E> l = last;
    if (l == null)
        throw new NoSuchElementException();
    return unlinkLast(l);
}

// Deque接口方法，删除队头元素，如果队列为空，不会抛出异常，而是返回null
public E pollFirst() {
    final Node<E> f = first;
    return (f == null) ? null : unlinkFirst(f);
}

// Deque接口方法，删除队尾元素，如果队列为空，不会抛出异常，而是返回null
public E pollLast() {
    final Node<E> l = last;
    return (l == null) ? null : unlinkLast(l);
}

// Deque接口方法，删除第一个指定的元素(从头到尾找)，找到并删除成功返回true，否则返回false
public boolean removeFirstOccurrence(Object o) {
    return remove(o);
}

// Deque接口方法，删除最后一个指定的元素(从尾到头找)，找到并删除成功返回true，否则返回false
public boolean removeLastOccurrence(Object o) {
    if (o == null) {
        for (Node<E> x = last; x != null; x = x.prev) {
            if (x.item == null) {
                unlink(x);
                return true;
            }
        }
    } else {
        for (Node<E> x = last; x != null; x = x.prev) {
            if (o.equals(x.item)) {
                unlink(x);
                return true;
            }
        }
    }
    return false;
}

// Deque接口方法，作为栈的方法使用，删除队头元素（队列方法默认也是删除队头元素）
public E pop() {
    return removeFirst();
}
```

##### 替换元素方法

作为队列时，不会有替换元素的方法，且获取元素方法都是检索栈顶的元素。

- **set（int，E）**：替换指定位置的元素。

1. 索引越界校验、根据索引获取结点、替换结点元素、返回旧元素。

```java
// 替换指定位置的元素
public E set(int index, E element) {
    checkElementIndex(index);// 索引越界校验
    Node<E> x = node(index);// 根据索引获取结点
    E oldVal = x.item;
    x.item = element;// 替换结点元素
    return oldVal;
}
```

#### CopyOnWriteArrayList

![1621484957471](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1621484957471.png)

##### 特点

- ArrayList的线程安全变体，其中所有可变操作（add、remove、set方法）都**通过对基础数组进行全新复制来实现**，不需要扩容机制。
- 在**无法或不想同步遍历**而又需要防止并发线程之间的干扰时很有用。
- **基于数组快照方式查找数据**，所有迭代操作都没有并发修改检查，不需要快速失败，但不支持add、remove、set方法，会抛出**UnsupportedOperationException**。

##### 构造方法

- **无参的构造函数**：创建一个0长度的数组。
- **指定复制数组的构造函数**：Arrays.copyOf（...）复制数组（底层调用的是System.arraycopy（...））。
- **指定复制集合的构造函数**：调用Collection接口toArray（）转换集合为数组，再用Arrays.copyOf（...）复制数组（底层调用的是System.arraycopy（...））。

```java
public class CopyOnWriteArrayList<E>
implements List<E>, RandomAccess, Cloneable, java.io.Serializable {
	final transient ReentrantLock lock = new ReentrantLock();
	private transient volatile Object[] array;// volatile修饰
   
    final void setArray(Object[] a) {
        array = a;
    }
    
	// 无参的构造函数
	public CopyOnWriteArrayList() {
        setArray(new Object[0]);
    }
    
    // 指定复制数组的构造函数
    public CopyOnWriteArrayList(E[] toCopyIn) {
        setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));
    }
    
    // 指定复制集合的构造函数
    public CopyOnWriteArrayList(Collection<? extends E> c) {
        Object[] elements;
        if (c.getClass() == CopyOnWriteArrayList.class)
            elements = ((CopyOnWriteArrayList<?>)c).getArray();
        else {
            elements = c.toArray();
            // c.toArray might (incorrectly) not return Object[] (see 6260652)
            if (elements.getClass() != Object[].class)
                elements = Arrays.copyOf(elements, elements.length, Object[].class);
        }
        setArray(elements);
    }
}
```

##### 迭代方法

所有迭代操作**都没有并发修改检查**，检测对象有没有发生并发修改的操作。

next（）、previous（）、forEachRemaining（Consumer）：**基于snapshot查找数据**。

不支持remove（）、set（）、add（）方法，会抛出**UnsupportedOperationException**。

- **iterator（）**：获取Collection迭代器。
- **listIterator（）**：获取默认的List迭代器。
- **listIterator（int）**：获取指定索引的List迭代器。

```java
// 获取Collection迭代器
public Iterator<E> iterator() {
    return new COWIterator<E>(getArray(), 0);
}

// 获取默认的List迭代器
public ListIterator<E> listIterator() {
    return new COWIterator<E>(getArray(), 0);
}

// 获取指定索引的List迭代器
public ListIterator<E> listIterator(int index) {
    Object[] elements = getArray();
    int len = elements.length;
    if (index < 0 || index > len)
        throw new IndexOutOfBoundsException("Index: "+index);

    return new COWIterator<E>(elements, index);
}

static final class COWIterator<E> implements ListIterator<E> {
    /** Snapshot of the array */
    private final Object[] snapshot;
    /** Index of element to be returned by subsequent call to next.  */
    private int cursor;

    private COWIterator(Object[] elements, int initialCursor) {
        cursor = initialCursor;
        snapshot = elements;
    }

    public boolean hasNext() {
        return cursor < snapshot.length;
    }

    public boolean hasPrevious() {
        return cursor > 0;
    }
	
    public E next() {
        if (! hasNext())
            throw new NoSuchElementException();
        return (E) snapshot[cursor++];// 基于snapshot查找数据
    }

    public E previous() {
        if (! hasPrevious())
            throw new NoSuchElementException();
        return (E) snapshot[--cursor];// 基于snapshot查找数据
    }

    public int nextIndex() {
        return cursor;
    }

    public int previousIndex() {
        return cursor-1;
    }
	
    // 不支持remove（）、set（）、add（）方法，会抛出UnsupportedOperationException
    public void remove() {
        throw new UnsupportedOperationException();
    }
    public void set(E e) {
        throw new UnsupportedOperationException();
    }
    public void add(E e) {
        throw new UnsupportedOperationException();
    }

    @Override
    public void forEachRemaining(Consumer<? super E> action) {
        Objects.requireNonNull(action);
        Object[] elements = snapshot;// 基于snapshot查找数据
        final int size = elements.length;
        for (int i = cursor; i < size; i++) {
            E e = (E) elements[i];
            action.accept(e);
        }
        cursor = size;
    }
}
```

##### 扩容方法

**不需要扩容机制**，因为每个数组都是“刚需”，而每次添加又都全量复制。

##### 增加元素方法

所有添加动作之前都需要**ReentrantLock加锁**，在添加完成后解锁。

所有添加动作都是通过Arrays.copyOf（...）**复制新数组**来完成的（底层调用的是System.arraycopy（...））。

- add（E）：添加元素到末尾位置。
- add（int，E）：添加元素到指定位置。
- addIfAbsent（E）：如果**当前快照不存在指定元素**，才添加该元素到末尾位置。

```java
// 添加元素到末尾位置
public boolean add(E e) {
    final ReentrantLock lock = this.lock;
    lock.lock();// ReentrantLock加锁
    try {
        Object[] elements = getArray();
        int len = elements.length;
        Object[] newElements = Arrays.copyOf(elements, len + 1);
        newElements[len] = e;
        setArray(newElements);
        return true;
    } finally {
        lock.unlock();
    }
}

// 添加元素到指定位置
public void add(int index, E element) {
    final ReentrantLock lock = this.lock;
    lock.lock();// ReentrantLock加锁
    try {
        Object[] elements = getArray();
        int len = elements.length;
        if (index > len || index < 0)
            throw new IndexOutOfBoundsException("Index: "+index+
                                                ", Size: "+len);
        Object[] newElements;
        int numMoved = len - index;
        if (numMoved == 0)
            newElements = Arrays.copyOf(elements, len + 1);
        else {
            newElements = new Object[len + 1];
            System.arraycopy(elements, 0, newElements, 0, index);
            System.arraycopy(elements, index, newElements, index + 1,
                             numMoved);
        }
        newElements[index] = element;
        setArray(newElements);
    } finally {
        lock.unlock();
    }
}

// 如果当前快照不存在指定元素，才添加该元素到末尾位置
public boolean addIfAbsent(E e) {
    Object[] snapshot = getArray();
    return indexOf(e, snapshot, 0, snapshot.length) >= 0 ? false :
    addIfAbsent(e, snapshot);
}
private boolean addIfAbsent(E e, Object[] snapshot) {
    final ReentrantLock lock = this.lock;
    lock.lock();// ReentrantLock加锁
    try {
        Object[] current = getArray();
        int len = current.length;
        if (snapshot != current) {
            // Optimize for lost race to another addXXX operation
            int common = Math.min(snapshot.length, len);
            for (int i = 0; i < common; i++)
                if (current[i] != snapshot[i] && eq(e, current[i]))
                    return false;
            if (indexOf(e, current, common, len) >= 0)
                return false;
        }
        Object[] newElements = Arrays.copyOf(current, len + 1);
        newElements[len] = e;
        setArray(newElements);
        return true;
    } finally {
        lock.unlock();
    }
}
```

##### 获取元素方法

- get（int）：根据索引获取元素。

1. 获取当前数组快照、根据索引获取快照中的元素。

```java
// 根据索引获取元素
public E get(int index) {
    return get(getArray(), index);
}
final Object[] getArray() {
    return array;
}
private E get(Object[] a, int index) {
    return (E) a[index];
}

```

##### 删除元素方法

所有删除动作之前都需要**ReentrantLock加锁**，在删除完成后解锁。

所有删除动作都是通过Arrays.copyOf（...）**复制新数组**来完成的（底层调用的是System.arraycopy（...））。

- **remove（int）**：删除指定索引元素。
- **remove（Object）**：删除指定元素，用equals（...）判断**数组快照**。
- **removeRange（int，int）**：删除fromIndex~toIndex-1内的元素。无返回值。

```java
// 删除指定索引元素
public E remove(int index) {
    final ReentrantLock lock = this.lock;
    lock.lock();// ReentrantLock加锁
    try {
        Object[] elements = getArray();
        int len = elements.length;
        E oldValue = get(elements, index);
        int numMoved = len - index - 1;
        if (numMoved == 0)
            setArray(Arrays.copyOf(elements, len - 1));
        else {
            Object[] newElements = new Object[len - 1];
            System.arraycopy(elements, 0, newElements, 0, index);
            System.arraycopy(elements, index + 1, newElements, index,
                             numMoved);
            setArray(newElements);
        }
        return oldValue;
    } finally {
        lock.unlock();
    }
}

// 删除指定元素
public boolean remove(Object o) {
    Object[] snapshot = getArray();
    int index = indexOf(o, snapshot, 0, snapshot.length);
    return (index < 0) ? false : remove(o, snapshot, index);
}
private static int indexOf(Object o, Object[] elements,
                           int index, int fence) {
    if (o == null) {
        for (int i = index; i < fence; i++)
            if (elements[i] == null)
                return i;
    } else {
        for (int i = index; i < fence; i++)
            if (o.equals(elements[i]))
                return i;
    }
    return -1;
}
private boolean remove(Object o, Object[] snapshot, int index) {
    final ReentrantLock lock = this.lock;
    lock.lock();// ReentrantLock加锁
    try {
        Object[] current = getArray();
        int len = current.length;
        if (snapshot != current) findIndex: {
            int prefix = Math.min(index, len);
            for (int i = 0; i < prefix; i++) {
                if (current[i] != snapshot[i] && eq(o, current[i])) {
                    index = i;
                    break findIndex;
                }
            }
            if (index >= len)
                return false;
            if (current[index] == o)
                break findIndex;
            index = indexOf(o, current, index, len);
            if (index < 0)
                return false;
        }
        Object[] newElements = new Object[len - 1];
        System.arraycopy(current, 0, newElements, 0, index);
        System.arraycopy(current, index + 1,
                         newElements, index,
                         len - index - 1);
        setArray(newElements);
        return true;
    } finally {
        lock.unlock();
    }
}

// 删除fromIndex~toIndex-1内的元素
void removeRange(int fromIndex, int toIndex) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        Object[] elements = getArray();
        int len = elements.length;

        if (fromIndex < 0 || toIndex > len || toIndex < fromIndex)
            throw new IndexOutOfBoundsException();
        int newlen = len - (toIndex - fromIndex);
        int numMoved = len - toIndex;
        if (numMoved == 0)
            setArray(Arrays.copyOf(elements, newlen));
        else {
            Object[] newElements = new Object[newlen];
            System.arraycopy(elements, 0, newElements, 0, fromIndex);
            System.arraycopy(elements, toIndex, newElements,
                             fromIndex, numMoved);
            setArray(newElements);
        }
    } finally {
        lock.unlock();
    }
}
```

##### 替换元素方法

- **set（int，E）**：替换指定位置的元素。
  - 需要**ReentrantLock加锁**，在完成后解锁。
  - 通过Arrays.copyOf（...）**复制新数组**来完成的（底层调用的是System.arraycopy（...））。

```java
// 替换指定位置的元素
public E set(int index, E element) {
    final ReentrantLock lock = this.lock;
    lock.lock();// ReentrantLock加锁
    try {
        Object[] elements = getArray();
        E oldValue = get(elements, index);

        if (oldValue != element) {
            int len = elements.length;
            Object[] newElements = Arrays.copyOf(elements, len);
            newElements[index] = element;
            setArray(newElements);
        } else {
            // Not quite a no-op; ensures volatile write semantics
            setArray(elements);
        }
        return oldValue;
    } finally {
        lock.unlock();
    }
}
```

#### SynchronizedList

![1621503899100](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1621503899100.png)

##### SynchronizedCollection

- java.util.Collections内部类
- 成员变量有Collection引入和一个mutex对象锁，用于包装传入的集合，使其所有方法都能成为同步方法（**加synchronized关键字**）。
- 获取集合的迭代器后，需要自己实现同步的迭代方法。

```java
public class Collections {
    static class SynchronizedCollection<E> implements Collection<E>, Serializable {
        private static final long serialVersionUID = 3053995032091335093L;

        final Collection<E> c;  // Backing Collection
        final Object mutex;     // Object on which to synchronize

        SynchronizedCollection(Collection<E> c) {
            this.c = Objects.requireNonNull(c);
            mutex = this;
        }

        SynchronizedCollection(Collection<E> c, Object mutex) {
            this.c = Objects.requireNonNull(c);
            this.mutex = Objects.requireNonNull(mutex);
        }

        public int size() {
            synchronized (mutex) {return c.size();}
        }
        public boolean isEmpty() {
            synchronized (mutex) {return c.isEmpty();}
        }
        public boolean contains(Object o) {
            synchronized (mutex) {return c.contains(o);}
        }
        public boolean add(E e) {
            synchronized (mutex) {return c.add(e);}
        }
        public boolean remove(Object o) {
            synchronized (mutex) {return c.remove(o);}
        }
        // Override default methods in Collection
        @Override
        public void forEach(Consumer<? super E> consumer) {
            synchronized (mutex) {c.forEach(consumer);}
        }
		...
    }
}
```

##### 特点

- java.util.Collections内部类
- 继承自SynchronizedCollection类，相当于拥有成员变量Collection引入和mutex对象锁，用于包装传入的集合，使（**其所有方法都能成为同步方法加synchronized关键字**），其在SynchronizedCollection类上扩展了属于List集合的同步方法。
- 同样，在获取集合的迭代器后，需要自己实现同步的迭代方法。
- 迭代器是否具有快速失败的特性，取决于传入的List引用的实际类型。

##### 构造方法

- **只传入List集合的构造函数**：设置List引用，持有父类mutex对象锁。
- **传入List集合与对象锁的构造函数**：设置List引用与对象锁引用。

```java
static class SynchronizedList<E> extends SynchronizedCollection<E> implements List<E> {
    final List<E> list;
    
    // 只传入List集合的构造函数
    SynchronizedList(List<E> list) {
        super(list);
        this.list = list;
    }
    // 传入List集合与对象锁的构造函数
    SynchronizedList(List<E> list, Object mutex) {
        super(list, mutex);
        this.list = list;
    }
}
```

##### 迭代方法

- **listIterator（）**：获取List引用的默认迭代器，其同步迭代方法需要自己实现。
- **listIterator（int）**：获取指定索引的迭代器，其同步迭代方法需要自己实现。

```java
// 获取默认迭代器
public ListIterator<E> listIterator() {
    return list.listIterator(); // Must be manually synched by user
}

// 获取指定索引的迭代器
public ListIterator<E> listIterator(int index) {
    return list.listIterator(index); // Must be manually synched by user
}
```

##### 扩容方法

所有方法都是获取mutex对象锁后，调用引用List的方法，所以无独立实现的扩容机制。

##### 增加元素方法

- **add（E）**：父类方法，添加元素到末尾位置，只做了mutex对象锁的获取，其实现交由引用的List集合。
- **add（int，E）**：添加元素到指定索引的位置，只做了mutex对象锁的获取，其实现交由引用的List集合。

```java
// 父类方法，添加元素到末尾位置
public boolean add(E e) {
    synchronized (mutex) {return c.add(e);}
}

// 添加元素到指定索引的位置
public void add(int index, E element) {
    synchronized (mutex) {list.add(index, element);}
}
```

##### 获取元素方法

- get（int）：获取指定索引的元素，获取方法也需要加mutex锁，其实现同样交由List引用实现。

```java
// 获取指定索引的元素
public E get(int index) {
    synchronized (mutex) {return list.get(index);}
}
```

##### 删除元素方法

- **remove（Object）**：父类方法，删除指定元素，只做了mutex对象锁的获取，其实现交由引用的List集合。
- **remove（int）**：删除指定位置的元素，只做了mutex对象锁的获取，其实现交由引用的List集合。

```java
// 父类方法，删除指定元素
public boolean remove(Object o) {
    synchronized (mutex) {return c.remove(o);}
}

// 删除指定位置的元素
public E remove(int index) {
    synchronized (mutex) {return list.remove(index);}
}
```

##### 替换元素方法

- **set（int，E）**：替换指定位置元素，只做了mutex对象锁的获取，其实现交由引用的List集合。

```java
// 替换指定位置元素
public E set(int index, E element) {
    synchronized (mutex) {return list.set(index, element);}
}
```

#### Vector

![1621505440028](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1621505440028.png)

##### 特点

- {@code Vector}类实现对象的**可增长数组**。 像数组一样，它包含可以使用整数索引访问的组件。 但是，{@ code Vector}的大小可以根据需要增大或缩小，以适应在创建{@code Vector}之后添加和删除项目。
- 每个Vector都尝试通过维持{@code Capacity}和{@code CapacityIncrement}来优化存储管理。 Capacity始终至少与Vector大小一样大； 它通常较大，因为随着向Vector中添加分量，Vector的存储量**将以{@code CapacityIncrement}的大小逐块增加**。 应用程序可以在插入大量组件之前增加Vector的容量。 这减少了增量重新分配的数量。
- 与新的集合实现不同，**{@ code Vector}是同步的**。 如果不需要线程安全的实现，建议使用{@link ArrayList}代替{@code Vector}。
- 迭代器是快速失败的。

##### 构造方法

- **空参的构造函数**：默认容量为10，默认容量增速为0，即扩容时增长2倍。
- **指定容量的构造函数**：默认容量增速为0，即扩容时增长2倍。
- **指定容量以及容量增速的构造函数**。
- **指定复制集合的构造函数**：默认容量增速为0，即扩容时增长2倍。

```java
public class Vector<E> extends AbstractList<E> implements List<E>, RandomAccess, Cloneable, java.io.Serializable
{
	protected Object[] elementData;
	protected int elementCount;
	protected int capacityIncrement;
	
	// 空参的构造函数，默认容量为10，默认容量增速为0，即扩容时增长2倍
	public Vector() {
        this(10);
    }

	// 指定容量的构造函数，默认容量增速为0，即扩容时增长2倍
    public Vector(int initialCapacity) {
        this(initialCapacity, 0);
    }
    
    // 指定容量以及容量增速的构造函数
    public Vector(int initialCapacity, int capacityIncrement) {
        super();
        if (initialCapacity < 0)
            throw new IllegalArgumentException("Illegal Capacity: "+
                                               initialCapacity);
        this.elementData = new Object[initialCapacity];
        this.capacityIncrement = capacityIncrement;
    }
    
    // 指定复制集合的构造函数，默认容量增速为0，即扩容时增长2倍
    public Vector(Collection<? extends E> c) {
        elementData = c.toArray();
        elementCount = elementData.length;
        // c.toArray might (incorrectly) not return Object[] (see 6260652)
        if (elementData.getClass() != Object[].class)
            elementData = Arrays.copyOf(elementData, elementCount, Object[].class);
    }
}
```

##### 迭代方法

与Arraylist的相同，所有迭代操作都有：**并发修改检查**，检测对象有没有发生并发修改的操作。

- **iterator（）**：获取Collection迭代器。
- **listIterator（）**：获取默认的List迭代器。
- **listIterator（int）**：获取指定索引的List迭代器。

##### 扩容方法

- **扩容条件**：数组实际长度（size）大于当前数组长度（elementData.length）时。

- **grow（int）**：增长元素数组到指定容量。

1. 计算新容量： = 旧容量（当前元素数组实际长度） *  2。
2. 容量判断：如果新容量小于指定容量，则设置为指定容量。以及最大长度判断：Integer.MAX_VALUE - 8。
3. 移动元素到新数组：Arrays.copyOf（...）（底层调用的是System.arraycopy（...））。

```java
// 扩容条件
private void ensureCapacityHelper(int minCapacity) {
    // overflow-conscious code
    if (minCapacity - elementData.length > 0)
        grow(minCapacity);
}

// 扩容方法
private void grow(int minCapacity) {
    // overflow-conscious code
    int oldCapacity = elementData.length;
    int newCapacity = oldCapacity + ((capacityIncrement > 0) ?
                                     capacityIncrement : oldCapacity);
    if (newCapacity - minCapacity < 0)
        newCapacity = minCapacity;
    if (newCapacity - MAX_ARRAY_SIZE > 0)
        newCapacity = hugeCapacity(minCapacity);
    elementData = Arrays.copyOf(elementData, newCapacity);
}
```

##### 增加元素方法

- **add（E）**：添加元素到末尾位置。方法开始前需要获取synchronized可重入锁，所以是线程安全的。

1. 更新模数（修改次数）、扩容判断、插入元素到数组末尾、更新实际大小、返回true。

- **add（int，E）**：添加元素到指定位置。无返回值。方法开始前需要获取synchronized可重入锁，所以是线程安全的。

1. 更新模数（修改次数）、索引指针校验、扩容判断、System.arraycopy（...）复制移动数组、插入元素到指定位置、更新实际大小。

- **addElement（E）**：独立实现的方法，添加元素到末尾位置。方法开始前需要获取synchronized可重入锁，所以是线程安全的。

1. 更新模数（修改次数）、扩容判断、插入元素到数组末尾、更新实际大小、返回true。

```java
// 添加元素到末尾位置
public synchronized boolean add(E e) {
    modCount++;
    ensureCapacityHelper(elementCount + 1);
    elementData[elementCount++] = e;
    return true;
}

// 添加元素到指定位置
public void add(int index, E element) {
    insertElementAt(element, index);
}
public synchronized void insertElementAt(E obj, int index) {
    modCount++;
    if (index > elementCount) {
        throw new ArrayIndexOutOfBoundsException(index
                                                 + " > " + elementCount);
    }
    ensureCapacityHelper(elementCount + 1);
    System.arraycopy(elementData, index, elementData, index + 1, elementCount - index);
    elementData[index] = obj;
    elementCount++;
}

// 独立实现的方法，添加元素到末尾位置
public synchronized void addElement(E obj) {
    modCount++;
    ensureCapacityHelper(elementCount + 1);
    elementData[elementCount++] = obj;
}
```

##### 获取元素方法

- **get（int）**：获取指定索引位置的元素O（1）。方法开始前需要获取synchronized可重入锁，所以是线程安全的。

```java
// 获取指定索引位置的元素
public synchronized E get(int index) {
    if (index >= elementCount)
        throw new ArrayIndexOutOfBoundsException(index);

    return elementData(index);
}
```

##### 删除元素方法

- **remove（int）**：删除指定索引元素。方法开始前需要获取synchronized可重入锁，所以是线程安全的。

1. 索引越界校验。
2. 根据索引获取数组元素，O(1)。
3. 移动数组元素：System.arraycopy（...）。
4. 清空元素、实际大小 - 1。
5. 返回旧元素。

- **remove（Object）**：删除指定元素，用equals（...）判断。方法开始前需要获取synchronized可重入锁，所以是线程安全的。

1. 元素为null：遍历数组、找到第一个为null的元素、移动数组元素、清空元素、实际大小 - 1、返回true。
2. 元素非null：遍历数组、找到第一个equal的元素、移动数组元素、清空元素、实际大小 - 1、返回true。
3. 否则代表删除失败，返回false。

- **removeRange（int，int）**：删除fromIndex~toIndex-1内的元素。无返回值。方法开始前需要获取synchronized可重入锁，所以是线程安全的。

1. 移动数组元素、清空元素、更新实际大小 。

```java
// 删除指定索引元素
public synchronized E remove(int index) {
    modCount++;
    if (index >= elementCount)
        throw new ArrayIndexOutOfBoundsException(index);
    E oldValue = elementData(index);

    int numMoved = elementCount - index - 1;
    if (numMoved > 0)
        System.arraycopy(elementData, index+1, elementData, index,
                         numMoved);
    elementData[--elementCount] = null; // Let gc do its work

    return oldValue;
}

// 删除指定元素，用equals（...）判断
public boolean remove(Object o) {
    return removeElement(o);
}
public synchronized boolean removeElement(Object obj) {
    modCount++;
    int i = indexOf(obj);
    if (i >= 0) {
        removeElementAt(i);
        return true;
    }
    return false;
}
public synchronized void removeElementAt(int index) {
    modCount++;
    if (index >= elementCount) {
        throw new ArrayIndexOutOfBoundsException(index + " >= " +
                                                 elementCount);
    }
    else if (index < 0) {
        throw new ArrayIndexOutOfBoundsException(index);
    }
    int j = elementCount - index - 1;
    if (j > 0) {
        System.arraycopy(elementData, index + 1, elementData, index, j);
    }
    elementCount--;
    elementData[elementCount] = null; /* to let gc do its work */
}

// 删除fromIndex~toIndex-1内的元素
protected synchronized void removeRange(int fromIndex, int toIndex) {
    modCount++;
    int numMoved = elementCount - toIndex;
    System.arraycopy(elementData, toIndex, elementData, fromIndex,
                     numMoved);

    // Let gc do its work
    int newElementCount = elementCount - (toIndex-fromIndex);
    while (elementCount != newElementCount)
        elementData[--elementCount] = null;
}
```

##### 替换元素方法

- **set（int，E）**：替换指定位置的元素。方法开始前需要获取synchronized可重入锁，所以是线程安全的。

1. 索引越界检查、根据索引获取数组元素O(1)、设置数组元素O(1)、返回旧元素。

- **setElementAt（E，int）**：独立实现的方法，替换指定位置的元素。无返回值。方法开始前需要获取synchronized可重入锁，所以是线程安全的。

```java
// 替换指定位置的元素
public synchronized E set(int index, E element) {
    if (index >= elementCount)
        throw new ArrayIndexOutOfBoundsException(index);

    E oldValue = elementData(index);
    elementData[index] = element;
    return oldValue;
}

// 独立实现的方法，替换指定位置的元素
public synchronized void setElementAt(E obj, int index) {
    if (index >= elementCount) {
        throw new ArrayIndexOutOfBoundsException(index + " >= " +
                                                 elementCount);
    }
    elementData[index] = obj;
}
```

#### Stack

![1621509325202](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1621509325202.png)

##### 特点

- **Stack类表示对象的后进先出（LIFO）堆栈**。 它通过五个操作扩展了Vector类，这些操作允许将Vector视为堆栈。 提供了通常的push和pop方法，一种查看堆栈顶部元素的peek方法，一种判断堆栈是否为空的empty方法，和一种查找指定元素距离堆栈底部高度的search方法。 
- 首次创建堆栈时，不做任何实现。添加元素时，从顶部开始添加。

##### 构造方法

- **只有无参构造方法**：该方法没有任何实现。

```java
public class Stack<E> extends Vector<E> {
    public Stack() {
    }
}
```

##### push方法

- **push（E）**：添加元素到栈顶，交由父类Vector#addElement（E）实现。父类方法开始前需要获取synchronized可重入锁，所以是线程安全的。

1. 更新模数（修改次数）、扩容判断、插入元素到数组末尾、更新实际大小、返回true。

```java
// 添加元素到栈顶
public E push(E item) {
    addElement(item);
    return item;
}
// Vector#addElement（E）
public synchronized void addElement(E obj) {
    modCount++;
    ensureCapacityHelper(elementCount + 1);
    elementData[elementCount++] = obj;
}
```

##### pop方法

- **pop（）**：弹出栈顶元素，交由父类Vector#removeElementAt（int）实现。父类方法开始前需要获取synchronized可重入锁，所以是线程安全的。

1. 备份栈顶元素、移动数组元素、清空元素、实际大小 - 1、返回旧元素。

```java
public synchronized E pop() {
    E obj;
    int len = size();
    obj = peek();
    removeElementAt(len - 1);
    return obj;
}
// Vector#removeElementAt（int）
public synchronized void removeElementAt(int index) {
    modCount++;
    if (index >= elementCount) {
        throw new ArrayIndexOutOfBoundsException(index + " >= " +
                                                 elementCount);
    }
    else if (index < 0) {
        throw new ArrayIndexOutOfBoundsException(index);
    }
    int j = elementCount - index - 1;
    if (j > 0) {
        System.arraycopy(elementData, index + 1, elementData, index, j);
    }
    elementCount--;
    elementData[elementCount] = null; /* to let gc do its work */
}
```

##### peek方法

- **peek（）**：查看栈顶元素O（1），交由父类Vector#elementData（int）实现，O（1）。父类方法开始前需要获取synchronized可重入锁，所以是线程安全的。

```java
// 查看栈顶元素O（1）
public synchronized E peek() {
    int len = size();

    if (len == 0)
        throw new EmptyStackException();
    return elementAt(len - 1);
}
// Vector#elementAt（int）
public synchronized E elementAt(int index) {
    if (index >= elementCount) {
        throw new ArrayIndexOutOfBoundsException(index + " >= " + elementCount);
    }

    return elementData(index);
}
// Vector#elementData（int），O（1）
E elementData(int index) {
    return (E) elementData[index];
}
```

##### empty方法

- **empty（）**：判断栈是否为空，即实际元素个数是否为0。获取实际元素个数方法交由父类Vector#size（），其方法开始前需要获取synchronized可重入锁，所以是线程安全的。

```java
// 判断栈是否为空，即实际元素个数是否为0
public boolean empty() {
    return size() == 0;
}
// Vector#size（）
public synchronized int size() {
    return elementCount;
}
```

##### search方法

- **search（）**：查找元素距离堆栈底部的高度，交由父类Vector#lastIndexOf（Object，int）实现。父类方法开始前需要获取synchronized可重入锁，所以是线程安全的。

```java
// 查找元素距离堆栈底部的高度
public synchronized int search(Object o) {
    int i = lastIndexOf(o);

    if (i >= 0) {
        return size() - i;
    }
    return -1;
}
// Vector#lastIndexOf（Object）
public synchronized int lastIndexOf(Object o) {
    return lastIndexOf(o, elementCount-1);
}
// Vector#lastIndexOf（Object，int）
public synchronized int lastIndexOf(Object o, int index) {
    if (index >= elementCount)
        throw new IndexOutOfBoundsException(index + " >= "+ elementCount);

    if (o == null) {
        for (int i = index; i >= 0; i--)
            if (elementData[i]==null)
                return i;
    } else {
        for (int i = index; i >= 0; i--)
            if (o.equals(elementData[i]))
                return i;
    }
    return -1;
}
```

### 2.8. Set？

Set，不包含重复元素的集合，最多包含一个空元素。

```java
// 其接口方法都是Collection接口的方法
public interface Set<E> extends Collection<E> {
    int size();
    boolean isEmpty();
    boolean contains(Object o);
    Iterator<E> iterator();
    Object[] toArray();
    <T> T[] toArray(T[] a);
    boolean add(E e);
    boolean remove(Object o);
    boolean containsAll(Collection<?> c);
    boolean addAll(Collection<? extends E> c);
    boolean retainAll(Collection<?> c);
    boolean removeAll(Collection<?> c);
    void clear();
    boolean equals(Object o);
    int hashCode();
    default Spliterator<E> spliterator() {...}
}
```

- **典型实现**：HashSet、LinkedHashSet、SynchronizedSet

#### HashSet

![1621512944158](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1621512944158.png)

##### 特点

- 实现Set接口，该接口由哈希表（HashMap实例）支持， **不保证集合的迭代顺序**，允许使用null元素。
- add，remove，contain和size方法时间性能恒定。但迭代时间与元素数量和哈希桶容量有关，最坏为O（m * n）（m为桶长度，n为桶中链表长度）。
- 非线程安全的，如果要使用同步的Set方法，可以考虑使用Collections＃synchronizedSet进行包装。
- 迭代器是快速失败的。
- **Set集合没有获取和替换元素的方法。**

##### 构造方法

- **无参的构造函数**：使用默认初始化容量16，默认负载因子0.75。
- **指定复制集合的构造函数**：根据集合大小计算初始容量（size / 0.75） 或者为默认值16。
- **指定初始容量的构造函数**：默认负载因子0.75。
- **指定初始容量和负载因子的构造函数**：该构造方法是defalut级别的，供LinkHashSet使用，同时底层数据结构改用LinkedHashMap存储，多维护了一个双向链表，使得迭代顺序是有序的。

```java
public class HashSet<E> extends AbstractSet<E> implements Set<E>, Cloneable, java.io.Serializable
{
	private transient HashMap<E,Object> map;
	private static final Object PRESENT = new Object();// 用作HashMap中元素的假值
	
	// 无参的构造函数：使用默认初始化容量16，默认负载因子0.75
    public HashSet() {
        map = new HashMap<>();
    }
    
    // 指定复制集合的构造函数：根据集合大小计算初始容量（size / 0.75） 或者为默认值16
    public HashSet(Collection<? extends E> c) {
        map = new HashMap<>(Math.max((int) (c.size()/.75f) + 1, 16));
        addAll(c);
    }
    
    // 指定初始容量的构造函数：默认负载因子0.75
    public HashSet(int initialCapacity) {
        map = new HashMap<>(initialCapacity);
    }
    
    // 指定初始容量和负载因子的构造函数：该构造方法是defalut级别的，供LinkHashSet使用，同时底层数据结构改用LinkedHashMap存储，多维护了一个双向链表，使得迭代顺序是有序的
    HashSet(int initialCapacity, float loadFactor, boolean dummy) {
        // dummy参数留给子类LinkedHashSet使用，注意这里构造的是LinkedHashMap，不是HashMap
        map = new LinkedHashMap<>(initialCapacity, loadFactor);
    }
}
```

##### 迭代方法

- **iterator（）**：获取迭代器，交由成员变量引用HashMap#HashIterator实现，用于遍历HashMap的Node结点的key。

```java
// 获取迭代器
public Iterator<E> iterator() {
    return map.keySet().iterator();
}
// HashMap#KeySet
final class KeySet extends AbstractSet<K> {
    public final Iterator<K> iterator()     { return new KeyIterator(); }
    ...
}
// HashMap#KeyIterator
final class KeyIterator extends HashIteratorimplements Iterator<K> {
    public final K next() { 
        return nextNode().key; 
    }
}
// HashMap#HashIterator
abstract class HashIterator {
    Node<K,V> next;        // next entry to return
    Node<K,V> current;     // current entry
    int expectedModCount;  // for fast-fail
    int index;             // current slot
    
   	...
        
    final Node<K,V> nextNode() {
        Node<K,V>[] t;
        Node<K,V> e = next;
        if (modCount != expectedModCount)
            throw new ConcurrentModificationException();
        if (e == null)
            throw new NoSuchElementException();
        if ((next = (current = e).next) == null && (t = table) != null) {
            do {} while (index < t.length && (next = t[index++]) == null);
        }
        return e;
    }
}
```

##### 增加元素方法

- add（E）：添加元素到集合中，交由成员变量引用HashMap#put（K，V）实现。以元素的值为HashMap.Entry的键，以Object PRESENT = new Object();空对象作为HashMap.Entry的值。

```java
// 添加元素到集合中
public boolean add(E e) {
    return map.put(e, PRESENT)==null;
}
// HashMap#put（K，V）
public V put(K key, V value) {
    return putVal(hash(key), key, value, false, true);
}
```

##### 删除元素方法

- remove（Object）：删除集合中指定的元素，交由成员变量引用HashMap#remove（Object），同一元素的判断条件为：key的hash值相等 或者 Key值equal。

```java
// 删除集合中指定的元素
public boolean remove(Object o) {
    return map.remove(o)==PRESENT;
}
// HashMap#remove（Object）：key的hash值相等 或者 Key值equal
public V remove(Object key) {
    Node<K,V> e;
    return (e = removeNode(hash(key), key, null, false, true)) == null ?
        null : e.value;
}
```

#### LinkedHashSet

![1621519230206](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1621519230206.png)

##### 特点

- Set接口的**哈希表和链表**实现，具有可预测的迭代顺序。 此实现与HashSet的不同之处在于，它维护在其所有条目中运行的双向链接列表。 此链表定义了迭代顺序，即**将元素插入到集合中的顺序（插入顺序）**。 请注意，如果将元素重新插入到集合中，则插入顺序不会受到影响（如在调用之前s.contains（e）将返回true的情况下调用s.add（e），则将元素e重新插入到set s中）。
- 无论原始集的实现如何，都可以使用它来产生与原始集具有相同顺序的集合副本，如Set copy = new LinkedHashSet(Set)。
- 与HashSet一样，提供add，contains和remove基本操作，由哈希表（HashMap实例）支持，由于还维护了一个双向链表，所以性能可能会略低于HashSet。但迭代时间最坏为O（n），而HashSet的为最坏为O（m * n）（m为桶长度，n为桶中链表长度）。
- 非线程安全的，如果要使用同步的Set方法，可以考虑使用Collections＃synchronizedSet进行包装。
- 迭代器是快速失败的。
- **其迭代方法、增加与删除元素方法交由HashSet实现，没有获取和替换元素的方法。**

##### 构造方法

所有构造方法交由父类HashSet#HashSet(int, float, boolean)实现，底层数据结构改用LinkedHashMap存储，多维护了一个双向链表，使得迭代顺序是有序的。

- **无参的构造函数**：使用默认初始化容量16，默认负载因子0.75。
- **指定复制集合的构造函数**：根据集合大小计算初始容量（size / 0.75） 或者为默认值16。
- **指定初始容量的构造函数**：默认负载因子0.75。
- **指定初始容量和负载因子的构造函数**。

```java
public class LinkedHashSet<E> extends HashSet<E> implements Set<E>, Cloneable, java.io.Serializable {
    
    // 无参的构造函数
    public LinkedHashSet() {
        super(16, .75f, true);// true代表HashMap中的Key值使用假值
    }
    
    // 指定复制集合的构造函数
    public LinkedHashSet(Collection<? extends E> c) {
        super(Math.max(2*c.size(), 11), .75f, true);
        addAll(c);
    }

    // 指定初始容量的构造函数
    public LinkedHashSet(int initialCapacity) {
        super(initialCapacity, .75f, true);
    }

    // 指定初始容量和负载因子的构造函数
    public LinkedHashSet(int initialCapacity, float loadFactor) {
        super(initialCapacity, loadFactor, true);
    }
}

public class HashSet<E> extends AbstractSet<E> implements Set<E>, Cloneable, java.io.Serializable
{
    // 指定初始容量和负载因子的构造函数：该构造方法是defalut级别的，供LinkHashSet使用，同时底层数据结构改用LinkedHashMap存储，多维护了一个双向链表，使得迭代顺序是有序的
    HashSet(int initialCapacity, float loadFactor, boolean dummy) {
        // dummy参数留给子类LinkedHashSet使用，注意这里构造的是LinkedHashMap，不是HashMap
        map = new LinkedHashMap<>(initialCapacity, loadFactor);
    }
}
```

#### SynchronizedSet

![1621521638282](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1621521638282.png)

##### 特点

- java.util.Collections内部类

- 继承自SynchronizedCollection类，相当于拥有成员变量Collection引入和mutex对象锁，用于包装传入的集合，使（**其所有方法都能成为同步方法加synchronized关键字**），其元素操作方法与SynchronizedCollection类的一致，也就是**Set集合没有获取和替换元素的方法**。
- 迭代器是否具有快速失败的特性，取决于传入的Set引用的实际类型（**Set集合的都是快速失败的**）。

##### 构造方法

- **只传入Set集合的构造函数**：设置Collection引用，持有父类mutex对象锁。
- **传入Set集合与对象锁的构造函数**：设置Colleciton引用与对象锁引用。

```java
static class SynchronizedSet<E> extends SynchronizedCollection<E> implements Set<E> {
    private static final long serialVersionUID = 487447009682186044L;

    // 只传入Set集合的构造函数
    SynchronizedSet(Set<E> s) {
        super(s);
    }
    
    // 传入Set集合与对象锁的构造函数
    SynchronizedSet(Set<E> s, Object mutex) {
        super(s, mutex);
    }
    
    // 只重写了equals和hashCode方法: 加上synchronized关键字
    ...
}
```

