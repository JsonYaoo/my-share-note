# 一、基础篇

## 1. 网络基础

### 1.1. TCP是什么？

TCP，Transmission Control Protocol，传输控制协议，是一种面向连接的、面向字节流的、可靠的传输层通信协议。

### 1.2. UDP是什么？

UDP，User Datagram Protocol，用户数据报协议，是一种无连接的、面向报文的、不可靠的传输层协议，为应用程序提供一种无需建立连接就可以发送封装好的IP数据包的方法。

### 1.3. TCP与UDP的差别？

|                     | TCP                                          | UDP                                  |
| ------------------- | -------------------------------------------- | ------------------------------------ |
| 是否连接            | 面向连接的                                   | 无连接的                             |
| 传输方式            | 面向字节流的（流入进程或进程流出的字节序列） | 面向报文的（完整的报文）             |
| 连接对象个数        | 只能 一对一、可全双工通信                    | 支持一对一、一对多、多对一和多对多   |
| 是否使用拥塞控制    | **<u>流量控制和拥塞控制</u>***               | 无流量控制和拥塞控制                 |
| 是否可靠            | 可靠的                                       | 不可靠的，尽最大努力交付             |
| **<u>首部开销</u>** | 8个字节                                      | 20~60字节（选项可达40个字节）        |
| 性能                | 传输效率低，所需资源多                       | 传输效率高，所需资源少               |
| 适用场景            | 文件、邮件                                   | 语音、视频、直播                     |
| 应用的协议          | HTTP、FTP、SMTP                              | **<u>RIP</u>**、DNS、**<u>SNMP</u>** |

### 1.4. TCP与UDP应用的协议？



![1620099899187](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620099899187.png)

### 1.5. TCP如何保证数据可靠传输？

> 思路：当出现差错时能让发送方重传出现差错的数据，同时在接收方来不及处理收到的数据时，及时告诉发送方适当降低发送数据的速度。
>
> TCP主要通过确认应答和超时重传机制、检验和、最大报文长度、滑动窗口控制、流量控制以及拥塞控制等方法实现数据的可靠性传输。

#### **1. 确认应答和超时重传机制**

1. 作用：发送方通过对字节流每个字节进行顺序标号发送，接收方需要对接收到的数据中最高需要给出确认（不应超过0.5s），如果在规定的时间内，发送方没有收到确认应答，则需要重传已发送的报文段。
2. 工作原理：

- **序号**：占4个字节，范围[0，2^32  - 1]，使用mod 2^32运算，n序号表示第n字节，共可表示2^40位（4GB）数据。
- **确认号**：占4个字节，表示期望收到对方下一个报文段的第一个数据字节的序号。若确认号=N，则表明到序号N-1为止的所有数据都已正确收到。
- **确认ACK**：占1位，仅当ACK=1时确认号有效，TCP规定，在连接建立后，所有传送的报文都必须把ACK置为1。

#### **2. 检验和**

1. 作用：通过检验和的方式，接收端可以检测出数据是否有差错和异常，假如有差错，报文段就会被直接丢弃，发送方需要重新发送报文段。
2. 工作原理：

- **二进制反码求和运算**：
  - 0+0=0，但要产生进位1
  - 0+1=1，不需要产生进位1
  - 1+1=0，不需要产生进位1
  - 最高位产生进位1，最后结果需要+1
- 发送方：取12位TPC伪首部+TCP首部+TCP报文段数据部分，对其16位字使用**二进制反码求和运算**， 把结果**取反**写入检验和字段。
- 接收方：取12位TPC伪首部+TCP首部（此时检验和已经不是全0了）+TCP报文段数据部分，对其16位字使用**二进制反码求和运算**，当无差错时结果应为全1，否则就表明有差错出现。

![1620126724402](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620126724402.png)

#### **3. 最大报文段长度**

MSS，Maximum Segment Size，是指每一个TCP报文段中数据字段的最大长度 = TCP报文段长度 - TCP首部长度 

1. 作用：在连接建立过程中，双方选项上写入自己能支持的MSS（默认536字节），要保证在IP层传输时不需要再分片，减少网络开销，提高网络利用率。
2. 工作原理：

- MSS较小时，传输时加上TCP首部+IP首部+链路层首部，造成花费大开销实现少量数据传输，网络利用率低下。
- MSS较大时，TCP报文段非常长，在IP层传输被分解成多个短的数据报片，造成在终点时要把收到的各个短数据报片装配成原TCP报文段，而且分片多传输出错的概率大，还需要重传，使得花销增大。

#### **4. 以字节为单位的滑动窗口控制**

1. 作用：在没有收到接收方确认的情况下，发送方可以连续把窗口内的数据都发送出去，凡是已经发送过的数据，在未收到确认之前都必须暂时保留以便在超时重传时使用。这样可以提高超时重传机制下的发送效率和信道利用率。
2. 工作原理：

- 发送窗口里面的序号表示允许发送的序号，后沿后面部分表示已发送且已收到的确认，前沿前面部分表示不允许发送。*后沿变化有两种可能即不动（没有收到新的确认）和前移（收到了新的确认）。前沿通常是不断向前的，但也可能不动（收到通知窗口变小），还有可能向后收缩（不推荐）*。
- 接收窗口后沿部分表示已经发送过确认，已经交付主机了，不需要再保留这些数据，窗口内的需要是允许接收的。

![1620130103782](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620130103782.png)

#### **5. 利用滑动窗口实现的流量控制**

1. 作用：控制发送方速率不要太快，要让接收方来得及接收。*是点对点通信量的控制，是个端对端的问题（接收端控制发送端）。*
2. 工作原理：

- rwnd，receiver window，即通知窗口，发送方的发送窗口不能超过接收方给出的接收窗口数值。
- *持续计时器，persistence timer，收到零窗口通知时开启，时间到期后会发送一个零窗口探测报文段（仅携带1字节的数据），对方在这个探测报文段给出现在窗口值，如果仍然是零，则还会重新设置持续计时器。以解决零窗口互相等待问题。*

![1620130650215](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620130650215.png)

#### 6. 拥塞控制

1. 作用：防止过多的数据注入到网络中，避免网络中的路由器和链路过载。*拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的因素。*
2. 工作原理：

- cwnd，congestion window，拥塞窗口，发送方维持的一个状态变量，大小取决于网络的拥塞程度，并且动态变化。**发送方窗口上限值 = Min[rwnd，cwnd]**
- SMSS，Sender Maximum Segment Size，最大报文段。
- 慢开始门限，ssthresh，cwnd < ssthresh => 慢开始算法，cwnd > ssthresh时 => 拥塞避免算法。
- 慢开始，slow-start，先发送小字节探测一下（2~4个SMSS），由小到大逐渐增大拥塞窗口。在每收到一个对新的报文段的确认后，就可以把拥塞窗口增多一个SMSS数值（△cwnd = min[N，SMSS]，N指原先未被确认的、但现在刚刚收到确认的字节数）。
- 拥塞避免，congestion avoidance，cwnd缓慢增大，每经过1个往返时间RTT只把cwnd+1，不像慢开始阶段那样指数规律增长，而是按线性规律增长增长。如果网络出现了超时，发送方判断为网络拥塞，需要调整ssthresh为原来的一半，同时cwnd设置为1，重新进入慢开始阶段。
- 快重传，fast retransmit，接收方没收到某报文段时，需要立即返回3个缺失报文段的重复确认给发送方。发送方只要一收到3个重复确认（3 - ACK），则认为接收方确实没有收到该报文段，则进行重传，而不会误认为是网络拥塞。
- 快恢复，fast recovery，发送方知道只是丢失个别报文段后，不启动慢开始而是执行快恢复算法，调整ssthresh为cwnd/2，同时设置cwnd=ssthresh，并执行拥塞避免算法。

![1620132158175](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620132158175.png)

### 1.6. TCP三次握手？

*服务端TCP进程先创建传输控制块TCB（TCP连接表、指向发送和接收缓存的指针、指向重传队列的指针、当前发送和接收序号等），处于LISTEN（收听）状态，等待客户端的连接请求。*

*客户端TCP进程创建传输控制块，打算建立TCP连接，向服务端发起连接请求报文段。*

- TCP规定，SYN报文段不能携带数据，但要消耗一个序号。
- TCP规定，ACK报文段可以携带数据，如果不携带数据则不用消耗序号。

1. 一次握手：客户端发送SYN=1，seq=x的请求报文段，随后客户端进入SYN-SENT（同步已发送）状态。
2. 二次握手：服务端返回ACK=1，ack=x+1，SYN=1，seq=y的确认报文段，随后服务器进入SYN-RECD（同步收到）状态。
3. 三次握手：客户端返回ACK=1，ack=y+1，seq=x+1的确认报文段，此时TCP连接已建立，客户端进入ESTABLISHED（已建立连接）状态。

*当服务端收到客户端的确认报文段后，也进入ESTABLISHED（已建立连接）状态。*

![1620138485517](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620138485517.png)

### 1.7. 为什么TCP需要三次握手，两次行吗？

- 三次握手的原因：主要是为了建立可靠的全双工通信信道，保证客户端与服务端同时具备发送与接收数据的能力。
- 两次握手不行的原因：

1. **两次握手只能保证单向连接是通畅的**。根据TCP确认应答和超时重传机制，通信双方必须维护一个序列号，发送方根据序列号标识哪些报文段是已经发送出去的，接收方也要根据序列号应答哪些报文段是已经确认的。**而三次握手的过程就是双方互相告知起始序列号的过程**，即客户端标记服务端确认，服务端标记客户端确认。如果只是两次握手，那么至多只有客户端的起始序列号得以确认，而另一方的序列号得不到确认，即只能确保单向连接是顺畅的。
2. **第三次握手可以防止已失效的连接请求报文段突然又传送到服务端，建立了多余的连接，造成资源的浪费。**

### 1.8. TCP四次挥手？

*客户端TCP进程先发起TCP释放报文段，并停止发送数据，主动关闭TCP连接。*

- TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
- TCP规定，ACK报文段可以携带数据，如果不携带数据则不用消耗序号。
- MSL，Maximum Segment LifeTime，最长报文段寿命，建议设置为2分钟。

1. 一次挥手：客户端发起FIN=1，seq=u的连接释放报文段，随后进入FIN-WAIT-1（终止等待1）状态，等待服务端确认。
2. 二次挥手：服务端返回ACK=1，ack=u+1，seq=v的确认报文段，随后进入CLOSE-WAIT（关闭等待）状态，此时客户端到服务端方向的连接已释放，TCP连接处于HALF-CLOSE（半关闭）状态。接着，客户端收到确认报文段后，进入FIN-WAIT-2（终止等待2）状态，等待服务端发出连接释放报文段。
3. 三次挥手：服务端TCP进程发起ACK=1，ack=u+1，FIN=1，seq=w的连接释放报文段，随后进入              LAST-ACK（最后确认）状态，等待客户端的确认。
4. 四次挥手：客户端返回ACK=1，ack=w+1，seq=u+1的确认报文段，随后进入TIME-WAIT（时间等待）状态，服务端接收到确认报文段后，进入CLOSE（关闭）状态。此时TCP连接还没有释放掉，必须经过时间等待计时器（TIME-WAIT timer）设置的2MSL时间后，客户端才进入CLOSED（关闭）状态。

![1620141320603](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620141320603.png)

### 1.9. 为什么TCP需要四次挥手？

- 四次挥手的原因：因为需要确保客户端与服务端的数据能够完成传输。前两次挥手后，关闭客户端到服务端方向的连接，服务端通知上层应用程序做好最后的准备，进入CLOSE-WAIT（等待关闭）状态。第三次挥手由服务端TCP进程发起连接释放报文段，根据TCP确认应答和超时重传机制，客户端必须返回确认报文段，所以产生第四次挥手。

### 2.0. 为什么TCP客户端需要等待2MSL才进入关闭状态？

- MSL，Maximum Segment LifeTime，最长报文段寿命，建议设置为2分钟。

1. **为了保证客户端发送的最后一个确认报文段能够达到服务器。**如果上一个确认报文丢失，设置2MSL能够在这个时间内，客户端再次收到服务端的FIN+ACK连接释放报文段，保证服务端释放TCP连接。
2. **还为了防止已失效的连接请求报文段突然又传送到服务端，建立了多余的连接，造成资源的浪费。**设置2MSL，可以使本次TCP连接持续的时间内所产生的报文段在网络中消失，确保下一个新的连接不会出现这种旧的连接请求报文段。

### 2.1. 如何查看TIME-WAIT状态的连接数量？

netstat -an | grep TIME_WAIT | wc -l

### 2.2. 为什么会TIME-WAIT过多？如何解决？

- 可能原因：在**高并发短连接**的TCP服务器上，当服务器处理完请求后立刻主动正常关闭连接时，会出现大量socket处于TIME-WAIT状态。此时如果客户端的并发量持续很高，那么部分客户端就可能显示连接不上。
- 解决：

1. vim /etc/sysctl.conf，打开系统的TIME-WAIT重用和快速回收。

```shell
# 表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭；
net.ipv4.tcp_tw_reuse = 1
# 表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。
net.ipv4.tcp_tw_recycle = 1
```

2. /sbin/sysctl -p，使参数生效。

### 2.3. TCP报文段格式？

![1620179962619](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620179962619.png)

> TCP报文首部占用20~60字节。

- **源端口和目的端口**：各占2个字节，分别写入源端口号和目的端口号，实现TCP分功能。两个值分别加上IP首部的源端IP地址和目的端IP地址，可以唯一确定一个TCP连接。
- **序号**：占4个字节，范围[0，2^32  - 1]，使用mod 2^32运算，n序号表示第n字节，共可表示2^40位（4GB）数据。
- **确认号**：占4个字节，表示期望收到对方下一个报文段的第一个数据字节的序号。若确认号=N，则表明到序号N-1为止的所有数据都已正确收到。
- **数据偏移**：占4位，指TCP报文段的数据起始处，距离TCP报文段的起始处有多远即TCP报文段的**首部长度**。单位是32位字（4个字节），而4位二进制最大表示15，意味着**TCP首部长度最大长度为60字节**（即选项长度不能超过40字节）。
- **保留**：占6位，保留为今后使用，目前应置为0。
- **标志字段**：各占1位，共6位
  - **紧急URG**：URGent，当URG=1时，表名**紧急指针**有效，需要与**紧急指针**配合使用。URG告诉系统，此报文段中有紧急数据，应尽快传送（相当于高优先级的数据），而不要按原来的排队顺序来传送。
  - **确认ACK**：ACKnowledgment，仅当ACK=1时确认号有效，TCP规定，在连接建立后，所有传送的报文都必须把ACK置为1。
  - **推送PSH**：PuSH，发送方TCP把PSH置为1，则应该立即创建一个报文段发送出去。接收方TCP收到PSH=1的报文段，则应该尽快地交付接收应用进程，而不再等到整个缓存都填满了后再向上交付。
  - **复位RST**：ReSeT，当RST=1时，表明TCP连接出现严重差错，必须释放连接再重新建立连接。
  - **同步SYN**：SYNchronization，在连接建立时用来同步序号。SYN=1，表示这是一个连接请求或连接接受报文。
  - **终止FIN**：FINish，用来释放一个连接。当FIN=1时，表明此报文段发送方的数据已发送完毕，并要求释放连接。
- **窗口**：占2个字节，[0, 2^16 - 1]，指的是发送本报文段的一方的接收窗口，指明从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量（以字节为单位）。窗口值作为接收方让发送方设置其发送窗口的依据，经常动态变化着。
- **检验和**：占2个字节，通过检验和的方式，接收端可以检测出数据是否有差错和异常，假如有差错，报文段就会被直接丢弃，发送方需要重新发送报文段。
  - **二进制反码求和运算**：
    - 0+0=0，但要产生进位1
    - 0+1=1，不需要产生进位1
    - 1+1=0，不需要产生进位1
    - 最高位产生进位1，最后结果需要+1
  - 发送方：取12位TPC伪首部+TCP首部+TCP报文段数据部分，对其16位字使用**二进制反码求和运算**， 把结果**取反**写入检验和字段。
  - 接收方：取12位TPC伪首部+TCP首部（此时检验和已经不是全0了）+TCP报文段数据部分，对其16位字使用**二进制反码求和运算**，当无差错时结果应为全1，否则就表明有差错出现。

![1620126724402](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620126724402.png)

- **紧急指针**：占2个字节，紧急指针仅在**URG=1**时才有意义，指出本报文段中紧急数据的字节数（序号值+字节数=偏移量），即指出了紧急数据的末尾在报文段中的位置。窗口为零时也可发送紧急数据。
- **选项**：长度可变，最大可达40字节。常见的有**最大报文段长度MSS**、**窗口扩大选项**、**时间戳选项**、**选择确认选项**等。

### 2.4. UDP用户数据报格式？

![1620182389880](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620182389880.png)

> UDP报文首部占8个字节。

- **源端口**：占2字节，源端口号，在需要对方回信时选用，否则全0。

- **目的端口**：占2个字节，目的端口号，在终点交付报文时必须使用。

- **长度**：占2个字节，UDP用户数据报的长度，最小值是8（仅有首部时），最大表示2^16 - 1=65535个字节。

- **检验和**：占2个字节，通过检验和的方式，接收端可以检测出数据是否有差错和异常，假如有差错，报文段就会被直接丢弃，发送方需要重新发送报文段。

  - **二进制反码求和运算**：
    - 0+0=0，但要产生进位1
    - 0+1=1，不需要产生进位1
    - 1+1=0，不需要产生进位1
    - 最高位产生进位1，最后结果需要+1
  - 发送方：取12位UDP伪首部+UDP首部+UDP用户数据报的数据部分，对其16位字使用**二进制反码求和运算**， 把结果**取反**写入检验和字段。
  - 接收方：取12位UDP伪首部+UDP首部（此时检验和已经不是全0了）+UDP用户数据报的数据部分，对其16位字使用**二进制反码求和运算**，当无差错时结果应为全1，否则就表明有差错出现。

  ![1620182690813](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620182690813.png)

### 2.5. IP数据报格式？

![1620185300666](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620185300666.png)

> IP报文首部占20~60字节。

- **版本**：占4位，指IP协议的版本。通信双方使用的IP协议版本必须一致。IPv4的版本号为4，IPv6的版本号为6。
- **首部长度**：占4位，IP分组的首部长度，单位是32位字（4个字节），最小值是5，而4位二进制最大表示15，意味着**IP分组首部长度最大长度为60字节**（即选项字段不能超过40字节）。IP分组的首部长度如果不是4字节的整数倍时，必须利用最后的填充字段加以补充。
- **区分服务**：DS，Differentiated Services，也叫服务类型。占8位，用来获得更好的服务：*最小时延、最大吞吐量、最高可靠性、最小费用*。一般情况下都不使用这个字段。
- **总长度**：占16位，[0, 2^16 - 1]，指**首部和数据之和的长度**，最大长度为65535个字节。若所传送的数据报长度超过**数据链路层MTU（最大传送单元，默认1500字节）**，就必须把过长的数据报进行分片处理，分片该字段的值也会发生改变，即此时指**分片后的每一个分片的首部长度与该分片的数据长度的总和**。*IP协议规定，在互联网中所有的主机和路由器，必须能够接受长度不超过576字节的数据报，MSS+TCP固定首部+IP固定首部=536+20+20=576字节。*
- **标识**：identification，占16位，IP软件在存储器中维持了一个计数器，每产生一个数据报计数器就+1，并将此值赋给标识字段。**相同的标识字段的值可以使分片后的各数据报片重装为原来的数据报**。
- **标志**：flag，占3位，目前只有两位有意义。
  - **最低位MF**：More Fragment，MF=1表示后面还有分片的数据报，MF=0表示这个已经是若干数据报片中的最后一个了。
  - **中间位DF**：Don't Fragment，DF=1表示不能分片，DF=0表示允许分片。
- **片偏移**：占13位，指较长的分组经过分片后，某片在原分组中的相对位置，以8个字节为偏移单位，即原偏移1400字节，偏移量=1400/8=175。
- **生存时间**：TTL，Time to Live，占8位，指数据报在网络中的寿命。现表示跳数限制，单位是**跳数**，指路由器每次转发数据报之前需要把TTL值-1，若TTL值减小到零，就丢弃这个数据报不再转发。即**TTL表明数据报在互联网中至少可经过多少个路由器**，最大值为255。
- **协议**：占8位，协议字段指出此数据报携带的数据使用何种协议，以便使目的主机IP层知道应该将数据部分上交给哪个协议进行处理。TCP为6，UDP为17。
- **首部检验和**：占16位，通过检验和的方式，接收端可以检测出数据是否有差错和异常，假如有差错，报文段就会被直接丢弃，发送方需要重新发送报文段。**只检验数据报的首部部分，不检验数据部分。**ICMP、IGMP、UDP、TCP均同时检验首部部分和数据部分。
  - **二进制反码求和运算**：
    - 0+0=0，但要产生进位1
    - 0+1=1，不需要产生进位1
    - 1+1=0，不需要产生进位1
    - 最高位产生进位1，最后结果需要+1
  - 发送方对首部部分16位字使用**二进制反码求和运算**， 把结果**取反**写入首部检验和字段。
  - 接收方对首部部分16位字使用**二进制反码求和运算**（此时首部检验和已经不是全0了），当无差错时结果取反应为全0，否则就表明有差错出现。
- **源地址**：占32位。
- **目的地址**：占32位。
- **可选字段**：最大占40个字节，用来支持排错、测量以及安全检测等措施。必要时需要用全0的填充字段来补齐成为4字节的整数倍。实际上很少被使用。

### 2.6. 以太网MAC帧格式？

![1620190340385](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620190340385.png)

> 常用的以太网MAC帧格式有两种标准，一种是DIX Ethernet V2标准（即以太网V2标准），另一种是IEEE的802.3标准，现在市场上流行的都是以太网V2的MAC帧，但大家也常常把它称为IEEE 802.3标准的MAC帧。

MAC帧首部固定长度18个字节，有效MAC帧长度=首部长度+数据长度=64~1518字节。

- **目的地址**：6个字节，是指网卡的硬件地址（MAC地址），占48位，在网卡出厂时固化。
- **源地址**：6个字节，是指网卡的硬件地址（MAC地址），占48位，在网卡出厂时固化。
- **类型字段**：2个字节，用来标志上一层使用的是什么协议，以便把收到的MAC帧的数据上交给上一层的协议。*如值为0x0800，就表示上层的是IP数据报。*
- **数据字段**：长度在46~1500字节，46=64-18，1500=**以太网最大传输单元MTU**。当数据字段的长度小于46字节时，MAC子层会在数据字段后面加入一个整数字节的填充字段，以**保证以太网MAC帧不小于64字节**。上层协议具有识别有效的数据长度长度的功能，比如IP层就可以把填充的字节丢弃掉。
- **帧检验序列FCS**：使用CRC检验。

从MAC子层向下传到物理层时，还要在帧的前面插入8个字节（由硬件生成）

- 前7个字节是**前同步码**（1和0交替码），作用是使接收端的适配器在接收MAC帧时能够迅速调整其时钟频率，使它和发送端的时钟同步，也就是实现位同步（比特同步）。
- 最后一个字节是**帧开始界定符**，定义为10101011，最后两个连续的1表示MAC帧马上要开始了。

> 在以太网上传送数据时是以**帧**为单位传送的，各帧之间还必须有一定的间隙。
>
> 由于存在**帧开始界定符**，所以以外网不需要使用帧结束定界符，也不需要使用字节插入来保证透明传输。
>
> **以太网不负责重传丢弃的帧。**

### 2.7. 子网掩码的作用？

为了能够从IP数据报的首部看出源主机或目的主机所连接的网络是否进行了子网划分。

### 2.8. OSI与TCP/IP模型？

![1620196369515](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620196369515.png)

> OSI七层体系协议结构概念请求、理论完整，但既复杂又不使用。
>
> TCP/IP四层体系结构使用更为广泛。
>
> 五层协议体系结构总和了OSI和TCP/IP的优点，为介绍网络原理而设计出来的。

- OSI七层模型：物理层、数据链路层、网络层、运输层、会话层、表示层、应用层
- TCP/IP四层模型：网络接口层、网际层、运输层、应用层
- 五层协议模型：物理层、数据链路层、网络层、运输层、应用层
  - **物理层**：physical layer，以**比特**为单位，负责在发送双方**传送1和0**。
  - **数据链路层**：data link layer，以**帧**为单位，负责在两个相邻结点之间的链路上**传送帧**，包括控制信息（如同步信息、地址信息、差错控制等）。
  - **网络层**：network layer，以**IP数据报**为单位，负责为在分组交换网上的不同主机提供**通信服务**。在发送数据时，把运输层产生的报文或用户数据报封装成IP数据报进行传送。
  - **运输层**：transport layer，TCP以**报文段**为单位，UDP以**用户数据报**为单位，负责向两台主机中进程之间的通信提供**通用的数据传输服务**。
  - **应用层**：application layer，以**报文**为单位，负责通过应用进程之间的交互来完成**特定网络应用**。

### 2.9 常见的网络服务分层示例

| 分层       | 示例                                |
| ---------- | ----------------------------------- |
| 物理层     | 中继器、集线器                      |
| 数据链路层 | 网卡、网桥、交换机                  |
| 网络层     | 路由器、防火墙、ARP、IP、ICMP、IGMP |
| 运输层     | TCP、UDP                            |
| 应用层     | HTTP、SMTP、DNS、FTP                |

- **ARP**：Address Resolution Protocol，地址解析协议，从网络层使用的IP地址，解析出在数据链路层使用的硬件地址。
- **ICMP**：Internet Control Message Protocol，网际控制报文协议，允许主机或路由器报告差错情况和提供有关异常情况的报告，可以更有效地转发IP数据报，提高交付成功的机会。
- **IGMP**：Internet Group Management Protocol，网际组管理协议，让连接在本地局域网上的多播路由器**知道**本局域网上是否有主机（即主机中的某个进程）参加或退出了某个多播组。

### 3.0. TCP拆包、粘包？原因？解决方法？

- **TCP拆包**：

  - **概念**：如果要发送的数据包过大，就会被拆分成多个TCP报文分开传输，即**一个完整的包可能会被TCP拆分成多个包进行发送**。
  - **直接原因**：
    - 应用程序写入的数据大于套接字缓冲区的大小。
    - TCP报文段的数据部分长度大于MSS(536字节)，导致在IP层传输被分解成多个短的数据报片。
  - **根本原因**：网络层所收到上层交付的数据报长度，超过**数据链路层MTU（最大传送单元，默认1500字节）**，需要把过长的数据报进行IP分片处理。

- **TCP粘包**：

  - **概念**：**多个小的包可能会被TCP封装成一个大的数据包发送**。
  - **直接原因**：
    - 应用程序写入的数据小于套接字缓冲区的大小
    - 接收方不及时读取套接字缓冲区数据
  - **根本原因**：
    - **发送方原因**：TCP默认使用**Nagle算法**（通过减少必须发送包的个数，来增加网络软件系统的效率），即TCP会收集多个小分组，在一个确认到来时才一起发送，导致可能在发送方出现粘包问题。
    - **接收方原因**：TCP将接收到的数据包保存在接收缓存里，如果TCP接收数据包到缓存的速度，大于应用程序从缓存中读取数据包的数据，那么多个包就会被缓存起来，而应用程序就有可能读取到多个首尾相连粘在一起的包。
    - **TCP原因**：TCP是**面向字节流**的协议，报文格式不像UDP那样有专门的长度字段来记录实际报文的长度，交付上层的数据没有边界，导致粘包的发生。

- **解决方法**：

  最本质的原因在于**接收方无法分辨消息与消息之间的边界在哪**，因此，思路就是，通过某种方案给出边界。

  - **消息定长，空格补位**：每个消息的大小都一样，接收方只要累计接收数据，直到数据等到一个定长的指就将它作为一个消息。
  - **包尾加特殊字符作为边界**：比如FTP协议就是在包尾加上\r\n标记作为边界的。但问题在于通信双方要约定在数据正文中，不出现该特殊字符，否则会误判为消息的边界。
  - **包首部记录包体长度**：每个包首部至少包含数据包的长度，这样接收方可以通过读取包首部的长度字段，就知道每一个包的实际长度。

### 3.1. HTTP是什么？

HTTP，hypertext Transfer Protocol，超长文本传输协议，是一个**通常运行在TCP之上的**应用层协议，定义了浏览器怎么向万维网服务器请求万维网文档以及服务器怎么把文档传送给浏览器。

- **事务**：指一系列的信息交换是一个不可分割的整体，即要么所有的信息交换都完成，要么一次交换都不进行。
- **无连接**：指通信双方在交换HTTP报文之前不需要先建立HTTP连接。
- **无状态**：指同一个客户第二次访问同一个服务器上的页面时，服务器的响应与第一次访问时的相同（假设不会更新）。

### 3.2. HTTP协议/1.0/1.1/2.0？

- **HTTP/1.0**：
  - **概述**：每一个请求建立一个TCP连接，请求完成后立马断开连接（**短连接**）。
  - **缺点**：
    - **连接无法复用**，每次请求都要经历三次握手和慢启动，导致在并发量大的情况下服务器的压力负担大，以及带宽无法被充分利用。
- **HTTP/1.1**：
  - **概述：**多个http请求可以复用一个TCP连接，使用Connection Header（close/keep-alive）来区分**短/长连接**。服务器按照FIFO原则来处理不同请求。
  - **缺点**：在同一时间，针对同一域名下的请求有一定的限制，超过限制数目的请求会被阻塞。
- **HTTP/2.0**：
  - **概述**：**多路复用**（二进制帧的设计）允许同时通过单一的连接发起多重的请求-响应信息，可以很容易地去实现并行地在同一个TCP连接上双向交换信息，而不用依赖建立多个TCP连接。
  - **缺点**：普及速度慢，与HTTP1.1并存。

### 3.3. HTTP/1.0/1.1的主要区别？

1. **长连接**：减少了建立和关闭连接的消耗和延迟。
2. **Host头处理**：支持Host头域，不在以IP为请求方标志，解决一台物理机存在多个虚拟主机，共享IP地址的问题。
3. **错误状态码增多**：1.1新增了24个错误状态响应码，更加明确各个状态，如409（表示请求的资源与资源当前状态发生冲突）、410（表示服务器某个资源被永久性的删除）。
4. **网络连接的优化**：1.1支持断点续传，在请求头引入range头域（允许只请求资源的某个部分，返回码206），方便充分利用带宽和连接。
5. **提供更多的缓存控制策略**：

| 缓存控制头          | 解释                                                         | 备注     |
| ------------------- | ------------------------------------------------------------ | -------- |
| If-Modified-Since   | 允许在对应的资源未被修改的情况下，返回304未修改              | 1.0、1.1 |
| Expires             | 指定一个日期/时间，超过该时间则认为此响应已过期              | 1.0、1.1 |
| ETag                | Entity tag，对于某个资源的某个特定版本的一个表示符，通常是一个消息三列 | 1.1新增  |
| If-Unmodified-Since | 仅当该实体某个特定时间以来未被修改的情况下，才发送响应。     | 1.1新增  |
| If-Match            | 仅当客户端提供的实体与服务器对应的实体相匹配时，才进行对应的操作。主要用于PUT这样的方法中，仅当从用户上次更新某个资源后，该资源未被修改的情况下，才更新该资源。 | 1.1新增  |
| If-None-Match       | 允许在对应的内容未被修改的情况下，返回304未修改              | 1.1新增  |

### 3.4 HTTP/1.1/2.0的主要区别？

1. **多路复用**：2.0连接共享，不同的Request可以使用同一个连接传输，最后根据每个Request id组合成正常的请求。
2. **新的传输格式**：2.0使用二进制格式（基于二进制帧的设计），1.0依然使用基于文本的格式（基于文本分割解析）。
3. **Header压缩**：由于1.X中Header带有大量的信息，并且得重复传输，2.0使用Encoder来减少需要传输的Header大小。
4. **服务端推送**：2.0中，服务器可以对客户端的一个请求发送多个响应。

### 3.5. HTTPS连接的建立过程？

> HTTPS，Hyper Text  Transfer Protocol over SecureSocket Layer，是以安全为目标的HTTP通道，在HTTP的基础上通过传输加密和身份认证保证传输过程的安全性。

- HTTPS在内容传输的加密上使用的是**对称加密**（速度快），在证书验证阶段使用**非对称加密**（安全性高）。
- **对称加密**：双方持有**相同的密钥**，加密速度快。典型的对称加密算法有：DES、AES**。**
- **非对称加密**：**密钥成对出现（私钥和公钥）**。私钥只有自己知道，不在网络中传输。公钥可以公开，A使用B公钥加密后，B使用B的私钥解密。加密速度慢。典型的非对称加密算法有：RSA、DSA。

1. **发起请求**：首先客户端将它所支持的算法列表和一个用作产生密钥的**随机数1**发送给服务器。
2. **返回证书**：服务器从算法列表中选择一种算法，并将它和一份包含**服务器公钥**的证书以及**随机数2**返回给客户端，包含用于认证目的的服务器标识。
3. **证书验证**：客户端对服务器的证书进行验证（**数字签名**），抽取**服务器公钥**，再产生一个**预主密钥（pre_master_secret）**的随机密码串 + **服务器公钥**，使用非对称加密，将**加密后的信息**发送给服务器。此时，客户端使用**随机数1、随机数2、预主密钥**，独立计算出**加密和MAC密钥**，作为接下来的**会话密钥**。
4. **服务器解密**：服务器通过**服务器私钥**对传送过来的加密信息进行解密，得到**预主密钥**，与**随机数1、随机数2**独立计算出**加密和MAC密钥**，作为接下来的**会话密钥**。
5. **客户端发起测试**：客户端将握手消息经过**会话密钥**使用对称加密得到的MAC值发送给服务端，验证服务器能否正常接受客户端加密的消息。
6. **服务器响应测试**：服务器将握手消息经过**会话密钥**使用对称加密得到的MAC值返回给客户端，如果客户端能够接受并返回确认报文的MAC值，则SSL层建立完成。

### 3.6. HTTP与HTTPS的区别？

| HTTP                           | HTTPS                                     |
| ------------------------------ | ----------------------------------------- |
| 默认端口80                     | 默认端口443                               |
| URL以http://开头               | URL以https://开头                         |
| 明文传输、数据未加密、安全性差 | 传输过程SSL加密、安全性好、需要用到CA证书 |
| 消耗资源少、响应速度快         | 消耗资源多、响应速度慢                    |

### 3.7. HTTP请求报文有哪些方法？

| 方法    | 描述                                                     |
| ------- | -------------------------------------------------------- |
| GET     | 向特定资源发送请求，查询数据并返回实体                   |
| POST    | 向服务器添加信息，可能会导致新的资源建立或已有资源的修改 |
| PUT     | 向服务器上传新的内容                                     |
| HEAD    | 类似于GET请求，返回的响应中没有具体的内容，用于获取报头  |
| DELETE  | 请求服务器删除特定的资源                                 |
| OPTIONS | 可以用来向服务器发送请求，来测试服务器的功能特性         |
| TRACE   | 回显服务器收到的请求，用于测试或者诊断                   |
| CONNECT | 用于代理服务器                                           |

### **3.8. Get和Post请求区别**？

|          | GET                                                          | POST                                                         |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 可见性   | 数据在URL中，所有人可见                                      | 数据不会显示在URL中                                          |
| 安全性   | 发送的数据是URL的一部分，安全性较差                          | 参数不会被保存在浏览器历史或者web服务器日志中，安全性较好    |
| 数据长度 | 受限制，最大2KB=2^10字节                                     | 无限制                                                       |
| 编码类型 | application/x-www-form-urlencoded                            | multipart/form-data                                          |
| 缓存     | 能被缓存，会保存在浏览器的浏览记录中，URL能够被作作为书签保存 | 不能被缓存                                                   |
| 意义     | 用于向特定资源发送请求，查询数据并返回实体                   | 用于向服务器添加信息，可能会导致新的资源建立或已有资源的修改 |

### 3.9. HTTP常见响应状态码？

> 1xx表示通知信息，如请求收到了或者正在进行处理。
>
> 2xx表示成功，如已接受或已知道。
>
> 3xx表示重定向，如要完成请求还必须采取进一步的行动。
>
> 4xx表示客户的差错，如请求中有错误的语法或者不能完车。
>
> 5xx表示服务器的差错，如服务器失效无法完成请求。

- 100：Continue，继续，客户端应继续请求。
- 200：OK，请求成功，一般用于GET和POST请求。
- 301：Move Permanently，资源永久重定向。
- 302：Found，资源暂时重定向。
- 400：Bad Request，客户端请求的语法错误，服务器无法理解。
- 403：Forbidden，服务器理解客户端的请求，但是拒绝执行此请求。
- 404：Not Found，服务器无法根据客户端的请求找到资源。
- 500：Internal Sever Error，服务器内容错误，无法完成请求。
- 502：Bad Gateway，作为**网关或者代理服务器**尝试执行请求时，从远程服务器中接收到了无效的响应。

### 4.0. 重定向与转发的区别？

|            | 重定向（Redirect）                                     | 转发（Forward）                                   |
| ---------- | ------------------------------------------------------ | ------------------------------------------------- |
| 地址栏路径 | 发生变化                                               | 不变                                              |
| 其他站点   | 可以访问其他站点（服务器）的资源                       | 只能访问当前服务器下的资源                        |
| 请求的次数 | 是两次请求，不能使用Request域对象来共享数据            | 是同一次请求，共享同一个Request域对象             |
| 效率       | 速度慢                                                 | 速度快                                            |
| 执行主体   | web容器，在同一个web容器中转发，对于客户端来说是透明的 | 客户端，服务器返回302状态码，客户端执行重定向操作 |

### 4.1. Cookie与Session的区别？

|          | Cookie                                                       | Session                                                      |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 共同点   | 用来跟踪浏览器用户身份                                       | 用来跟踪浏览器用户身份                                       |
| 位置     | 保存在客户端（浏览器）                                       | 保存在服务端                                                 |
| 安全性   | 不是很安全，可以分析本地的Cookie进行欺骗                     | 较安全                                                       |
| 作用     | 一般用来保存信息                                             | 记录用户的状态                                               |
| 产生机制 | 服务器通过设置响应头提示浏览器生成或者直接使用客户端脚本产生，然后请求时可以发送给服务器 | 客户端请求时，一般服务器会创建JSessionId标识，存放session值到散列表中 |

### 4.2. 在浏览器输入URL再回车确认后发生了什么？

URL判断、DNS查询、TCP连接、浏览器发起HTTP请求、服务器处理并响应HTTP请求、浏览器渲染页面

| 过程              | 过程                                                         | 使用的协议 |
| ----------------- | ------------------------------------------------------------ | ---------- |
| 1、URL判断        | 浏览器判断URL是否合法                                        | 无         |
| 2、DNS查询        | 浏览器查找DNS得到域名对应的IP地址，查找过程：浏览器缓存 -> 操作系统缓存 -> 路由器缓存 -> DNS缓存 -> 域名服务器 | DNS        |
| 3、TCP连接        | 根据IP地址与端口建立TCP连接                                  | TCP        |
| 4、HTTP请求       | 浏览器向服务器发送HTTP请求                                   | HTTP       |
| 5、响应HTTP请求   | 服务器处理并响应HTTP请求                                     | HTTP       |
| 6、浏览器渲染页面 | 浏览器接收HTTP响应并渲染页面                                 | 无         |

### 4.3. HTTP请求与响应报文格式？

![1620215152917](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620215152917.png)

- **开始行**：用于区分是请求报文还是响应报文。在请求报文中的开始行叫做**请求行**，在响应报文中的开始行叫**状态行**。开始行的**三个字段都以空格隔开**，最后的“CR”与"LF”分别代表"回车"和“换行”。
  - 请求报文：方法、URL、版本
  - 响应报文：版本、状态码、短语
- **首部行**：用来说明浏览器、服务器或者主体的一些信息，可以有好几行，也可以不用。每一个首部行都以CRLF结尾。在整个首部行结束时，**还有一空行将首部行和实体主体分开**。
- **实体主体**：请求包体或者响应包体。

## 2. 加解密基础

### 1.1. 常见签名与加密相关用语？

#### 1. 转义

转义字符能使其开头的序列具有不同于普通字符数列的语义。常见作用有：

- 如果不进行转义就可能与语法规定的某些**内容产生混淆**，所以某些内容需要转义。如Java的转义字符"\\"，用来区分字符串中，哪些是分割符，哪些是字符本身。
- 字符引用，用于转义键盘录入的字符，如字符串中的回车符和换行符，使其不可见，从而更容易表达其他内容。

#### 2. 编码解码

编码是采用一种新的载体来表示前一个载体所表达的信息，本质上是信息形式的转换，并没有保密的作用（因为编解码算法是公开的），目的是将信息转换成统一的格式，方便在不同系统中传输。

eg：信息 -> 编码 -> 二进制 -> 解码 -> 信息

*如果解码之后无法正确还原原来所表达的信息，此时就出现了**乱码**。通常是因为选用的解码和编码方式不同所导致的。*

常见编码类型有：

- **文本文件编码**：
  - 作用：将文本内容编码为**二进制数据**，以实现二进制数据进行存储或者传输的目的。
  - 相关技术：ASCII（1字节）、ISO8859-1、GBK（汉字2字节）、GBK2312、UTF-8（汉字0到4字节）、UTF-16、UTF-32等。
- **可打印字符编码**：
  - 作用：将二进制数据编码为**可打印的字符**，以实现通过可打印字符的形式进行存储或者传输的目的。
  - 场景：Web场景（图片）、公钥证书、电子邮件附件等（因为ASCII码128~255字符不可见，不方便路由传输）。
  - 相关技术：HEX、Base64等。
    - HEX：16进制字符，只有字母A~F，4位一组。
    - Base64：a-zA-Z0-9+=，64个字符，6位一组，再对照ASCII码表。

![1620302838656](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620302838656.png)

```java
        // 1、编码技术: 很多消息摘要、加解密算法都是针对二进制的
        try {
            // Base64编码: Q0FG => 6位一组, 3 * 8 = 4 * 6, 压缩率比HEX高, 可能会出现+、=符号
            String base64Str = Base64.getEncoder().encodeToString("CAF".getBytes("ASCII"));
            System.err.println(base64Str);

            // Base64解码: CAF
            String base64Org = new String(Base64.getDecoder().decode(base64Str), "ASCII");
            System.err.println(base64Org);
        } catch (UnsupportedEncodingException e) {
            // do nothing
        }
```

- **URL编码**：
  - 作用：通过使用安全的字符去表示不安全字符从而达到适合传输的目的。
  - 场景：作为URL参数时：中文、空格、&、？、=

#### 3. 消息摘要

- 作用：为了校验**信息的完整性**，保证信息在传输过程中不被篡改。
- 场景：校验密码是否正确、校验下载文件是否完整无损。
- 相关技术：MD5（32字符16字节定长）、SHA、SHA256等。
- 特点：无法逆推、（优秀的Hash算法）结果定长、碰撞率低、相同输入相同输出、不同输入输出千差万别。
- 缺点：简单的摘要可通过穷举、撞库的方式得到原文，因此需要加盐增加算法的安全度。

```java
        // 2、消息摘要: 16字节, MD5、SHA, 哈希的算法, 单向的不能逆推, 优秀的哈希产生的结果是定长的, 碰撞率比较低, 少量Hash就千差万别
        // 作用: 用于验证原消息是否有改变、不同输入不同输出、相同输入相同输出、在数字签名中可以用来证明消息没被别人篡改过
        String input = "hello world";

        // MD5国内一般都使用HEX格式编码, 但事实上Base64也可
        System.err.println(MD5(input));// HEX是一个字符占4位, 16个字节, 共32个字符 => 5EB63BBBE01EEED093CB22BB8F5ACDC3
        System.err.println(MD5(MD5(input) + "加盐"));// MD5加盐(随机字符串), 极大加强安全性: 1FEED1AECF760C313879517FA3A8F2B6
        System.err.println(SHA1(input));// HEX是一个字符占4位, 20个字节, 共40个字符 => 2AAE6C35C94FCFB415DBE95F408B9CE91EE846ED
        System.err.println(SHA256(input));// HEX是一个字符占4位, 32个字节, 共64个字符 => B94D27B9934D3E08A52E52D7DA7DABFAC484EFE37A5380EE9088F7ACE2EFCDE9
```

```java
// MD5消息摘要
    public static String MD5(String str) {
        try {
            MessageDigest md5 = MessageDigest.getInstance("MD5");// 算法类型
            md5.update(str.getBytes("UTF-8"));// 字符集
            byte[] digest = md5.digest();// MD5范围到此为止
            return DatatypeConverter.printHexBinary(digest);
        } catch (NoSuchAlgorithmException e) {
            // do nothing
        } catch (UnsupportedEncodingException e) {
            // do nothing
        }

        return null;
    }

    // SHA1不太安全
    public static String SHA1(String str) {
        try {
            MessageDigest SHA1 = MessageDigest.getInstance("SHA");
            SHA1.update(str.getBytes("UTF-8"));
            byte[] digest = SHA1.digest();// SHA1范围到此为止
            return DatatypeConverter.printHexBinary(digest);
        } catch (NoSuchAlgorithmException e) {
            // do nothing
        } catch (UnsupportedEncodingException e) {
            // do nothing
        }

        return null;
    }

    // SHA256比较安全
    public static String SHA256(String str) {
        try {
            MessageDigest SHA256 = MessageDigest.getInstance("SHA-256");
            SHA256.update(str.getBytes("UTF-8"));
            byte[] digest = SHA256.digest();// SHA256范围到此为止
            return DatatypeConverter.printHexBinary(digest);
        } catch (NoSuchAlgorithmException e) {
            // do nothing
        } catch (UnsupportedEncodingException e) {
            // do nothing
        }

        return null;
    }
```

#### 4. 加密解密

对原来的明文按照某种算法进行处理，使其成为不可读的一段代码，即密文。

- 作用：保护数据不被非法人窃取、阅读，保证发送**消息的保密性**。

- 算法类型：

  - **对称加密**：
    - 概念：加密和解密时使用的**密钥是同一个**，因此又称为共享密钥加密算法。
    - 优点：算法公开、计算量小、速度快、效率高。
    - 缺点：发送双发使用相同的密钥，密钥容易泄露，安全性较弱。
    - 相关技术：DES（速度快、容易被破解）、AES（难以被破解）等。
  - **非对称加密**：
    - 概念：加密和解密使用**不同的密钥**，包含一个公开密钥（公钥）和一个私有密钥（私钥），因此又称为公开密钥加密算法。
    - 优点：密钥成对出现，且私钥存在传输泄露的风险，大大增加了安全性。
    - 缺点：算法复杂，速度远远低于对称加密算法、不适用于数据量较大的场景。
    - 相关技术：RSA等。

  *注意点：算法类型、字符集、使用哪个密钥、编码类型*

```java
        // 3、加密算法: RSA跨平台, 不推荐使用JAVA方式(PKCS8)来生成私钥和公钥, 推荐用OPEN SSL(Git Hub)方式生成(PKCS1 | PKCS8)
        //      1) 对称加密: 收发双方约定同一个Key, Key被劫持了就不安全了
        //      2) 非对称加密: 收发双发约定一对Key, 只把一半在网上流传, 另一半不流传
        // RSA非对称加密默认使用Base64格式编码
        String publicKeyStr = "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDTse/HAlvTdgaUn4uCFiC6o++G\n" +
                "SPQ9XN3DjBOyitzOO0atlTG68KZnhEoUMZGJ2grKgWu49xjV8XY+8AUziAZfFJ5g\n" +
                "LXN/e9QuJ+yLm7hPfEmOAZorGLLxUV1ms266RqD9V9l2UJGlmVqo4ZV9pRnbxW8a\n" +
                "7sh2iR/2pIM5p3atiwIDAQAB";
        String privateKeyStr = "MIICdwIBADANBgkqhkiG9w0BAQEFAASCAmEwggJdAgEAAoGBANOx78cCW9N2BpSf\n" +
                "i4IWILqj74ZI9D1c3cOME7KK3M47Rq2VMbrwpmeEShQxkYnaCsqBa7j3GNXxdj7w\n" +
                "BTOIBl8UnmAtc3971C4n7IubuE98SY4BmisYsvFRXWazbrpGoP1X2XZQkaWZWqjh\n" +
                "lX2lGdvFbxruyHaJH/akgzmndq2LAgMBAAECgYEAgKkZeNNXKdsGvteEu4hlVeoC\n" +
                "zpOSVaUWZx3Abvf0oSbnmuIdOme+SxXczA8gTC8H9fHYna8YGhdJ7ZCFKL+YVqA3\n" +
                "y3ytx3VPcUR/DIexfsUKTQwxWbmwFOXjimHd1EOWglhP16jX+JqJdcYO8WUDaYJY\n" +
                "fII+52w4IBqXQzV0ROECQQDsjP6eVx+ocT3vPWKuO4k68xNIbJYv0rI6OUirq+iW\n" +
                "fEyt+qQg46p7cVcwjVy+smTEOcALljGp3qvBF+c9cEgbAkEA5RnFOnG4OWfEkzPF\n" +
                "bJPqZ49E59Yt6Gh0EC163IzFtirB/GMumrT70Gs1vItrZb8iYuhaK1uZB0lJLJPB\n" +
                "ppdnUQJBAKVa2hHtbR/eKSE3k+efjoo6qNwTq9i6PAQfTwFSJkArm55yepDTFLU9\n" +
                "wWkbKB3VrkLM68Yts4G/Oei8wNRdzMkCQE6LwE/iTzv3NLEXLdek+teYihJGHyUw\n" +
                "MqKdRSM6bEqhbDKguoi2BiOVri2/SwnuNtbcPJXi6JtT5++NlPYNsJECQAsU+Ama\n" +
                "zDNyx8oq/s/JmB/jk6HmNMUaujsBd4N3yvO9awaLEgeghD02lIa0smd9qgqLVhm8\n" +
                "rl0xPQV91p5pcFU=";

        // 如果不采用读文件的, 需要手动清理IDE加的"\n"
        publicKeyStr = publicKeyStr.replace("\n", "");
        privateKeyStr = privateKeyStr.replace("\n", "");

        String rsaEncryptStr = rsaEncrypt(input, toPublicKey(publicKeyStr));
        System.err.println(rsaEncryptStr);// UdYxJbZirWPDAHhIaTLA4q6jrdh0MWNu+OFZaAP5rZqvR9Vzynl53uyUe6OisyRxHS++q8EnHu6hEaFGdJNimuZ99yo0Lpq8AxudlUd7j9JvFd2EmAo+phA1KnC+SHn1BOF6qYVymhjxnsWnB2IHACIcFhWcHinC7txSVjZHQo0=
        String rsaDecryptStr = rsaDECRYPT(rsaEncryptStr, toPrivateKey(privateKeyStr));
        System.err.println(rsaDecryptStr);// hello world
```

```java
// Java生成RSA非对称加密公钥对象
    public static PublicKey toPublicKey(String str) {
        try {
            KeyFactory keyFactory = KeyFactory.getInstance("RSA");// 算法类型
            byte[] bytes = Base64.getDecoder().decode(str);// OPENSSL 生成的RSA公钥采用Base64编码
            X509EncodedKeySpec x509EncodedKeySpec = new X509EncodedKeySpec(bytes);// 公钥统一标准X509编码
            return keyFactory.generatePublic(x509EncodedKeySpec);
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (InvalidKeySpecException e) {
            e.printStackTrace();
        }

        return null;
    }

    // Java生成RSA非对称加密私钥对象
    public static PrivateKey toPrivateKey(String str) {
        try {
            KeyFactory keyFactory = KeyFactory.getInstance("RSA");// 算法类型
            byte[] bytes = Base64.getDecoder().decode(str);// OPENSSL 生成的RSA公钥采用Base64编码
            PKCS8EncodedKeySpec pkcs8EncodedKeySpec = new PKCS8EncodedKeySpec(bytes);// JAVA私钥只能读PKCS8格式
            return keyFactory.generatePrivate(pkcs8EncodedKeySpec);
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (InvalidKeySpecException e) {
            e.printStackTrace();
        }

        return null;
    }

   // RSA非对称加密
    public static String rsaEncrypt(String str, Key key) {
        try {
            Cipher cipher = Cipher.getInstance("RSA");// 算法类型
            cipher.init(Cipher.ENCRYPT_MODE, key);// 加密模式
            byte[] bytes = str.getBytes("UTF-8");// 字符集
            byte[] doFinal = cipher.doFinal(bytes);// RSA范围到此为止

            // RSA通常使用Base64编码
            return Base64.getEncoder().encodeToString(doFinal);
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (NoSuchPaddingException e) {
            e.printStackTrace();
        } catch (InvalidKeyException e) {
            e.printStackTrace();
        } catch (BadPaddingException e) {
            e.printStackTrace();
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        } catch (IllegalBlockSizeException e) {
            e.printStackTrace();
        }

        return null;
    }

    // RSA非对称解密
    public static String rsaDECRYPT(String str, Key key) {
        try {
            Cipher cipher = Cipher.getInstance("RSA");// 算法类型
            cipher.init(Cipher.DECRYPT_MODE, key);// 解密模式
            byte[] bytes = Base64.getDecoder().decode(str);// RSA通常使用Base64编码
            byte[] doFinal = cipher.doFinal(bytes);// RSA范围到此为止

            // 这里采用UAT-8字符集
            return new String(doFinal,"UTF-8");
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (NoSuchPaddingException e) {
            e.printStackTrace();
        } catch (InvalidKeyException e) {
            e.printStackTrace();
        } catch (BadPaddingException e) {
            e.printStackTrace();
        } catch (IllegalBlockSizeException e) {
            e.printStackTrace();
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }

        return null;
    }
```

#### 5. 数字签名

- 作用：身份认证发送方，具有消息的不可抵赖性，同时保证消息的完整性。
- 相关技术：消息摘要算法 + 加密解密算法。

```java
        // 4、数字签名: 散列+加密 = 消息摘要 + 非对称加密
        //      1) 证明消息没被别人篡改过 => 消息摘要
        //      2) 证明确实是发送方发过来的 => 非对称加密, 使用自己的私钥加密消息
        String sign = rsaSign(toPrivateKey(privateKeyStr), input);
        System.err.println(sign);// PDhFYAx3FSIajHFYwP35PInipQxmFA/qtuCJXPALOoUf2nZlIC3Xt9qfSK/hovhhXBIuOSReTnKLCHDuvXJ0rfNVC1SqO4yYl5PXeiHgOjUj18VLxKyId0H9Z4+L47Uhb3JSsNv+X8trE6Q4dDj29xjVeVEBkfsKYdqjc8QxSPQ=
        boolean res = rsaVerifySign(toPublicKey(publicKeyStr), input, sign);
        System.err.println(res);// true
```

```java
    // Java利用MD5WithRSA实现数字签名, 一定要用自己的私钥进行数字签名
    public static String rsaSign(PrivateKey privateKey, String str) {
        try {
            Signature signature = Signature.getInstance("MD5WithRSA");// 算法类型
            signature.initSign(privateKey);// 初始化私钥
            signature.update(str.getBytes("UTF-8"));// 数据字符集采用UTF-8
            byte[] sign = signature.sign();// 数字签名范围到此为止
            return Base64.getEncoder().encodeToString(sign);// 通常数字签名使用Base64编码
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (InvalidKeyException e) {
            e.printStackTrace();
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        } catch (SignatureException e) {
            e.printStackTrace();
        }

        return null;
    }

    // Java利用MD5WithRSA实现数字验签, 一定要用对方的公钥进行验签
    public static boolean rsaVerifySign(PublicKey publicKey, String str, String sign) {
        try {
            Signature signature = Signature.getInstance("MD5WithRSA");// 算法类型
            signature.initVerify(publicKey);// 初始化公钥
            signature.update(str.getBytes("UTF-8"));// 数据字符集采用UTF-8
            byte[] bytes = Base64.getDecoder().decode(sign);// 通常数字签名使用Base64编码
            return signature.verify(bytes);// 数字验签范围到此为止
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (InvalidKeyException e) {
            e.printStackTrace();
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        } catch (SignatureException e) {
            e.printStackTrace();
        }

        return false;
    }
```

### 1.2. 数字签名与数据加密的区别？

- **数字签名**：

![1620308002223](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620308002223.png)

1. 发送方先使用Hash函数对将要发送的明文生成**消息摘要**。
2. 发送方使用**自己的私钥**签名消息摘要，生成**已签名的消息摘要**。
3. 发送方把将要发送的**明文**和**已签名的消息摘要**，一起发送给接收方。
4. 接收方再使用**发送方的公钥**对收到的**已签名的消息摘要**进行验证，验证通过可以得到原始的消息摘要。此步验证了**发送方的身份**。
5. 接收方使用相同的Hash函数对收到的**明文**生成**消息摘要**，与解密出来的消息摘要进行比对，判断两者是否一致。此步验证了**消息的完整性**。

- **数据加密**：

（基于大质数分解数学原理的非对称加密，一般大的数值对作为私钥，小的数值对作为公钥）

![1620305224976](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620305224976.png)

![1620305447877](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620305447877.png)

1. 发送方先生成一个**对称密钥**，使用此密钥将对称加密将要发送的明文，生成密文。
2. 发送方使用**接收方的公钥**非对称加密上述生成的**对称密钥**，生成加密后的密钥。
3. 发送者将**密文**与**加密后的密钥**（*成为数字信封*），一起发送给接收方。
4. 接收者使用**自己的私钥**解密加密后的密钥得到原始的**对称密钥**，再用该对称密钥解密密文，得到真正的明文。

- **数字签名与数据加密的区别**：（共同点：都使用了公开密钥体系）

|                    | 数字签名                                                     | 数据加密                                                     |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 加密方式（发送时） | 使用发送方的私钥                                             | 使用接收方的公钥                                             |
| 解密方式（接收时） | 使用发送方的公钥                                             | 使用接收方的私钥                                             |
| 映射关系           | 一对多，只有拥有私钥的才能代表发送，任何拥有公钥的人都可以解密 | 多对一，任何拥有公钥的人都可以加密发送，只有拥有私钥的才能解密成功 |
| 使用的算法         | 非对称加密                                                   | 对称加密明文、非对称加密**对称密钥**                         |
| 作用               | 保证发送的消息的**完整性、身份认证和不可抵赖性**             | 发送的消息的**保密性**                                       |

### 1.3. PKCS1与PKCS8的区别？

使用OPEN SSL生成私钥和公钥：

- **PKCS1**：
  - 概念：一种标准的生成私钥Key的方法，是RSA的密钥的原本格式。
  - 特点：BEGIN 开头：BEGIN RSA PUBLIC KEY
  - 作用：生成私钥。
  - 语法：
    - 生成私钥：genrsa -out private 1024
    - 生成公钥：rsa -in private -pubout -out public

![1620305778221](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620305778221.png)

![1620305830513](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620305830513.png)

![1620305962240](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620305962240.png)

- PKCS8：
  - 概念：用于转换私钥，在PKCS1数据上增加了一些信息，使其可存储更多的元信息。
  - 特点：与PKCS1能够相互转换、可以用于非RSA对称加密算法、JAVA只认PKCS8。
  - 语法：
    - KCS1转换成PKCS8：pkcs8 -topk8 in private -nocrypt -out private_pkcs8

![1620306139689](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620306139689.png)



## **3. 操作系统基础**

### 1.1. 进程和线程的区别？

- **进程**：是**资源分配的最小单位**。
  - 在Java中，启动main函数相当于启动一个进程，而main函数所在的线程该进程中的线程，称为主线程。
- **线程**：是**任务调度和执行的最小单位**，线程并行执行，会存在资源竞争和上下文切换的问题。
  - 在Java中，一个进程可以有多个线程，多个线程共享进程的堆和方法区资源，但不共享栈和程序计数器，每个线程有自己的本地方法栈、虚拟机栈和程序计数器。各个线程之间切换工作时，负担要比进程小得多，所以线程也被称为轻量级进程。
- **协程**：是一种比线程更加轻量级的存在，一个线程可以拥有多个协程，协程没有增加线程数量，只是在线程的基础之上通过**分用复用**的方式运行多个协程。**协程只有和异步I/O结合起来才能发挥出最大的威力**，这是因为：
  - 对于计算密集型任务本身并不需要大量的线程切换（一般只需要C + 1），此时使用协程的作用非常有限，反而还增加了协程切换的开销。
  - 由于操作线程是任务调度和执行的最小单位，即操作系统只知道线程，并不知道协程的存在，所以在协程调用阻塞I/O时，操作系统会让线程进入阻塞状态，导致绑定在该线程之上的其他协程都会陷入阻塞而得不到调度（应该启动个新的线程或者封装I/O为异步非阻塞/O）。
- *管程：指的是管理共享变量以及对共享变量的操作过程，以让他们支持并发，是一种进程同步互斥工具。*
  - 作用：解决信号量机制变成麻烦，容易出错的问题。
  - 特点：各外部进程/线程只能通过管程提供的特定入口才能访问共享数据，且每次仅允许一个进程在管程内执行某个内部过程。
  - 场景：Java中的synchronized、wait()、notify()、notifyAll()等。

### 1.2. 进程间的通信方式？

1. **管道**：亲缘关系使用无名管道，非亲缘关系使用有名管道，遵循FIFO，是**半双工**通信方式，数据只能单向流动。
   - 无名管道：pipe，管道是一种半双工的通信方式，数据只能单向流动，且只能在具有亲缘关系的进程间使用（如父子进程）。
   - 高级管道：popen，指在当前程序进程中启动另一个程序进程，把其当做是当前程序进程的子进程。
   - 有名管道：named pipe，同样是半双工，但允许无亲缘关系进程间通信。
2. **信号**：signal，信号是一种比较复杂的通信方式，用于**通知接收进程某个事情已经发送了**。比如用户调用kill命令将信号发送给其他进程。
3. **消息队列**：message queue，消息队列即消息的链表， 存放在内核中并由消息队列标识符标识，克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等特点。
4. **共享内存**：shared memory，共享内存就是映射一段能被其他进程所访问的内存。
   - 这段共享内存由一个进程创建，多个进程都可以直接读写，是**最快的IPC方式**，是针对其他进程间通信方式运行效率低而专门设计的。
   - 由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。
5. **信号量**，semophore，信号量是一个计数器，用于控制多个进程对共享资源的访问，常作为**进程间以及同一进程不同线程之间的同步手段**。
6. **套接字**：socket，与其他通信机制不同，它是通信双方的一种约定，用于**不同机器间的进程通信**。

### 1.3. 核心态与用户态？

> 特权指令是拥有特殊权限的指令，用于调用系统函数或系统软件等。比如内存清理、重置时钟、分配系统资源、修改虚存段表和页表、修改用户访问权限等。
>
> 非特权指令是普通权限的指令，在程序执行时都可以调用。

核心态与用户态是两种处理器状态：

- **核心态（Kernel Mode）**：
  - 当程序运行在0特权级时（RING0~3），称之为运行在**核心态**。RING0是最高的特权级。
  - 运行操作系统程序（**内核程序**），可以**执行特权指令和执行非特权指令**。CPU可以访问内存的所有数据，包括外围设备等硬件资源。
  - 处于核心态时，进程能访问所有的内存和对象，且所占有的处理器不允许被抢占。
- **用户态（User Mode）**：
  - 当程序运行在3级特权级时（RING0~3），称之为运行在**用户态**，RING3是最低的特权级，是普通用户进程运行的特权级，大部分用户直接面对的程序都是运行在用户态。
  - 运行**应用程序**，只能执行**非特权指令**。只能**受限地**访问内存。
  - 处于用户态时，进程所能访问的内存空间和对象受到限制，其所占有的处理器可能被抢占。

### 1.4. 为什么要有核心态和用户态？

- 由于特权指令权限重大，如果使用不当将会导致整个系统崩溃，为了**保证系统安全**，这类指令只能用于操作系统或者其他系统软件，不直接提供给用户使用，所以CPU状态区分为核心态和用户态：
  - 特权指令必须在核心态执行，且内核态可以使用全部指令。
  - 用户态只能使用非特权指令，当用户态下使用特权指令时，将产生中断以阻止用户使用特权指令。

### 1.5. 用户态与核心态之间的切换？

- **用户态 -> 核心态**：通过**中断**实现，且**中断是用户态到核心态的唯一途径**。
  - *这里的中断指的是广义的中断，包括异常和狭义的中断。*
  - 因为发生中断意味着需要操作系统介入，开展管理工作，而操作系统的管理工作（如进程切换、分配I/O设备等）需要使用特权指令，所以CPU需要从用户态转为核心态。**中断可以使CPU从用户态切换为核心态，使操作系统获得计算机的控制权。**
- **核心态 -> 用户态**：通过执行一个特权指令，将程序状态字（PSW）标志位设置为用户态即可。

### 1.6. 内中断与外中断？

广义的中断可以分为内中断和外中断：

- **内中断**：也称为**异常**、例外、陷入，信号来源于CPU内部，与当前执行指令有关。
  - **陷阱、陷入**：trap，有意而为之的异常，如系统调用。
  - **故障**：fault，由错误条件引起的，可能被故障处理程序修复，如缺页中断。
  - **终止**：abort，不可修复的致命错误造成的结果，终止处理程序不再将控制返回给引入终止的应用，如整数除以0。
- **外中断**：是**狭义的中断**，信号来源于CPU外部，与当前执行的指令有关。
  - **外设请求**：如外围设备的中断，即I/O操作完成发出的中断信号。
  - **人工干预**：如用户强行终止一个进程。

### 1.7. Linux的进程地址空间？

![1620546981765](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620546981765.png)

- **栈**：stack，进程运行的栈，存储局部变量、临时变量，函数调用时，存储函数的返回指针，用于控制函数调用和返回。在程序块开始时自动分配内存，结束时自动释放内存，其操作方式类似于数据结构中的栈。
- **内存映射段**：memory mapping space（mmap），系统调用使用的空间，通常用于文件映射到内存，在进程创建时，会将程序用到的平台、动态链接库加载到该区域。
- **堆**：heap，是能够动态分配的内存空间，需要程序员手工分配，分配方式类似于链表。
- **未初始化过的数据**：bss segment，存储未初始化的全局或者静态变量。
- **初始化过的数据**：data segment，存储已经初始化的全局或者静态变量。
- **程序段**：text segment，是程序代码在内存中的映射，存放函数体的二进制代码。

### 1.9. 内存保护、覆盖技术、内存交换、紧凑技术、虚拟内存技术？

- **内存保护**：保护各进程在自己的内存空间内运行，不会越界访问。
- **覆盖技术**：将程序分为多个段（即多个模块），常用的段常驻固定区，不常用段在需要时才调入覆盖区，替换覆盖区中原有的段。
- **内存交换**：内存紧张时，换出某些进程以腾出内存空间，再换入某些进程。
- **紧凑技术**：用于解决分区分配遗留碎片的问题，通过在内存中移动程序，将所有小的空闲区域合并为大的空闲区域。
- **虚拟内存技术**：允许一个作业分多次调入内存，其实现建立在离散分配的内存管理方式基础上，分为**请求分页存储管理**、**请求分段存储管理**以及**请求段页式存储管理**。
  - **请求调页功能**：访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存。
  - **页面置换功能**：内存空间不够时，将内存暂时用不到的信息换出到外存。

### 2.0. 外部碎片与内部碎片？

- **外部碎片**：指内存中某些空闲分区由于太小而难以利用上。
- **内部碎片**：指分配给某进程的内存区域中，如果有些部分没有用上，那么就说有内部碎片。

### 2.1. 操作系统内存管理方式？

> 连续分配管理，指为一个用户程序分配一个**连续的内存空间**，分为单一连续分配、固定分区分配和动态分区分配。
>
> 非连续分配管理，允许一个程序**分散**地装入到不相邻的内存分区中，分为基本分页存储管理、基本分段存储管理和基本段页式管理方式。

#### 连续分配管理

##### 1. 单一连续分配

- 思想：内存被分为**系统区和用户区**，系统区通常位于内存的低地址部分，用于存放操作系统相关数据。用户区用于存放用户进程相关数据。
- 特点：内存中只能有一道用户程序，用户程序独占整个用户区。
- 优点：实现简单、无外部碎片、无需进行内存保护。
- 缺点：只能用于单用户、单任务的操作系统中，有内部碎片，存储器利用率极低。
- ![1620549393027](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620549393027.png)

##### 2. 固定分区分配

- 思想：将整个用户空间划分为若干个**固定大小的分区**，在每个分区中只装入一道作业。
- 特点：该方式是最早、最简单的一种可运行多道程序的内存管理方式。
- 分类：分区大小相等、分区大小不等（需要有分区说明表）。
- 优点：实现简单、无外部碎片。
- 缺点：
  - 当用户程序太大时，可能所有的分区都满足不了要求，此时不得不采用覆盖技术来解决，降低性能。
  - 会产生内部碎片、内存利用率低。
- ![1620549849883](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620549849883.png)

##### 3. 动态分区分配

- 思想：又称可变分区分配，该方式不会预先划分内存分区，而是在进程装入内存时，根据进程的大小**动态地建立分区**，使分区大小适合程序的需要。
- 特点：系统分区大小和数目可变。
- 内存使用记录方式：
  - 空闲分区表：每个空闲分区对应一个表项，包含分区号、分区大小、分区起始地址信息等。
  - 空闲分区链：每个分区的起始部分和末尾部分分别设置前向指针和后向指针，其中起始部分可记录分区大小等信息。
- 动态分区分配算法：
  - 首次适应算法：First Fit，空闲分区按**地址递增**的次序链接，分配内存时顺序查找，找到满足要求的第一个空闲分区。
    - 优点：最简单、性能最好。
    - 缺点：低地址部分会出现很多很小的空闲分区，增加查找的开销。
  - 最佳适应算法：Best Fit，空闲分区按**容量递增**的次序链接，分配内存时顺序查找，找到满足要求的第一个空闲分区。
    - 缺点：会产生很多、很小、难以利用的外部碎片。
  - 最坏适应算法：Worst Fit，又称最大适应算法，空闲分区按**容量递减**的次序链接，分配内存时顺序查找，找到满足要求的第一个空闲分区。
    - 缺点：每次都选择最大的分区分配，会导致后面的大进程无大分区可分配。
  - 邻近适应算法：Next Fit，空闲分区以**地址递增**的次序链接（循环链表），分配内存时从**上次查找结束的位置**开始查找，找到满足要求的第一个空闲分区。
    - 缺点：相比首次适应算法，会出现高地址部分被分割成多个小分区，导致后面的大进程无大分区可配。
- 优点：可根据装入进行大小动态分配、没有内部碎片、支持多道程序。
- 缺点：有外部碎片，可以通过**紧凑技术**来解决外部碎片。
- ![1620550822833](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620550822833.png)

#### 非连续分配管理

##### 1. 基本分页存储管理

- 思想：把**内存分为一个个相等的小分区**，再按照分区大小把**进程拆分一个个小部分**。

- 相关概念：

  ![1620554821838](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620554821838.png)

  - 页框：又称页帧、内存块、物理块，是指将内存空间分为一个个大小相等的分区。
  - 页框号：又称页帧号、内存块号、、物理块号，是指每个页框的编号，是从0开始的。
  - 页面：又称页，是指将用户进程的地址空间分为与页框大小相等的一个个区域。
  - 页号：是指每个页面的编号，也是从0开始的。注意的是，进程最后一个页面可能没有一个页框那么大，所以当页框过大时，会产生过大的内部碎片。
  - 页面长度：又称页面大小，每个页面的内存大小，一般要为2的整数幂，且等同于页框大小。
  - 页面始址：对应页面在内存中的起始物理地址。
  - 页内偏移量：又称页内地址，逻辑地址在页面内的偏移量。
  - 页表：负责记录进程页面和实际存放的内存块之间的对应关系。
  - 页表长度：指这个页表中一共有几个页表项，即一共有几页。
  - 页表项：进程每一页对应一个页表项，页表项 = 页号 + 块号。而**每个页表项长度是相同的，所以页号是隐含的**（因为可以算出来最大页表项长度）。页表项也是存放在页框中的，实际应用中，往往会使得每个页框恰好可以装得下整数个页表项（这样不会有内部碎片）。
  - 页表项长度：每个页表项的内存大小。最大页表项长度 = 总内存大小 / 页面长度。

- 特点：

  - 操作系统以页框为单位，为各个进程分配内存空间，进程的每个页面分别放入一个页框中，即进程的页面和内存的页框是一一对应的关系。
  - 各个进程页面不必连续存放，也不必按照先后顺序来存放，可以放到不相邻的各个页框中。
  - 页面外的实际物理地址是离散的，页面内的实际物理地址是连续的。
  - **页式管理中的地址是一维的**，即只要给出了一个逻辑地址，系统就可以自动算出页号、页内偏移量，并不需要显示告诉页内偏移量占多少位，因为页面大小是系统确定好了的（页面大小确定则逻辑地址结构也确定了）。

- **物理地址转换**：

  - 页号 = 逻辑地址 / 页面长度
    - M位内存，K位页面大小时，高（M - K）位表示页号。
  - 页内偏移量 = 逻辑地址 % 页面长度
    - M位内存，K位页面大小时，低K位表示页内偏移量。
    - K位页内偏移量，则页面大小为2^K大小。
  - 页面始址 = 内存块号 * 内存块大小
  - 物理地址 = 页面始址 + 页内偏移量

- **基本地址变换机构**：

  - 作用：用于实现逻辑地址到物理地址转换的一组硬件机构，即**硬件实现物理地址转换**。
  - 相关概念：
    - 页表寄存器：PTR，存放页表在内存中的起始地址F和页表长度M。在进程未执行时，页表始址和页表长度放在进程控制块PCB中，当进程被调度时，操作系统内核才会把它们放到PTR中。
  - 计算过程：

  ![1620555134892](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620555134892.png)

  1. 根据逻辑地址，计算出页号（高M-K位）和页内偏移量（低K位）。
  2. 判断页号是否越界：页号 <= 页表长度 - 1。
  3. 第一次访存（可用快表优化）：查询页表，找到页号对应的页表项，确定页面的内存块号：页表项地址 = 页表起始地址 + 页号 * 页表项长度。
  4. 用内存块号和页内偏移量，计算得到物理地址：物理地址 = 页面始址 + 页内偏移量 = 内存块号 * 页面大小 + 页内偏移量。
  5. 第二次访存：访问目标内存单元。

- **具有快表的地址变换机构**：

  - 作用：是基本地址变换机构的改进版本，**加快访存速度**。
  - 相关概念：
    - **局部性原理**：
      - **时间局部性**：如果执行了程序中的某条指令，那么在不久之后很可能再被执行。如果某个数据被访问过，那么在不久之后很可能再被访问。（因为程序中存在大量的循环）
      - **空间局部性**：如果程序访问了某个存储单元，那么在不久之后其附近的存储单元很有可能被访问。（因为很多数据在内存中都是连续存放的）
      - 应用：由于局部性原理，程序很有可能连续多次查询同一个页面，即同一个页表项，因此产生了**快表**机制。
    - 快表：TLB，联想寄存器，是一种访问速度比内存快很多的高速缓冲存储器，用来存放当前访问的**若干页表项**，以加速地址变换的过程。而内存中的页表成为慢表。
  - 计算过程：

  ![1620559002478](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620559002478.png)

  1. 根据逻辑地址，计算出页号（高M-K位）和页内偏移量（低K位）。
  2. 判断页号是否越界：页号 <= 页表长度 - 1。
  3. **先查询快表**，如果要访问的页表项在快表中有副本，则直接取出，否则需要第一次访存：查询页表，找到页号对应的页表项，再**把页表项拷贝一份到快表中**。接着确定页面的内存块号：页表项地址 = 页表起始地址 + 页号 * 页表项长度。
  4. 用内存块号和页内偏移量，计算得到物理地址：物理地址 = 页面始址 + 页内偏移量 = 内存块号 * 页面大小 + 页内偏移量。
  5. 第二次访存：访问目标内存单元。

- **两级页表**：

  - 作用：**离散存储页表项**、页表项需要是调入内存（**虚拟内存技术**：页表项中增加是否已调入的标志位）。

  - 相关概念：

    ![1620560132360](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620560132360.png)

    - 二级页表：用于将常常的页表项分页。
    - 页目录表：又称外层页表、顶层页表，用于记录分页页表项后的二级页表的目录。
    - 逻辑地址结构：32位 = 10位一级页号 + 10位二级页号 + 页内偏移量

##### 2. 基本分段存储管理

- 思想：按照程序自身的逻辑关系，划分程序为若干个段，每一段都有一个段名（从0开始）。内存分配时，以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻。

- 相关概念：

  - 段号：段名，段号的位数决定了每个进程最多可以分几个段。
  - 段内地址：即段内偏移量，段内地址的位数决定了每个段的最大长度是多少。
  - 段表：记录进程各个逻辑的段在内存中的存放位置，每个进程一张，包括段号、段长、段基址。
  - 段表项：进程的每一段逻辑段对应一个段表项。每个段表项长度是相同的，所以段号是可以隐含的，不需要占存储空间。
  - 段表项长度：每个段表项的内存大小。最大段表项长度 = 最大段长位数 + 最大地址位数。

- 物理地址变换过程：

  ![1620561048183](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620561048183.png)

  1. 根据逻辑地址，得到段号（高M/2位）、段内地址（低M/2位）。
  2. 判断段号是否越界：段号 <= 段表长度 - 1。
  3. 第一次访存（可用快表优化）：查询段表，找到对应的段表项：段表项始址 = 段表始址 + 段号 * 段表项长度。
  4. 检查段内地是否超过段长：段内地址 <= 段长。
  5. 计算得到物理地址：物理地址 = 段基址 + 段内地址。
  6. 第二次访存：访问目标内存单元。

##### 3. 段页式管理

- 思想：将进程按逻辑模块分段，接着将各段分页，再将内存空间分为大小相同的内存块，最后进程将各页面分别装入各内存块中。

- 作用：结合分段管理的优点和分页管理的优点，既能有效提高内存利用率，也容易实现信息的共享与保护。

- 物理地址变换过程：

  ![1620562681599](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620562681599.png)

  1. 根据逻辑地址，得到段号（高M/2位）、页号（低M/2-K位）、页内偏移量（低K位）。
  2. 判断段号是否越界：段号 <= 段表长度 - 1。
  3. 第一次访存（可用快表优化）：查询段表，找到对应的段表项：段表项始址 = 段表始址 + 段号 * 段表项长度。
  4. 检查页号是否越界：页号 <= 页表长度 - 1。
  5. 第二次访存（可用快表优化），根据段表中的页表存放块号、页号查询页表，找到对应的页表项：页表项始址 = 页表始址 + 页号 * 页表项长度。
  6. 根据页表项中的内存块号、页内偏移量，计算得出物理地址：物理地址 = 页面始址 + 页内偏移量 = 内存块号 * 页面大小 + 页内偏移量。
  7. 第三次访存，访问目标内存单元。

### 2.2. 分页管理与分段管理的区别？

|                  | 分页管理                                           | 分段管理                                                     |
| ---------------- | -------------------------------------------------- | ------------------------------------------------------------ |
| 管理维度         | 内存分区、进程分页，页是信息的物理单位             | 进程分段，段是信息的逻辑单位                                 |
| 透明度           | 对用户是透明的                                     | 对用户可见，用户编程需要显示给出段名                         |
| 单位大小         | 页大小固定，由系统决定                             | 段长度不固定，取决于编写的程序                               |
| 用户进程地址空间 | 是一维的，用户只需要给出一个助记符表示逻辑地址即可 | 是二维的，用户既要给出段名，也要给出段内地址                 |
| 目的             | 为了实现离散分配，提高内存利用率                   | 为了更好地满足用户需求                                       |
| 共享与保护       | 不容易实现信息共享与保护                           | 纯代码或可重入代码，更容易实现信息的共享与保护，只需要各进程指向同一个段即可实现共享 |
| 优点             | 内存空间利用率高、不会产生外部碎片                 | 没有内部碎片、容易实现信息共享与保护                         |
| 缺点             | 会产生少量的页内碎片、不容易实现信息共享与保护     | 段长过大难以分配连续空间、会产生外部碎片（可通过紧凑技术解决） |

### 2.3. 请求分页管理？

> **虚拟内存技术**：允许一个作业分多次调入内存，其实现建立在离散分配的内存管理方式基础上，分为**请求分页存储管理**、**请求分段存储管理**以及**请求段页式存储管理**。
>
> **请求调页功能**：访问的信息不在内存时，由操作系统负责将所需信息从外存调入内存。
>
> **页面置换功能**：内存空间不够时，将内存暂时用不到的信息换出到外存。

- 特点：请求分页存储管理与基本分页存储管理的主要区别：需要操作系统提供**请求调页**（调入）以及**页面置换**（调出）功能。

- **页表机制**：也叫请求页表，是实现请求调页和页面置换功能的基础。对比基本分页存储管理的页表增加了4个字段：

  - 状态位：表示当前页面是否已经调入了内存。状态位为0代表当前页面还没有存在内存中。
  - 访问字段：用于记录当前页面最近被访问过几次，或者上次访问的时间，以供置换算法选择换出页面时参考。
  - 修改位：用于标记当前页面调入内存后是否被修改过（没有被修改过的页面是不需要写会外存的）。
  - 外存地址：表示当前页面在外存中的存放位置。

- **缺页中断机构**：**请求调页**的基础，在请求分页系统中，当要访问的页面不存在时，会产生一个**缺页中断**（内中断-故障），然后操作系统的缺页中断处理程序处理该中断。此时的缺页进程会**阻塞**，被放入阻塞队列，在调页完成后，操作系统才将其唤醒，放回就绪队列。

  缺页中断机构处理中断逻辑如下：

  - 如果内存中有空闲块，则为进程分配一个空闲块，将所缺失的页面装入该块，并修改请求页表中相应的页表项。
  - 如果内存中没有空闲块，则由**页面置换算法**选择一个页面淘汰，同时若该页面在内存期间被修改过，则还需要将其写回外存，而未修改过的页面则不需要写回外存。

- **地址变换机构**：

  与基本分页存储管理的页表不同的是：

  - 找到页表项时，需要判断页面是否在内存中。
  - 若页面不在内存中，则需要请求调页。
  - 如果调入页面内存空间不够时，需要进行页面置换。
  - 页面被访问、页面调入以及页面调出后，需要修改请求页表中相应的页表项。

![1620573633869](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620573633869.png)

### 2.4. 页面置换算法？

请求分页系统中，在内存空间不够时，由操作系统负责将内存中暂时用不到的信息换出到外存。

页面置换算法用于决定应该换出**哪个页面**到外存。

**页面的换入、换出**需要磁盘I/O，开销比较大，因此好的页面置换算法应该追求**更少的缺页率**，以减少页面换入、换出的次数。

缺页不等于页面置换，只有在缺少空闲内存块才需要发生页面置换。

#### 1. 最佳置换算法OPT

- 概念：optimal，每次淘汰**未来永不使用**或者**未来最长时间不再被访问**（顺方向）的页面。
- 优点：可以保持**最低的缺页率**。
- 缺点：**实际上无法实现**，因为操作系统无法提前预判未来的页面访问序列。

![1620648468359](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620648468359.png)

#### 2. 先换先出置换算法FIFO

- 概念：first in first out，每次淘汰**最早进入内存**的页面。
- 实现方法：把调入内存的页面根据调入的先后顺序排成一个队列，需要换出页面时，只需要选择对头页面即可。
- **Belady异常**：贝拉底异常，指当为进程分配的内存块增大时，缺页的次数不减反增的异常现象。FIFO算法是唯一一个会出现Belady异常的页面置换算法。
- 优点：实现简单。
- 缺点：会有Belady异常，与运行时的规律不适应（因为先进入的页面后面也有可能最经常被访问），性能极差。 

![1620650037437](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620650037437.png)

![1620650005876](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620650005876.png)

#### 3. 最近最久未使用算法LRU

- 概念：least recently used，每次淘汰**最近最久未使用**（逆方向）的页面。
- 实现方法：在每个页面对应的页表项中，用**访问字段**来记录该页面从上次被访问到现在经历的时间t，当要淘汰页面时，选择页面中t值最大的，就是最近最久未使用的页面了。
- 优点：考虑到了时间局部性，性能好，实际应用较多。
- 缺点：实现困难，开销大，实现需要专门的硬件支持。

![1620649947028](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620649947028.png)

```java
/**
 * @program: Java
 * @description: LRU最近最久未使用置换算法，通过LinkedHashMap实现
 * @author: Mr.Li
 * @create: 2020-07-17 10:29
 **/
public class LRUCache {
    private LinkedHashMap<Integer,Integer> cache;
    private int capacity;   //容量大小

    /**
     *初始化构造函数
     * @param capacity
     */
    public LRUCache(int capacity) {
        cache = new LinkedHashMap<>(capacity);
        this.capacity = capacity;
    }

    // 使用过则需要放到链表尾部, 代表经常被使用，而链头代表的是最近最久未被使用的结点
    public int get(int key) {
        //缓存中不存在此key，直接返回
        if(!cache.containsKey(key)) {
            return -1;
        }

        int res = cache.get(key);
        cache.remove(key);   //先从链表中删除
        cache.put(key,res);  //再把该节点放到链表末尾处
        return res;
    }

    // 使用过则需要放到链表尾部, 代表经常被使用，而链头代表的是最近最久未被使用的结点
    // 在链表满时，还需要删除最近最久未被使用的结点，即链头结点
    public void put(int key,int value) {
        if(cache.containsKey(key)) {
            cache.remove(key); //已经存在，在当前链表移除
        }
        if(capacity == cache.size()) {
            //cache已满，删除链表头位置
            Set<Integer> keySet = cache.keySet();
            Iterator<Integer> iterator = keySet.iterator();
            cache.remove(iterator.next());
        }
        cache.put(key,value);  //插入到链表末尾
    }
}

```

```java
/**
 * @program: Java
 * @description: LRU最近最久未使用置换算法，通过LinkedHashMap内部removeEldestEntry方法实现
 * @author: Mr.Li
 * @create: 2020-07-17 10:59
 **/
class LRUCache {
    private Map<Integer, Integer> map;
    private int capacity;
	
    /**
     *初始化构造函数
     * @param capacity
     */
    public LRUCache(int capacity) {
        this.capacity = capacity;
        map = new LinkedHashMap<Integer, Integer>(capacity, 0.75f, true) {
            @Override
            protected boolean removeEldestEntry(Map.Entry eldest) {
                // 容量大于capacity 时就删除，删除最近最久未被使用的空闲结点
                return size() > capacity;
            }
        };
    }
    public int get(int key) {
        //返回key对应的value值，若不存在，返回-1
        return map.getOrDefault(key, -1);
    }

    public void put(int key, int value) {
        map.put(key, value);
    }
}
```

#### 4. 时钟置换算法CLOCK

- 概念：又称最近未用算法（NRU，not Recently Used），对比OPT和LRU，这是一种**性能和开销较平衡**的算法。
- 实现方法：

1. 为每个页面设置访问位（**访问位为1表示最近访问过，访问位为0表示最近没有访问过**），再将内存中的页面通过链表指针链接成一个循环队列。
2. 当页面被访问时，访问位将置为1。
3. 在淘汰页面时，循环检查访问位，把为1的置为0，为0的淘汰，如果第一轮全为1，则置换为0后进行第二轮扫描，所以**最多会经过2轮扫描**。
4. 而被置换进行的页面会被置为1，且扫描指针指向下一个页面。

- 优点：实现简单、算法开销小。
- 缺点：未考虑页面是否被修改过。

![1620651040375](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620651040375.png)

#### 5. 改进型时钟置换算法

- 概念：由于淘汰被修改过的页面时，需要写回外存，所以在时钟置换算法CLOCK的基础上，应该优先淘汰**最新没被修改过、没被访问过的**页面，避免写回外存的I/O操作。
- 实现方法：

1. 每个页面增加修改位（**修改位为0表示没有被修改过，修改位为1表示页面被修改过**），用（访问位，修改位表示），将所有可能被置换的页面排成一个循环队列。
2. 第一轮扫描：扫描第一个（0，0）即**最近没被修改过、没被访问过**的页面，本轮扫描不修改任何标志位。
3. 第二轮扫描：第一轮失败后，需要重新扫描。扫描第一个（0，1）即**最近被修改过、没被访问过**的页面用于替换，本轮扫描过的访问位置为0。
4. 第三轮扫描：第二轮失败后，需要重新扫描。扫描第一个（0，0）即**最近没被修改过、但被访问过**的页面用于替换，本轮扫描不修改任何标志位。
5. 第四轮扫描：第三轮失败后，需要重新扫描。扫描第一个（0，1）即**最近被修改过、也被访问过**的页面用于替换。改进型CLOCK算法淘汰一个页面**最多经过4轮扫描**。

- 优点：算法开销较小、性能也不错、考虑了页面是否被修改过（有修改位和访问位）。

![1620652055064](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620652055064.png)

### 2.5. 死锁的条件与解决方式？

> 哲学家进餐问题：每位哲学家都在等待自己右边的人放下筷子，即这些哲学家进程都因等待筷子资源而被阻塞，这就是发生了死锁。

- **死锁**：指在并发环境，**各进程因竞争资源而造成的一种互相等待对方手里资源**，导致各进程都阻塞，无法向前推进的现象。发生死锁后，若无外力干涉，这些进程都将无法向前推进。

- **死锁产生的必要条件**：产生死锁必须**同时满足**以下四个条件，只要其中任一条件不成立，死锁就不会发生。

  - **互斥条件**：进程对所分配的**资源不允许其他进程访问**，若其他进程访问该资源，只能等待至占有该资源的进程释放该资源。
  - **不剥夺条件**：进程所获得的资源在未使用完之前，**不可被剥夺**，只能主动释放。
  - **请求和保持条件**：进程获得一定的资源后，又对其他资源发出请求，且由于互斥条件进入阻塞状态后，还对自己占有的资源**保持不放**。
  - **循环等待条件**：存在一种**进程资源的循环等待链**，链中的每一个进程占有的资源被下一个进程所等待。
    - 注意！发生死锁时一定有循环等待，但发生循环等待时未必发生死锁（循环等待是死锁的必要不充分条件）。但如果系统中每类资源都只有一个，那循环等待则是死锁的充分必要条件。

- **死锁场景**：**对不可剥夺资源的不合理分配，可能会导致死锁。**

  - 对系统资源的竞争：各进程对不可剥夺资源的竞争可能引起死锁（如打印机），而对可剥夺资源的竞争是不会引起死锁的（如CPU）。
  - 进程推进顺序非法：请求和释放资源的顺序不当从而导致死锁。

- **死锁的处理策略**：

  - **预防死锁**：是**不允许死锁发生的静态策略**，破坏死锁的四个必要条件中的某一个。

    - **破坏互斥条件**：
      - 操作系统层面：采用SPOOLING技术，指操作系统用于把独占设备在逻辑上改造成共享设备。
      - 缺点：并不是所有的资源都可以改造成可共享使用的资源。很多时候都无法破坏互斥条件。
      - **Java层面**：乐观锁，CAS。
    - **破坏不可剥夺条件**：
      - 操作系统层面：进程请求不到其他资源时，必须立即释放保持的所有资源，或者考虑进程优先级强行剥夺想要的资源。
      - 缺点：实现比较复杂、释放资源可能会造成进程前一阶段的工作失效、反复申请和释放资源会增加系统开销，降低系统吞吐量、方案一可能会导致进程饥饿的发生。
      - **Java层面**：悲观锁，synchronized、ReentrantLock。
    - **破坏请求和保持条件**：
      - 操作系统层面：采用**静态分配方式**，进程运行需要一次申请完所有需要的资源，未满足则不能投入运行。一旦运行后，资源一直归它所有，且它不会再请求其他资源。
      - 缺点：资源利用率极低、可能会导致别的进程发生饥饿。
      - **Java层面**：数据库deadLock超时，即数据库通过锁定等待超时解决死锁。
    - **破坏循环等待条件**：
      - 操作系统层面：采用**顺序资源分配方式**，对系统该资源编号，规定每个进程必须按编号递增的顺序请求资源，对于编号相同的资源会一次申请完。
      - 缺点：不方便增加新的设备、实际使用资源的顺序可能和编号递增顺序不一致，可能会导致资源浪费、用户变成麻烦。

  - **避免死锁**：是**不允许死锁发生的动态策略**，避免系统进入**不安全状态**。

    - **安全序列**：指如果系统按照这种序列分配资源，每个进程都能顺利完成（安全序列可能有多个）。此时系统为**安全状态**，一定不会发生死锁。而如果分配资源后，系统中找不出任何一个安全序列，则系统进入了**不安全状态**，意味着之后可能发生死锁。

    - **银行家算法**：在资源分配之前先预判本次分配是否会导致系统进入不安全状态，从而决定是否答应该分配的请求，用于**避免死锁**。

      - 实现思路：保证优先分配资源给进程后，进程能够顺利执行完并归还资源，确保是安全状态。
      - 实现方法：Max矩阵、Allocation矩阵、Need矩阵、Available数组、Request数组、预判计算、回溯资源。

      ![1620737316076](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620737316076.png)

  - **死锁的检测和解除**：**允许死锁发生**，系统负责检测出死锁并解除。

    - 死锁的检测：

      - 数据结构：两种结点（进程结点、资源结点），两种边（请求边、分配边）。
      - 算法思想：最终能消除所有变，则称这个图是可完全被简化的，此时一定没有发生死锁（相当于找到了一个安全序列）。反之，如果**最终不能消除所有边，那么此时就发生了死锁（死锁定理）**。
      - 实现方法：找到孤点进程（有向边相连以及不阻塞的进程）、简化边、继续简化...

      ![1620737385049](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620737385049.png)

    - **死锁的解除**：

      - 死锁的进程：用死锁检测算法化简资源分配图后，还连着边的那些进程才是死锁进程。
      - **主要方法有**：
        - **资源剥夺法**：**挂起（暂时放到外存上）某些死锁进程，并抢占它的资源**，将这些资源分配给其他死锁的进程。
          - 缺点：需要防止进程挂起过久导致出现饥饿问题。
        - **撤销进程法**：又称**终止进程法**，强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源。
          - 缺点：虽然实现简单，但付出的代价是很大的。
        - **进程回退法**：让一个或者多个死锁进程回退到足以避免死锁的地步。
          - 缺点：操作系统需要记录进程的历史记录，设置还原点。
      - **考虑的维度**：进程优先级低的、执行时间少的、距离完成时间较久的、持有资源多的、批处理式的死锁进程。 

### 2.6. 死锁、饥饿、死循环？

- **死锁**：指各进程互相等待对方手里资源，导致各进程都阻塞，无法向前推进的现象。比如哲学家进餐问题。

- **饥饿**：指由于长期得不到想要的资源，某进程无法向前推进的现象。比如短进程优先（SPF）算法，会导致长进程饥饿问题。

- **死循环**：指某进程执行过程中一直跳不出某个循环的现象。有时是因为程序逻辑bug导致的，有时是程序员故意设计的。

  |          | 死锁                                                         | 饥饿                                                         | 死循环                                 |
  | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | -------------------------------------- |
  | 共同点   | 都是进程无法向前顺利推进的现象                               | -                                                            | -                                      |
  | 进程数量 | 至少有两个或者两个以上的进程                                 | 可能只有一个进程                                             | 可能只有一个进程                       |
  | 进程状态 | 一定处于阻塞状态                                             | 可能是阻塞状态（长期得不到I/O设备），也可能是就绪状态（长期得不到处理机） | 可以是运行状态                         |
  | 原因     | 由于**操作系统**分配资源策略不合理导致的（各进程互相等待对方手里的资源） | 由于**操作系统**分配资源策略不合理导致的                     | 由代码逻辑错误导致的（**管理者问题**） |



## 4. 设计模式基础

### 1.1. 六大原则

|              | 总结                                                     |
| ------------ | -------------------------------------------------------- |
| 单一职责原则 | 实现类要职责单一                                         |
| 里氏替换原则 | 不要破坏继承体系                                         |
| 依赖倒置原则 | 要面向接口编程                                           |
| 接口隔离原则 | 设计接口时要精简单一                                     |
| 迪米特法则   | 要减少对其他类的直接依赖、减少类对外暴露的方法，降低耦合 |
| 开放原则     | 要对扩展开放，对修改关闭                                 |

#### 1. 单一职责原则

- 概念：**一个类只负责一项职责**，不要存在本职责外导致类发生变更的原因。
- 问题由来：如果类T负责两个不同的职责P1和P2，当职责P1需求发生改变修改T时，可能会导致P2功能发生故障。
- 原因分析：出现了职责扩散。
- 解决方案：
  - 根据P1和P2职责，划分为类1和类2。
  - 在职责扩散到无法控制之前，对代码进行部分重构。
- 优点：
  - 可以降低类的复杂度，一个类只负责一项职责，逻辑简单清晰。
  - 可提高类的可读性和系统的可维护性。
  - 减少需求变更时对其他功能的影响，减少出现的风险。
- 总结：
  - 只有逻辑足够简单，才可以在代码级别上违反单一职责原则。
  - 只有类中方法数量足够少，才可以在方法级别上违反单一职责原则。
  - 模块化的程序设计以及在员工工作安排上面，都适合单一职责原则。

#### 2. 里氏替换原则

- 概念：子类可以扩展父类的功能，但不能改变父类原有的功能；子类可以替换父类，但方法或者行为不能发生改变。即**子类可以扩展父类的功能，但不能改变父类原有的功能**。
- 问题由来：子类B在扩展新功能时，有可能会导致父类原有的功能发生故障。
- 原因分析：继承的弊端，会给程序代理侵入性，使得程序的可移植性减低，增加了对象的耦合性。
- 解决方案：
  - 类B扩展新功能时，尽量不要重写父类A的方法，也尽量不要重载父类A的方法。
  - 如果子类对父类实现的方法进行修改，会对整个继承体系造成破坏，当子类要修改时，必须考虑所有的子类。并且，如果修改了父类，那么所有的子类功能可能都会发生故障。
- 优点：如果不遵循里氏替换原则，一开始程序可能是好好的，但是在之后的迭代过程中，代码出现问题的几率会大大增加，尤其当另外一个人接手项目之后。
- 总结：
  - 子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。
  - 子类中可以增加自己独特的方法。
  - 当子类的方法重载父类的方法时，方法的前置条件（形参）要比父类方法更宽松。
  - 当子类的方法实现父类的抽象方法时，方法的后置条件（返回值）要比父类更严格。

#### 3. 依赖倒置原则

- 概念：**高层模块不能依赖底层模块**，二者都应该依赖其抽象；**抽象不应该依赖细节**，细节应该依赖抽象。
- 问题由来：类A（高层模块）本来依赖类B（低层模块），但现在要修改类A依赖类C（低层模块），修改程序时可能会导致不必要的风险。
- 解决方案：将类A改为依赖接口T，而类B和类C分别实现接口T，此时**类A可以通过接口T，间接访问类B和类C，大打降低了修改类A的几率**。
- 总结：
  - 相对于细节的多变性，抽象的东西要稳定得多。依赖倒置原则的核心思想是面向接口编程，通过使用接口或者抽象类来制定好规范和契约，不用去涉及任何具体的操作，将展开细节的任务交给实现类去完成，以达到解耦的目的。
  - 低层模块尽量都要有接口或者抽象类，高层模块尽量通过接口或者抽象类的形式访问低层模块。
  - 使用抽象类时，要遵循里氏替换原则。

#### 4. 接口隔离原则

- 概念：客户端不应该依赖它不需要的接口，即一个类对另一个类的依赖都应该建立在**最小的接口**上面。
- 问题由来：类A通过接口T依赖了类B和类D，但类D不是类A想要依赖的。
- 解决方案：将臃肿的接口T拆分为独立的Tb和Td接口，类A只需要依赖Tb即可。
- 优点：提高内聚，减少对外交互，用最少的方法完成最多的事情。
- 总结：
  - 尽量细化接口，建立单一接口，使得接口中的方法尽量少。但要有限度，过小则会导致接口数量过多，增加复杂度。
  - 为单个类建立专用的接口，不要包含太多。依赖几个专用的接口要比依赖一个综合的接口灵活得多，即可以提高系统的灵活性和可维护性。
  - 为依赖接口的类定制服务，只暴露给调用类需要的方法，建立最小的依赖关系。
- 区别单一职责：
  - 单一职责注重的是职责；接口隔离注重的是接口依赖的隔离。
  - 单一职责约束的是实现类，其次才是接口和方法，针对的是程序中的实现细节；接口隔离约束的是接口，针对的是抽象和整体框架的构建。

#### 5. 迪米特法则

- 概念：又称**最少知道原则**，要求一个对象应该对其他对象有最少的了解。
- 优点：降低类之间的耦合，每个类尽量减少对其他类的依赖，尽量减少对外暴露的方法，使得功能模块独立，低耦合。
- 总结：
  - 减少对其他类的依赖，只通过成员变量、方法的输入输出参数来对类进行注入，减少方法体内部类的直接使用。
  - 减少类对外暴露的方法。
  - 虽然遵循迪米特法则可以避免和非直接的类通信，但如果要通信，则必然会通过一个中介发生联系，而过分地使用迪米特法则，会产生大量的中介和中间传递类，导致系统复杂度变高。

#### 6. 开闭原则

- 概念：软件中的对象（类、模块、函数等）应该**对于扩展是开放的，对与修改是关闭的**。
- 问题由来：对软件原有代码进行修改时，可能会将错误引入原本已经测试过的代码中，破坏原有系统。
- 解决方案：当软件需求发生变化时，尽量通过扩展实体的行为实现需求变化，而不是通过修改原有的代码来应对变化。

### 1.2. UML图

#### 1. 类UML

![1620827681262](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620827681262.png)

#### 2. 接口UML

![1620827737253](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620827737253.png)

#### 3. 类图UML

![1620827711036](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620827711036.png)

#### 4. 实现关系UML

![1620827793083](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620827793083.png)

#### 5. 泛化（继承）关系UML

![1620827830674](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620827830674.png)

#### 6. 依赖关系UML

![1620827777826](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620827777826.png)

#### 7. 一般关联关系UML

![1620827947066](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620827947066.png)

#### 8. 组合关系UML

![1620827976361](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620827976361.png)

#### 9. 聚合关系UML

![1620827988535](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1620827988535.png)

### 1.3. 单例模式

某个类只能生成一个实例，该实例被全局访问，比如Spring容器一级缓存里的单例池。

- 优点：唯一访问、提高性能
- 缺点：不适合有状态且需要变更的实例
- 实现方式：**所有方式都会被反序列破坏，但是都可以通过单例对象添加Object#readResolve() 方法, 直接返回单例对象即可防止破坏。**

|                       | 懒加载 | 线程安全 | 其他优点     | 缺点                       | 推荐 |
| --------------------- | ------ | -------- | ------------ | -------------------------- | ---- |
| 饿汉式                | 否     | 是       | 简单、速度快 | 提早占用内存、不可参数构造 | 是   |
| 懒汉式                | 是     | 否       | 可参数构造   | 线程不安全                 | 否   |
| 懒汉式-锁实现         | 是     | 是       | 可参数构造   | 加锁导致效率低下           | 否   |
| 懒汉式-静态内部类实现 | 是     | 是       | -            | 不可参数构造               | 是   |
| 双重检查锁            | 是     | 是       | 可参数构造   | 实现较复杂、可被反射破坏   | 是   |
| 枚举类                | 是     | 是       | 不被反射破坏 | 实现较复杂、不可参数构造   | 是   |

#### 1. 饿汉式

```java
/**
 * 1、饿汉式
 */
public class Singleton1 implements Serializable {
    private static final Singleton1 instance = new Singleton1();

    public static Singleton1 getInstance(){
        return instance;
    }
    
    private Singleton1() {
        // 防⽌反射获取多个对象的漏洞 true
        if(instance != null){
            throw new RuntimeException("获取单例异常!");
        }
    }
    
    // 防止反序列化获取多个对象的漏洞
    private Object readResolve() throws ObjectStreamException {
        return instance;
    }

}
```

#### 2. 懒汉式

```java
/**
 * 2、懒汉式-线程不安全
 */
public class Singleton2 implements Serializable {

    private static Singleton2 instance;// 类初始化为null

    public static Singleton2 getInstance(int code){
        if(instance == null){
            instance = new Singleton2(code);
        }
        return instance;
    }
}
```

#### 3. 懒汉式-锁实现

```java
/**
 * 3、懒汉式-线程安全-锁方法实现
 */
public class Singleton3 implements Serializable {
    
    private static Singleton3 instance;// 类初始化为null

    public static synchronized Singleton3 getInstance(int code){
        if(instance == null){
            instance = new Singleton3(code);
        }
        return instance;
    }
}
```

#### 4. 懒汉式-静态内部类实现

```java
/**
 * 4、懒汉式-线程安全-静态内部类
 */
public class Singleton4 implements Serializable {
    
    private static class Holder {
        private static final Singleton4 SINGLE_TON = new Singleton4();
    }
    
    public static Singleton4 getInstance(){
        return Holder.SINGLE_TON;
    }
}

```

#### 5. 双重检查锁

```java
/**
 * 5、双重检查锁
 */
public class Singleton5 implements Serializable {

    // volatile防止重排序导致实例化未完成
    private volatile static Singleton5 instance;// 必须要保证可见性

    public static Singleton5 getInstance(int code){
        // 第一次减少锁的开销
        if(instance == null){
            synchronized (Singleton5.class){
                // 第二次防止重复
                if(instance == null){
                    instance = new Singleton5(code);
                }
            }
        }

        return instance;
    }
}
```

#### 6. 枚举类

```java
/**
 * 6、枚举(JDK 1.5后)
 */
public class Singleton6 implements Serializable {

    private static enum SingletonEum {
        INSTANCE;// 创建一个枚举类, 天生就是单例的

        private Singleton6 singleton6;

        SingletonEum() {// 创建时创建singleton6单例对象
            singleton6 = new Singleton6();
        }

        public Singleton6 getInstance(){
            return singleton6;
        }
    }

    // 调用getInstance()才使用枚举类, 才对枚举类进行加载, 再枚举类的构造方法中创建了单例
    public static Singleton6 getInstance() {
        return SingletonEum.INSTANCE.getInstance();
    }
}
```

### 1.4. 工厂模式

#### 1. 简单工厂模式

简单工厂模式是**由一个工厂对象决定创建出哪一种产品类的实例**，是工厂模式家族中最简单实用的模式，可以理解为是不同工厂模式的一个特殊实现。

- 组成：
  - 工厂类角色：简单工厂类，即是根据类型创建具体产品，是具体产品的逻辑封装。
  - 抽象产品角色：一般是指具体产品继承的父类或实现的接口。
  - 具体产品角色：具体的实现类，相当于抽象业务的落地。
- 优点：
  - 解耦：实现了对责任的分割，专门的工厂类用于创建产品，客户类免除了除直接创建产品对象的责任，而仅仅是消费产品。
  - 简单：客户类无须知道所创建的具体产品类的类名，只需要知道具体产品类的对应参数即可。
  - 可配置（解决方案）：通过引入配置文件，可以在不修改任何客户类代码的情况下，更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。
- 缺点：
  - 中心化：由于工厂类集中了所有产品的创建逻辑，一旦不能工作, 整个系统都要受到影响。
  - 类爆炸：使用简单工厂模式将会增加系统中类的个数，在一定程度上增加了系统的复杂度和理解度。
  - 不灵活：系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。
  - 不够体系化：由于使用了静态工厂方法，造成了工厂角色无法形成基于继承的等级结构。
- 使用场景：
  - 工厂类负责创建的对象比较少时。
  - 客户类只知道传入工厂的参数，对于如何创建对象逻辑不关心时。
  - 由于简单工厂很容易违反高内聚责任分配原则，因此一般只在很简单的情况下应用。

```java
// 客户类
public class Customer {

    public static void main(String[] args) {
        SimpleFatory simpleFatory = new SimpleFatory();
        simpleFatory.createProduct("HighLvA");
        simpleFatory.createProduct("B");
    }
}

// 抽象接口
public abstract class Product {

    public Product() {

    }
}

// 具体产品实现类
public class ProductA extends Product{

    public ProductA() {
        System.out.println("制造产品A: Product HighLvA...");
    }
}

// 简单工厂类
public class SimpleFatory {

    public Product createProduct(String type){
        switch (type){
            case "HighLvA":
                return new ProductA();
            case "B":
                return new ProductB();
            default:
                break;
        }

        return null;
    }
}
```

#### 2. 工厂方法模式

工厂方法模式的核心思想是**封装类中变化的部分**，提取其中个性化善变的部分为独立类，通过依赖注入以达到解耦、复用和方便后期维护拓展的目的。工厂方法模式是对简单工厂模式的**工厂做了抽象**。

- 组成：
  - 抽象工厂角色：工厂方法模式的核心，是具体工厂角色必须实现的接口或必须继承的父类，也就是对具体工厂的抽象。
  - 具体工厂角色：含有和具体业务逻辑有关的代码, 由客户类指明创建, 用于创建对应具体的产品对象。
  - 抽象产品角色：对比简单工厂模式，抽象逻辑没变。一般是指具体产品继承的父类或实现的接口。
  - 具体产品角色：对比简单工厂模式，抽象逻辑没变。具体的实现类，相当于抽象业务的落地。
- 优点：
  - 去中心化：工厂方法模式去掉了简单工厂模式中工厂的静态属性，使得它可以被子类继承，这样在简单工厂模式里集中在工厂方法上的压力，就可以由工厂方法模式里不同的工厂子类分担。
  - 开闭原则： 当有新的产品产生时，只要按照抽象产品角色、抽象工厂角色提供的合同来生成，那么就可以被客户使用，而不必去修改任何已有的代码。
- 缺点：
  - 类爆炸：在添加新产品时需要编写新的具体产品类，而且还要提供与之对应的具体工厂类。可见系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，而更多的类需要编译和运行，会给系统带来一些额外的开销。
- 使用场景：
  - 对于某种产品，调用者清楚地知道应该使用哪个具体工厂服务，从而实例化该具体工厂，生产出具体的产品。比如Java Collection中的iterator()方法。
  - 只是需要一种产品，而不想知道，也不需要知道究竟是哪个工厂生产的，即最终选用哪个具体工厂的决定权在生产者一方，生产者根据当前系统的情况来实例化一个具体的工厂返回给使用者，而这个决策过程对于**使用者来说是透明的**。

```java
// 客户类
public class Customer {

    public static void main(String[] args) {
        FactoryProductA factoryProductA = new FactoryProductA();
        factoryProductA.createProduct();

        FactoryProductB factoryProductB = new FactoryProductB();
        factoryProductB.createProduct();
    }
}

// 抽象产品类
public abstract class Product {

    public Product() {

    }
}

// 产品实现类
public class ProductA extends Product {

    public ProductA() {
        System.out.println("制造产品A: Product HighLvA...");
    }
}

// 抽象工厂类
public interface AbstractFatory {

    public Product createProduct();
}

// 工厂实现类
public class FactoryProductA implements AbstractFatory{

    @Override
    public Product createProduct() {
        return new ProductA();
    }
}
```

#### 3. 抽象工厂模式

抽象工厂是指当有**多个抽象角色**时使用的一种工厂模式，可以向客户提供提供一个接口，使客户在不必指定产品的具体参数情况下（工厂方法模式），创建**多个产品族中**的产品对象（由于有抽象工厂角色对多个工厂进行聚合, 暴露各种产品生产的接口）。

> 工厂方法模式，针对的是多个产品系列结构（同一个抽象产品角色, 同一个产品族）。
>
> 抽象工厂模式，针对的是多个产品族结构（多个抽象产品角色,多个产品族）。
>
> 一个产品族内有多个产品系列（同一个抽象产品角色, 同一个产品）。

- 核心思想：在抽象工厂中，增加创建其他产品族的生产接口，并在具体子工厂中实现。
- 优点：
  - 抽象工厂：也是工厂方法模式的优点，分离了具体的类，客户通过抽象接口操纵实例，产品的类名也在具体工厂的实现中被分离，它们不出现在客户代码中。
  - 多产品族：易于交换产品系列，只需要改变具体工厂或者调用不同的接口，即可生产不同的产品。
  - 产品一致：有利于产品的一致性，当一个系列的产品对象被设计成一起工作时，抽象工厂很容易实现一个应用一次只能使用同一个系列的对象。
- 缺点：
  - 难以支持新种类的产品：产品族扩展费力，因为抽象工厂接口确定了可以被创建的产品集合，假如产品族需要增加一个新的产品，则几乎所有的工厂类都需要进行修改。因此使用抽象工厂模式时，对产品等级结构的划分非常重要。
- 使用场景：
  - 一个系统要独立于它的产品创建、组合和表示时（无关性）。
  - 一个系统要由**多个产品系列**中的一个来配置时。
  - 需要强调一系列相关的产品对象的设计以便进行联合使用时。
  - 提供一个产品类库, 而只想显示它们的接口而不是实现时。
  - 如果创建的产品是一系列相互关联或者相互依赖的产品组时，可以使用抽象工厂模式。而如果产品间不存在关联或约束时，则使用多个独立的工厂来对产品进行创建，则更适合一点。

```java
// 客户类
public class Customer {

    public static void main(String[] args) {
        FactoryProductA factoryProductA = new FactoryProductA();
        factoryProductA.createProduct();
        factoryProductA.createNewProduct();

        FactoryProductB factoryProductB = new FactoryProductB();
        factoryProductB.createProduct();
        factoryProductB.createNewProduct();
    }
}

// 抽象产品类
public abstract class Product {

    public Product() {

    }
}

// 产品实现类
public class ProductA extends Product {

    public ProductA() {
        System.out.println("制造产品A: Product HighLvA...");
    }

}

// 抽象工厂类
public interface AbstractFatory {

    public Product createProduct();

    public NewProduct createNewProduct();
}

// 工厂实现类
public class FactoryProductA implements AbstractFatory {

    @Override
    public Product createProduct() {
        return new ProductA();
    }

    @Override
    public NewProduct createNewProduct() {
        return new NewProductA();
    }
}
```

### 1.5. 策略模式

定义一组算法，将**每一种算法**封装起来，从而使它们可以相互切换。

- 组成：
  - 策略封装角色：上层访问策略入口，持有抽象策略的引用（聚合关系）。
  - 抽象策略角色：提供接口或抽象类，定义策略组必须拥有的方法和属性。
  - 具体策略角色：实现抽象策略，定义具体的算法逻辑。
- 优点：
  - 重用：策略模式提供了管理相关**算法族**的方法，其等级结构定义了一个算法或者行为族，恰当使用继承和接口可以把公共的代码进行抽取，避免代码重复。
  - 减少嵌套：if-else语句不易维护，使用策略模式可以避免使用多重条件if-else语句。如果把采取哪一种算法或行为的逻辑与算法或行为本身的逻辑混合在了一起，统统列在一个语句里面，那这样比使用继承的办法还要原始和落后。
- 缺点：
  - 算法列表：客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择适当的算法类，因此，策略模式只适用于客户端知道算法或者行为的情况。
  - 类爆炸：由于策略模式把每个具体的策略实现都单独封装成类，如果备选的策略很多，那么对象的数目就会很可观。

```java
// 客户类
public class Client {

    public static void main(String[] args) {
        Context context = new Context(new StrategyB());
        context.useStrateyAlgorithmLogic();
    }
}

// 策略封装上下文对象
public class Context {

    private Strategy strategy;

    public Context(Strategy strategy) {
        this.strategy = strategy;
    }

    /**
     * 调用策略
     */
    public void useStrateyAlgorithmLogic(){
        strategy.algorithmLogic();
    }
}

// 策略抽象接口
public interface Strategy {

    // 具体算法逻辑
    public void algorithmLogic();
}

// 具体策略A
public class StrategyA implements Strategy{

    @Override
    public void algorithmLogic() {
        System.out.println("这是策略A...");
    }
}
```

### 1.6. 命令模式

将一个请求封装为一个对象，从而可以使用不同的请求对客户进行**参数化、请求排队、记录请求日志、命令撤销**等操作。

- 特点：当需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个时使用命令模式时使用，可以使得请求发送者与请求接收者相解耦。
- 组成：
  - 抽象命令类：Command，抽象出命令对象，可以根据不同的命令类型，写出不同的实现类。
  - 具体命令类：ConcreteCommand，实现了抽象命令对象的具体实现。
  - 调用者/请求者：Invoker，请求的发送者，通过命令对象来执行请求。一个调用者并不需要在设计时确定其接收者，因此它只与抽象命令之间存在关联。
  - 接收者：Receiver，执行与请求相关的操作，真正执行命令的对象，具体实现对请求业务的处理。
  - 客户类：Client，在客户类中创建调用者对象，具体命令类对象，在创建具体命令对象时指定对应的接收者。
- 优点：
  - 解耦：可以降低系统的耦合度。
  - 易用：可以容易地将新的命令加入到系统中。
  - 设计方便：可以容易地设计一个命令队列和宏命令（组合命令）。
  - 可撤销与重试：可以方便地实现对请求的Undo和Redo。
- 缺点：
  - 类爆炸：由于针对每一个命令都需要设计一个具体命令类，所以在使用命令模式时，可能会导致某些系统有过多的具体命令类。当某些系统可能需要大量具体命令类时，将会影响命令模式的使用。
- 使用场景：
  - 网络传输：命令的调用者和命令执行者之间存在不同的生命周期，意味着命令发送了并不是立即执行。即命令发送出去后，原先的请求发出者可能已经不存在了，而命令对象本身还在，可以通过网络传输到另一台机器，给执行者执行。比如, Struts2中的action调用。
  - 统一管理：命令需要进行各种管理逻辑，比如对多个命令的统一控制。
  - 撤销重试：系统需要支持撤销（反撤销)）或者重试操作时。命令对象可以把状态存储起来，等到客户端需要撤销命令所产生的效果时，可以调用undo（）方法，把命令所产生的效果撤销掉。命令对象还可以提供redo()方法，以供客户端在需要时再重新实施命令效果。比如数据库中的事务机制底层实现。
  - 回调：回调callBack（）系统的使用，其中callBack（）讲的就是先将一个函数登记上，然后在以后调用此函数。
  - 命令日志：将系统中所有命令记录在日志里，待系统奔溃时，可以根据日志中一条一条命令重新调用execute（）， 从而恢复系统在崩溃前所做的数据更新。

```java
// 客户类
public class Client {

    public static void main(String[] args) {
        Receiver receiver = new Receiver();
        RemoteInvoker remoteInvoker = new RemoteInvoker(new TurnUpCommand(receiver), new TurnDownCommand(receiver));

        // 操作遥控器
        remoteInvoker.turnDownButton();
        remoteInvoker.turnUpButton();
        remoteInvoker.undoButton();
        remoteInvoker.undoButton();
        remoteInvoker.redoButton();
        remoteInvoker.redoButton();
    }
}

// 接收者实现类-电视机
public class Receiver {

    public void turnUp(){
        System.out.println("跳转到上一个台...");
    }

    public void turnDown(){
        System.out.println("跳转到下一个台...");
    }
}

// 请求发送实现类-遥控器
public class RemoteInvoker {

    private Command turnUpCommand;
    private Command turnDownCommand;

    private Stack<Command> undoCommadStack;
    private Stack<Command> redoCommadStack;

    public RemoteInvoker(Command turnUpCommand, Command turnDownCommand) {
        this.turnUpCommand = turnUpCommand;
        this.turnDownCommand = turnDownCommand;

        undoCommadStack = new Stack<>();
        redoCommadStack = new Stack<>();
    }

    // 遥控器-切上一个台的按钮实现
    public void turnUpButton(){
        turnUpCommand.execute();
        undoCommadStack.push(turnUpCommand);
        if(!redoCommadStack.isEmpty()){
            redoCommadStack.clear();
        }
    }

    // 遥控器-切下一个台的按钮实现
    public void turnDownButton(){
        turnDownCommand.execute();
        undoCommadStack.push(turnDownCommand);
        if(!redoCommadStack.isEmpty()){
            redoCommadStack.clear();
        }
    }

    // 遥控器-undo按钮实现
    public void undoButton(){
        if(!undoCommadStack.isEmpty()){
            Command command = undoCommadStack.pop();
            command.undo();
            redoCommadStack.push(command);
        }else {
            System.out.println("按钮无效...");
        }
    }

    // 遥控器-redo按钮实现
    public void redoButton(){
        if(!redoCommadStack.isEmpty()){
            redoCommadStack.pop().execute();
        }else {
            System.out.println("按钮无效...");
        }
    }
}

// 命令接口
public interface Command {

    // 执行命令
    public void execute();

    // 撤销命令
    public void undo();
}

// 转上一个台具体命令
public class TurnUpCommand implements Command{

    private Receiver receiver;

    public TurnUpCommand(Receiver receiver) {
        this.receiver = receiver;
    }

    @Override
    public void execute() {
        receiver.turnUp();
    }

    @Override
    public void undo() {
        receiver.turnDown();
    }
}

// 转下一个台具体命令
public class TurnDownCommand implements Command{

    private Receiver receiver;

    public TurnDownCommand(Receiver receiver) {
        this.receiver = receiver;
    }

    @Override
    public void execute() {
        receiver.turnDown();
    }

    @Override
    public void undo() {
        receiver.turnUp();
    }
}
```

### 1.7. 代理模式

为其他对象**提供一种代理**，以控制对这个对象的访问。在某种情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到**中介**的作用。

- 组成：
  - 抽象角色：通过接口或者抽象类声明真实角色实现的业务方法。
  - 代理角色：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法，来实现抽象方法（持有真实角色对象的引用），并可以附加自己的操作。
  - 真实角色：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。
- 分类：
  - 静态代理：静态代理，是由程序员创建或者工具生成代理类的源码，再在编译生成代理类。所谓静态，也就是程序运行前就已经存在**代理类的字节码文件**，这时代理类和委托了类的关系在运行前就确定了。
  - 动态代理：动态代理在实现阶段不用关心代理类，而在**运行阶段**才指定哪一个对象。
    - 分类：JDK动态代理、CGLIB动态代理。
    - [2.6. 动态代理？](#2.6. 动态代理？)
- 优点：
  - 职责清晰：真实角色就是实现实际业务逻辑的，不用去关心其他非本职的业务。而通过后期的代理去完成那些非真实角色本职的业务，编程简洁清晰。
  - 保护目标对象：在客户端和目标对象中间存在代理对象，起到中介以及保护目标对象的作用。
  - 高扩展性：符合开闭原则，代理类的实现不是通过修改原有的代码，而是通过扩展的方式，织入新的业务代码。符合对修改关闭，对扩展开放的原则。

```java
// 客户类(静态代理)
public class Client {

    public static void main(String[] args) throws Throwable {
        UserService userService = new UserServiceImplStaticProxy(new UserServiceImpl());
        userService.save();       
    }
}

/**
 * 抽象角色: 用户服务接口
 */
public interface UserService {

    public void save();
}

/**
 * 真实角色: 用户服务接口实现类
 */
public class UserServiceImpl implements UserService {

    @Override
    public void save() {
        System.out.println("保存用户信息...");
    }
}

/**
 * 代理角色: 用户服务实现静态代理类
 */
public class UserServiceImplStaticProxy implements UserService{

    private UserService userService;

    public UserServiceImplStaticProxy(UserService userService) {
        this.userService = userService;
    }

    @Override
    public void save() {
        System.out.println("静态代理前...");
        userService.save();
        System.out.println("静态代理后...");
    }
}
```

### 1.8. 模板方法模式

定义一个操作中算法的骨架，将一些步骤延迟到子类中，使得子类可以不改变算法结构即可**重定义**该算法的某些特定步骤。

- 组成：
  - 抽象父类：实现了模板方法，定义了算法的骨架。
  - 具体类：实现抽象类的抽象方法，即不同对象实现不同的具体细节。
- 优点：
  - 灵活：具体细节步骤实现定义在子类中，子类定义详细处理算法不会改变算法整体结构。
  - 代码复用：代码复用的基本技术，在数据库设计中尤为重要。
  - 开闭原则：存在一种反向的控制结构，通过一个父类调用其子类的操作，通过子类对父类进行扩展增加新的行为，符合开闭原则。
- 缺点：
  - 类爆炸：每个不同的实现都需要定义一个子类，会导致类的个数增加，系统更加庞大。
- 使用场景：Spring、JDBC等各种框架中均有使用。

```java
// 客户类
public class Client {

    public static void main(String[] args) {
        /**
         * 模板方法模式:
         * a. 假设做菜有3步: 备料、做菜、上菜, 这三步是算法的骨架
         * b. 然后做不同菜需要不同的料, 做时不同的方法, 以及如何盛装给客人, 这些就是不同的实现细节
         */
        // 番茄炒蛋
        DodishTemplate eggsWithTomato = new EggsWithTomato();
        eggsWithTomato.dodish();

        // 红烧肉
        DodishTemplate braisedPork = new BraisedPork();
        braisedPork.dodish();
    }
}

// 抽象角色: 做菜的抽象父类
public abstract class DodishTemplate {

    /**
     * 做菜, 定义算法骨架
     */
    protected void dodish(){
        this.preparation();
        this.doing();
        this.carriedDishes();
    }

    /**
     * 备菜
     */
    protected abstract void preparation();

    /**
     * 做菜
     */
    protected abstract void doing();

    /**
     * 上菜
     */
    protected abstract void carriedDishes();
}

// 具体角色: 番茄炒蛋
public class EggsWithTomato extends DodishTemplate{

    @Override
    protected void preparation() {
        System.out.println("洗并切西红柿, 打鸡蛋...");
    }

    @Override
    protected void doing() {
        System.out.println("鸡蛋倒入锅里, 然后倒入西红柿一起炒...");
    }

    @Override
    protected void carriedDishes() {
        System.out.println("将炒好的西红寺鸡蛋装入碟子里, 端给客人吃...");
    }
}
```

### 1.9. 复合模式（MVC模式）

将多个模式结合起来形成一个框架，以解决一般性问题，在形式上，**复合模式是多个模式的结合**。

- 使用场景：
  - MVC就是典型的多个模式结合：
    - 观察者模式：V和C都是M的观察者，Model的状态更新要及时通知V更新视图，或者通知C做相应逻辑处理。
    - 策略模式：C是V的策略，所以V包含的控制逻辑就是选择策略，也就是选择控制器Controller。
    - 组合模式：V的自身实现应用了组合模式，即调用顶层容器的repaint方法，容器内的所有组件都会进行重绘。
  - MVC应用了多个模式，并能够较好的解决设计上的一般性问题，所以被成为复合模式。但应用复合模式的框架远不止MVC一个。

### 2.0. 适配器模式

定义一个包装类，用于**包装不兼容接口的对象**。把一个类的接口变换成客户端所期待的另一种接口，从而使原本接口不匹配而无法工作的两个类能够一起工作。

- 组成：
  - 包装类：适配器Adapter。
  - 被包装对象：适配器Adaptee，即被适配的类。
- 分类：
  - 类的适配器模式：
    - 特点：使用对象继承的方式实现，是静态的定义方式。
    - 优点：使用方便，代码简化，仅仅引入一个对象，并不需要额外地字段来引用Power实例。
    - 缺点：高耦合，灵活性低。在需要同时适配源类和其子类时，由于类的适配器不能和Adaptee子类一起工作，所以选择对象的适配器比较合适。
  - 对象的适配器模式：
    - 特点：使用对象组合的方式，是动态组合的方式。
    - 优点：灵活性高、低耦合。
    - 缺点：使用复杂、需要引入对象实例。在需要重新定义Adaptee部分行为时，由于类适配器可以重定义Adaptee部分行为，相当于子类覆盖父类的部分实现方法，所以选择类的适配器比较合适。

```java
// 客户类
public class Client {

    public static void main(String[] args) {
        // 获取进口电视机
        ImportedTv importedTv = new ImportedTv();
        
        // 类的适配器模式
        // 获取电视机电源适配器(实际上是一个电视机插头, 但也是个电源)
        TvPlug tvPlug = new PowerAdapter();
        // 开始转换电压
        tvPlug.converTo110v();
        // 开启电视机
        importedTv.work();
        
        // 对象的适配器模式
        // 获取新的电视机电源适配器(实际上是一个电视机插头, 但也是个电源)
        NewPowerAdapter newPowerAdapter = new NewPowerAdapter(new Power());
        // 开始转换电压
        newPowerAdapter.converTo110v();
        // 开启电视机
        importedTv.work();
    }
}

// 进口电视机
public class ImportedTv {

    public void work(){
        System.out.println("电视机正在开启...");
    }
}

// 被包装对象：电视机插头
public interface TvPlug {

    public void converTo110v();
}

// 被包装对象：电源
public class Power {

    public void supply220v(){
        System.out.println("提供220v电源...");
    }
}

// 包装对象：类的适配器模式-电视机电源适配器
public class PowerAdapter extends Power implements TvPlug {

    @Override
    public void converTo110v() {
        super.supply220v();
        System.out.println("开启转换电压...");
    }
}

// 包装对象：对象的适配器模式-电视机电源适配器
public class NewPowerAdapter implements TvPlug{

    private Power power;

    public NewPowerAdapter(Power power) {
        this.power = power;
    }

    public void converTo110v() {
        power.supply220v();
        System.out.println("开启转换电压...");
    }
}
```

### 2.1. 装饰者模式

通过创建一个包装对象，也就是用装饰来包裹真实的对象，在不必改变原类文件和使用继承的情况下，**动态地扩展**一个对象的功能。

- 特点：
  - 装饰对象和真实对象具有相同的接口，这样客户端对象就能以和真实对象相同的方式和装饰对象交互了。
  - 装饰对象包含一个真实对象的引用。
  - 装饰对象接收所有来自客户端的请求，它把这些请求转发给真实的对象。
  - 装饰对象可以在转发这些请求以前或者以后增加一些附加功能，这样就确保了在运行时，不用修改指定对象的结构就可以在外部增加附加的功能。
- 组成：
  - 顶层抽象父类：具有最一般的特性，是真实对象以及装饰组件的共同抽象。
  - 真实对象：代表的是具有业务意义的，能被修饰的底层对象。
  - 组件抽象父类：具有装饰组件的一般性，是装饰组件的抽象。
  - 包装对象：代表的是能够装饰真实对象的组件，实现了组件抽象父类。
- 优点：
  - 灵活：装饰者模式与继承关系的目的都是扩展对象功能，但是装饰者模式可以提供比继承更多的灵活性。
  - 高扩展：通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合。
- 缺点：
  - 复杂：这种比继承更加灵活机动的特性，也同时意味着更多的复杂性。
  - 类爆炸：装饰者模式会导致设计中出现许多小类，如果过度使用，会使程序变得很复杂。
- 使用场景：
  - 需要扩展一个类的功能，或者给一个类添加附加职责。
  - 需要动态地给一个对象添加功能，这些功能可以再动态的撤销。
  - 需要增加由一些基本功能的排列组合而产生了非常大量的功能，而如果使用继承关系变得不现实。比如JDK中的IO类便使用了装饰者模式，其中的InputStream是顶层抽象父类，FilterInputStream是组件抽象父类。

```java
// 客户类
public class Client {

    public static void main(String[] args) {
        /**
         * 开始下单
         */
        // 要一杯 深焙咖啡, 摩卡, 奶泡
        Beverage beverage1 = new DarkRoast();
        beverage1 = new Mocha(beverage1);
        beverage1 = new Whip(beverage1);
        System.out.println(getDescAndCost(beverage1.getDescription(), beverage1.cost()));
    }

    public static String getDescAndCost(String desc, BigDecimal cost){
        return String.format("Description: %s, $%f", desc, cost);
    }
}

// 顶层抽象父类-饮料抽象类
public abstract class Beverage {

    private String description = "Unkown Beverage";

    /**
     * 获取饮料描述-子类中重写
     * @return
     */
    public String getDescription() {
        return description;
    }

    /**
     * 获取饮料价格-子类中实现
     * @return
     */
    public abstract BigDecimal cost();
}

// 真实对象：深焙咖啡类-一种具体的饮料
public class DarkRoast extends Beverage {

    @Override
    public String getDescription() {
        return "深焙咖啡";
    }

    @Override
    public BigDecimal cost() {
        return new BigDecimal("3.00");
    }
}

// 组件抽象父类-因为调料叠加以后也是一种饮料, 所以能继承饮料抽象类
public abstract class CondimentDecorator extends Beverage {

    /**
     * 所有的具体调料装饰者都必须实现getDescription(), 这样才能够用递归的方式来得到所选饮料的整体描述
     * @return
     */
    public abstract String getDescription();
}

// 包装对象-摩卡调料类-一种具体的调料
public class Mocha extends CondimentDecorator {

    /**
     * 持有一个具体饮料的引用
     */
    private Beverage beverage;

    public Mocha(Beverage beverage) {
        this.beverage = beverage;
    }

    @Override
    public String getDescription() {
        return beverage.getDescription() + ", 摩卡";
    }

    @Override
    public BigDecimal cost() {
        return new BigDecimal("0.2").add(beverage.cost());
    }
}

// 包装对象-奶泡调料类-一种具体的调料
public class Whip extends CondimentDecorator {

    /**
     * 持有一个具体饮料的引用
     */
    private Beverage beverage;

    public Whip(Beverage beverage) {
        this.beverage = beverage;
    }

    @Override
    public String getDescription() {
        return beverage.getDescription() + ", 奶泡";
    }

    @Override
    public BigDecimal cost() {
        return new BigDecimal("0.4").add(beverage.cost());
    }
}
```

### 2.2. 观察者模式

一个目标物件管理所有相依于它的观察者物件，并且在它本身的**状态改变**时主动发出通知，透过呼叫各观察者所提供的方法来实现，通常被用来实现事件处理系统。

- 特点：
  - 当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新，完美地将观察者模式和被观察者的对象分离开，在模块之间划定了清晰的界限，提高了应用程序的可维护性和重用性。
  - 将一个系统分割成一些类相互协作的类有一个不好的副作用，那就是需要维护相关对象之间的一致性，当不希望为了维持一致性，而使各类紧密耦合导致会给维护、扩展和重用都带来不便时，可以使用观察者模式来解决这类耦合关系。
- 组成：
  - 抽象主题：Subject，抽象主题提供一个接口，可以增加和删除观察者对象。它把所有观察者对象的引用保存到一个聚集里，每个主题都可以有任意数量的观察者。
  - 具体主题：Concrete Subject，将有关状态存入具体观察者对象，在具体主题内部状态改变时，给所有登记过的观察者发出通知。
  - 抽象观察者：Observer，为所有具体的观察者定义一个接口，在得到主题通知时更新自己。
  - 具体观察者：Concrete Observer，实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题状态协调。
- 优点：
  - 解耦：观察者模式解除了主题和具体观察者的耦合，让耦合的双方都依赖于抽象，不依赖具体，从而使得各自的变化都不会影响另一边的变化。
- 缺点：
  - 需考虑异步：在应用观察者模式时需要考虑以下开发短路问题，程序中包括一个被观察者和多个观察者，开发和调试比较复杂，而且Java中的消息通知默认是顺序执行的，一个观察者的卡顿会影响整体的执行效率，因此，在这种情况下，一般考虑采用异步的方式。
  - 需考虑进一步解耦：如果依赖关系未完全解除，如抽象通知者依旧依赖抽象的观察者，这时可以采用委托的方式（引用方法类型）来解决。
- 使用场景：
  - 当一个抽象模型有两个方面，其中一个方面依赖于另一个方面，需要将二者封装在独立的对象中，以使它们可以各自独立地改变和复用时。
  - 当一个对象的改变需要同时改变其他对象，但又不知道具体有多少对象需要改变时。
  - 当一个对象必须通知其他对象，但它又不知道其他对象是谁时，也就是希望这些对象之间不是紧密耦合的。

```java
// 客户类
public class Client {
    public static void main(String[] args) {
        CustomerA customerA = new CustomerA();
        customerA.addObserver(new Cashier(customerA));
        customerA.addObserver(new Accountant(customerA));
        customerA.addObserver(new Dilliveryman(customerA));
        customerA.payOrder();
    }
}

// 客户主题抽象类
public abstract class CustomerSubject {

    private Vector<JobStation> observers = new Vector<>();

    private String state;

    public void addObserver(JobStation jobStation){
        observers.add(jobStation);
    }

    public void removeObserver(JobStation jobStation){
        observers.remove(jobStation);
    }

    public abstract void payOrder();

    public Vector<JobStation> getObservers() {
        return observers;
    }

    public String getState() {
        return state;
    }

    public void setState(String state) {
        this.state = state;
    }
}

// 具体主题类：具体客户类A
public class CustomerA extends CustomerSubject {

    @Override
    public void payOrder() {
        super.setState("已付款");
        System.out.println("我是用户, 我已经完成订单付款...");
        for(JobStation jobStation : super.getObservers()){
            jobStation.updateJobState();
        }
    }
}

// 抽象观察者: 工作岗位接口
public interface JobStation {

    public void updateJobState();
}

// 具体观察者：出纳工作人员
public class Cashier implements JobStation{

    private String state;

    private CustomerSubject customerSubject;

    public Cashier(CustomerSubject customerSubject) {
        this.customerSubject = customerSubject;
    }

    @Override
    public void updateJobState() {
        if(customerSubject.getState().equals("已付款")){
            this.state = "已入账";
            System.out.println(String.format("我是出纳员, 我来登记入账 => %s.", this.state));
        }
    }
}
```

### 2.3. 建造者模式

将一个复杂对象的**构造与他的表示分离**，使同样的构建过程可以创建不同的表示。

- 特点：
  - 将一个复杂的对象分解为多个简单的对象，然后一步步构建而成，它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。
  - 当需要创建的产品具备复杂创建过程时，可以抽取公共创建过程，然后交由具体实现类自定义创建流程， 使得同样得创建行为可以生产出不同的产品，分离了创建与表示，使创建的产品灵活性大大增加。
- 组成：
  - 指挥者：Director，它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体的产品信息。
  - 抽象构造者：Builder，它是一个包含创建产品各个子部分的抽象方法的接口，通常还包含一个返回复杂产品的getResult()方法。
  - 具体构造者：Concrete Builder，实现Builder接口，完成复杂产品的各个部件的具体方法。
  - 产品：它是包含多个部件的复杂对象，由具体建造者来创建其各个零部件。
- 过程：

1. 指挥者Director直接和客户Client进行需求沟通。
2. 沟通后，指挥者将客户创建产品的需求划分为各个部件的建造请求Builder。
3. 将各个部件的建造请求委派到具体的建造者ConcreteBuilder。
4. 各个具体建造者ConcreteBuilder负责进行产品部件的构建。
5. 最终构建成具体产品Product。

- 优点：
  - 封装性好：构建和表示分离，即同样的构建过程能取到不同的表示。
  - 扩展性好：各个具体的构造者独立，有利于系统的解耦。
  - 易用：客户端不必知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其他模块产生任何影响，便于控制细节风险。
  - 灵活：改造多参数构造对象可以使得传递参数更加灵活，代码具有更高的可读性。
- 缺点：
  - 范围限制：产品的组成部分必须相同，这限制了其使用范围。
  - 维护成本高：如果产品的内部变化复杂，当产品内部发生变化时，则建造者也要同步修改，后期维护成本较大。
- 使用场景：
  - 相同的方法，当有不同的执行顺序时，产生不同的结果时。
  - 多个部件零件，都可以装配到一个对象中，但是产生的结果又不相同时。
  - 产品类非常复杂，或者产品类中不同的调用顺序产生不同的作用时。
  - 初始化一个对象特别复杂，参数多， 而且很多参数都具有默认值时。
- 建造者模式 VS 工厂模式：
  - 建造者模式注重零部件的**组装过程**，而工厂模式更注重零部件的**创建过程**，但两者可以结合使用。
  - 建造者模式注重方法的**调用顺序,** 而工厂模式注重**创建对象**。
  - **创建对象的方式不同**：建造者模式通过指挥类来指导如何生成对象，包括对象的组装过程和构造步骤。而工厂模式是通过客户端实例化工厂类，然后调用工厂方法获取所需的产品对象。
  - **关注重点不一样**：建造者模式不仅要创建出对象，还要知道对象由哪些部件组成。而工厂模式只需要把对象创建出来就可以了。
  - **创建对象的粒度不同**：建造者模式创建复杂对象，由各种复杂的部件组成，建造顺序不同最终对象部件也会不一样。而工厂模式创建出来的对象都一样或者是一系列的产品族。
  - 如果将抽象工厂模式看成**汽车配件生产工厂**，生产一个产品族的产品，那么建造者模式就相当于一个**汽车组装工厂**，通过对部件的组装生成出一辆完整的汽车。

```java
// 客户类
public class Client {

    public static void main(String[] args) {
        Director directorA =  new Director(new ConcreteBuildA());
        Director directorB =  new Director(new ConcreteBuildB());

        // 获取产品A
        directorA.assembledProduct();

        // 获取产品B
        directorB.assembledProduct();
    }
}

// 指挥者类
public class Director {

    private Builder builder;

    public Director(Builder builder) {
        this.builder = builder;
    }

    // 组装产品
    public Product assembledProduct(){
        builder.buildNilProduct();
        builder.buildPartA();
        builder.buildPartB();
        builder.buildPartC();
        return builder.getProduct();
    }
}

// 抽象Builder类
public abstract class Builder {

    // 构造空属性产品
    protected Product product;

    public abstract void buildPartA();

    public abstract void buildPartB();

    public abstract void buildPartC();

    // 获取产品
    public void buildNilProduct() {
        this.product = new Product();
    }

    // 获取产品
    public Product getProduct() {
        return product;
    }
}

// 具体建造者类A
public class ConcreteBuildA extends Builder{

    @Override
    public void buildPartA() {
        if(super.product == null){
            throw new RuntimeException("请先构建空产品");
        }

        super.product.setPartA("我是A Part A.");
        System.out.println("A建造者建造了Part A...");
    }

    @Override
    public void buildPartB() {
        if(super.product == null){
            throw new RuntimeException("请先构建空产品");
        }

        super.product.setPartB("我是A Part B.");
        System.out.println("A建造者建造了Part B...");
    }

    @Override
    public void buildPartC() {
        if(super.product == null){
            throw new RuntimeException("请先构建空产品");
        }

        super.product.setPartC("我是A Part C.");
        System.out.println("A建造者建造了Part C...");
    }
}

// 产品类
public class Product {

    private String partA;
    private String partB;
    private String partC;

    public String getPartA() {
        return partA;
    }

    public void setPartA(String partA) {
        this.partA = partA;
    }

    public String getPartB() {
        return partB;
    }

    public void setPartB(String partB) {
        this.partB = partB;
    }

    public String getPartC() {
        return partC;
    }

    public void setPartC(String partC) {
        this.partC = partC;
    }
}
```



## **5. Java基础**

### 1.1. 面向对象三大特性？

**封装、继承、多态**

- **封装**：对抽象的事物抽象化成一个对象，并对其对象的属性私有化，同时提供一些能被外界访问属性的方法。
- **继承**：子类扩展新的数据域或者功能，并复用父类的属性与功能，单继承、多实现。
- **多态**：通过继承（多个子类对同一方法的重写），也可以用过接口（实现接口）。

### 1.2. Java与C++的区别？

Java和C++都是面向对象语言，都能够实现面向对象思想（即**封装、继承、多态**）。

|          | Java                         | C++                |
| -------- | ---------------------------- | ------------------ |
| 继承     | 单继承，可通过接口实现多继承 | 多继承             |
| 访存     | 不提供指针直接访存           | 有指针的概念       |
| 内存管理 | JVM自动管理                  | 程序员需要手动管理 |

### 1.3. 多态是什么？

多态，按字面意思就是多种状态。**在面向对象语言中，接口的多种不同实现方式即为多态，允许将基类的指针或者引用指向派生类的对象，在具体访问时实现方法的动态绑定。**

- 条件：
  - 多态建立在继承的基础上，先有继承才能有多态。
  - 多态另一个条件是，在创建子类时必须使用父类指针以及new实际的子类类型。

### 1.4. static和final关键字？

- **static**：可以修饰属性和方法
  - 修饰属性：
    - 代表类级别属性，所有对象共享一份，随着类的加载而加载，只加载一次，先于对象的创建。
    - 可以使用类名直接调用。
  - 修饰方法：
    - 随着类的加载而加载。
    - 可以使用类名直接调用。
    - 在静态方法中，只能调用静态的成员，以及不可以使用this。
- **final**：最要用于变量、方法、类。
  - 修饰变量：
    - 如果变量是基本数据类型，则其数值一旦在初始化后就不能更改了。
    - 如果是引用类型的变量，则其在初始化后就不能更改指向的对象了。
  - 修饰方法：
    - 锁定方法，防止任何继承类重写其含义（类中所有的private方法都隐式地指定为了final修饰）。
  - 修饰类：
    - 表名这个类不能被继承，其中该类中的所有成员、方法都会被隐式地指定为final修饰。
    - *另：要使一个类不能被继承，除了final关键字外，还可以私有化构造器（不能继承内部类）。*

### 1.4. 抽象类和接口？

- **抽象类**：
  - 包含抽象方法的类，使用abstract修饰。
  - 抽象类不能被实例化。
  - 抽象类只能被继承，所以不能使用final修饰。
  - 使用场景：既想约束子类具有共同的行为，不在乎其如何实现，又想拥有缺省的方法以及拥有实例变量时。
- **接口**：
  - 是一个抽象类型，是抽象方法的集合。
  - 支持多继承，接口中定义的方法默认是public abstract修饰的抽象方法。
  - 使用场景：想要约束多个实现类具有统一行为，不在乎每个实现类如何实现，又想实现类各个功能之间可以没有任何联系（多继承）时。
- 相同点：都不能被实例化、都可以定义抽象方法，靠子类/实现类实现抽象方法。
- 不同点：

| 抽象类                     | 接口                                      |
| -------------------------- | ----------------------------------------- |
| 有构造方法                 | 没有构造方法                              |
| 可以包含普通方法           | JDK7前只能是"抽象方法"                    |
| 只能单继承                 | 支持多继承                                |
| 可以定义各种类型的成员变量 | 只能定义public static final修饰的静态常量 |

### 1.5. 泛型和泛型擦除？

泛型的本质是**参数化类型**。

- 使用方式：可以用在类、接口和方法上，分别成为泛型类、泛型接口和泛型方法，还可以用在方法的参数和返回值上（此时该方法只是普通方法）。
  - 泛型类：
    - 当指定了泛型类型，整个类泛型都必须同一类型。
    - 没有指定泛型类型，整个类可以为任意类型（Object类型）。
  - 泛型接口：
    - 实现泛型接口时，当接口指定泛型类型时，实现类必须保持相同的泛型类型。
    - 当接口没指定泛型类型时，实现类可以不指定泛型类型（Object类型）。
  - 泛型方法：
    - 在修饰符和返回值之间的位置，声明了泛型的才是泛型方法。
    - 而只使用泛型类型参数和返回值的，只是普通方法。
  - 泛型通配符：
    - 泛型的上限：<? extends 类型>，作为实参传递时，只能传递子类及本类类型。
    - 泛型的下限：<? super 类型>，作为实参传递时，只能传递父类级本类类型。
  - 泛型数组：
    - 不可以创建一个确切泛型类型的数组，比如不能List<String>[] ls = new ArrayList<String>[10];
    - 但可以创建一个确切通配符类型的数组，且获取时必须进行类型转换。比如可以List<?>[] ls = new ArrayList<?>[10];
- **泛型擦除**：
  - Java的泛型是伪泛型，使用泛型的时需要加上类型参数，在编译器编译生成字节码时会被去掉，这个过程称为泛型擦除。
  - 比如List<String>类型，在编译之后都会 成为List类型，JVM看到的只是List，因此泛型附加的类型信息对JVM来说是不可见的，**只在编译期间有效，在运行期间无效**。
- **泛型优点**：
  - 可以指定类型，不用强转，代码简洁，提高了编码期间的可读性
  - 保证集合中存的元素都是同一类型的元素，程序更加健壮。
- 桥接方法：
  - 概念：在子类继承泛型父类或者实现泛型接口，并且指定了泛型类型时，编译器会自动在子类中生成桥接方法。
  - 原因：如果不生成桥接方法，在泛型擦除后，父类类型变为了Object类型，而子类方法参数还是指定的类型，此时就不算实现父类或者接口方法了。因此，为了**维持多态性**，会在子类中生成Object类型的桥接方法，其实现是把Object参数强转成指定的类型，方便指向具体的实现方法。

```java
/**
 * 泛型类
 */
public class MyGeneric<T> {

    private T genericCode;

    // 静态方法-不含泛型
    public static void main(String[] args) {

    }

    // 静态泛型方法-含泛型
    public static <E> E test(E args) {
        return args;
    }

    // 构造方法-使用类的泛型
    public MyGeneric(T genericCode) {
        this.genericCode = genericCode;
    }

    // 普通方法-使用类的泛型
    public T getGenericCode() {
        return genericCode;
    }

    // 普通方法-使用类的泛型
    public void setGenericCode(T genericCode) {
        this.genericCode = genericCode;
    }
}
```

### 1.6. Java异常体系？

![1621048569059](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1621048569059.png)

- **Throwalbe**：Java中所有错误或者异常的超类。
- **Error**：指Java运行时系统内部的错误以及资源耗尽的错误。应用程序不会抛出该类对象，如果出现这样的错误，除了告知用户，剩下的就是尽力使程序安全地终止。
- **Exception**：
  - **RuntimeException**：运行时异常，程序应该从逻辑角度尽可能避免这类异常的发生。
  - **非运行时异常**：这类异常必须使用try-catch进行捕捉处理，否则编译器报错。比如IOExceptin、SQLException。

### 1.7. 反射原理以及使用场景？

指在运行状态中，对于任意一个类，都能够知道这个类所有的属性和方法，并且都能够调用它的任意一个方法。

- 原理：首先获取反射类的字节码，然后将字节码中的方法、变量、构造函数等映射成相应的Method、Field、Constructor等对象。
- 反射类Class对象获取方式：
  - **类名.class**：Class personClazz = Person.class，就一份字节码，所以是同一个Class对象。
  - **Object#getClass（）**：每一个对象都有getClass（）方法，用于返回对象真实的Class对象（对象的元数据）。
  - **Class.forName（String）**：根据一个类的权限定名来构建Class对象。
- 使用场景：通用框架开发、动态代理、自定义注解。

### 1.8. Java构造方法？

构造方法，也叫构造函数，是Java中一种特殊的函数，函数名与类名相同，无返回值。

- 一般用于**初始化成员属性和成员方法**，在对象创建时运行，只运行一次。
- 构造方法可以被重载，只有当类中没有显式声明任何构造方法时，才会有默认的无参构造方法。

### 1.9. Java初始化块？

代码初始化块是类的成员之一，每次类的创建会隐式调用它，本质上是一个代码块或者方法体。

初始化块分为**静态初始化块**和**非静态初始化块**，其好处是减少多个构造器内重用的代码。

- **静态初始化**块优先级最高，会在类第一次被加载时最先执行（也在main方法前），在**非静态初始化块**之前执行。

### 2.0. Java this关键字？

- 关键字this代表**当前对象的引用**：当前对象指的是调用类中的属性或者方法的对象。
- 关键字this不可以在静态方法中使用：因为静态方法不依赖于当前类的实例。

### 2.1. 重载与重写的区别？

- **重载**：指可以在同一个类中定义多个同名方法，但要求参数列表不同，与方法返回值无关。成员方法和构造方法都可以进行重载，可以通过重载构造方法来实现多种初始化行为。重载要求如下：
  - 方法必须都在同一个类中。
  - 方法名相同。
  - 方法参数个数或者参数类型不同。
  - 与方法返回值、返回类型、方法修饰符无关。
- **重写**：指子类中方法签名与父类相同的方法，使用@override注解标识。重写要写如下：
  - 方法在父类和子类不同的类中。
  - 方法名相同。
  - 方法参数个数和参数类型都要相同。
  - 方法返回值类型相同，或者子类方法返回值类型是父类方法返回值的一个子类类型。
  - 子类方法不能缩小方法的访问权限。

### 2.2. 基本数据类型与包装类？

**三类八种基本数据类型**，每个基本类型都有对应的包装类。包装类变量是个指针，没初始化前默认为null。

| 种类   | 基本数据类型           | 存储位数 | 取值范围                                                     | 默认值         | 包装类    |
| ------ | ---------------------- | -------- | ------------------------------------------------------------ | -------------- | --------- |
| 数值型 | byte（位）             | 8 bit    | -2^8到2^8 -1                                                 | 0              | Byte      |
| 数值型 | short（短整数）        | 16 bit   | -2^15到2^15 -1                                               | 0              | Short     |
| 数值型 | int（整数）            | 32 bit   | -2^31到2^31 - 1                                              | 0              | Integer   |
| 数值型 | long（长整数）         | 64 bit   | -2^63到2^63 - 1                                              | 0L             | Long      |
| 数值型 | float（单精度浮点数）  | 32 bit   | 负数范围：-3.402823E+38到-1.401298E-45，正数范围：1.401298E-45到3.402823E+38 | 0.0F           | Float     |
| 数值型 | double（双精度浮点数） | 64 bit   | 负数范围：-1.797693E+308到-4.9000000E-324，正数范围：4.9000000E-324到1.797693E+308 | 0.0D           | Double    |
| 字符型 | char（字符）           | 16 bit   | 0到2^16 - 1                                                  | '\u0000'（空） | Character |
| 布尔型 | boolean                | 1 bit    | true和false                                                  | false          | Boolean   |

### 2.3. 序列化与反序列化？

- **序列化**：
  - 指将Java对象转化为字节序列的过程，即将对象的状态转化成字节流，然后可以通过这些值再生成相同状态的对象。
  - 对象序列化，是对象持久化的一种实现方法，是将对象的属性和方法转化为一种序列化的形式，用于存储和传输。
- **反序列化**：
  - 指将字节序列转化为Java对象的过程，即将对象字节序列重建对象的过程。
- 优点：
  - 实现了数据的持久化，通过序列化可以把数据永久地保存到硬盘上，通常是放在文件里，比如Redis的RDB。
  - 利用序列化实现远程通信，即在网络上传送对象的字节序列，比如Google的ProtoBuf。
- 反序列失败场景：
  - 如果SerialVersionUID不一致，会导致反序列化失败。

### 2.4. Object类？

**Object类是所有类的父类**，在使用任何类都可以使用Object类中的方法：

- toString（）：默认是 类名+hashCode，一般需要重写。

- equals（）：

  - 默认为==，比较对象的引用地址是否相同。
  - 实际上往往需要重写，用于判断两个类的实例是否逻辑（内容）相等。

- hashCode（）：

  - 对象的哈希码，协定声明相等对象必须具有相等的哈希码，即对象equal则hashCode一定相等，hashCode不等则对象一定不equal；对象不euqal时hashCode可能相等，hashCode相等时可能不equal，比如HashMap散列冲突。

  - 因此**重写equals（）方法时必须重写hashCode（）方法**，因为HashMap#get(String)时使用

    first.hash == hash && ((k = first.key) == key || (key != null && key.equals(k)))

    即hash相等且（地址相同或者对象equal）来获取key对象的值，如果修改后，对象equal但hashCode不等，则HashMap会出错。

- finalize（）：

  - 在垃圾回收前调用，默认为空实现。
  - 子类可以重写finalize（）方法，以配置系统资源或执行其他清除。

- clone（）：深拷贝，类需要实现Cloneable接口。

- getClass（）：用于返回对象真实的Class对象（对象的元数据）。

- wait（）、wait（long）、wait（long，int）、notify（）、notifyAll（）：用于线程等待或唤醒。

### 2.5. String类？

- **String**：使用**数组**存储内容，由于数组使用final修饰，因此String定义的字符串的值是不可变的。
- **StringBuffer**：对方法都加了synchronize关键字，是线程安全的，适用于多线程环境下在字符缓冲区进行大量操作，但效率不如StringBuilder。
- **StringBuilder**：StringBuilder方法没有加synchronzie关键字，是非线程安全的，适用于单线程环境下在字符缓冲区进行大量操作，效率比StringBuffer高。

### 2.6. 动态代理？

[1.7. 代理模式](#1.7. 代理模式)&nbsp;

动态代理，指在实现阶段不用关心代理类，而在**运行阶段**才指定哪一个对象。

> **JDK动态代理**：Proxy类利用反射机制以及一个**实现InvocationHandler的处理类**，生成一个实现了原委托类接口（为了可以调用被代理方法） 和 继承了Proxy类（为了持有已经实现InvocationHandler实例的引用） 的代理类，使得在调用代理类具体方法时去调用实现InvocationHandler接口的处理类里的方法。
>
> **CGLIB动态代理**：利用ASM开源包，通过**修改委托类的Class文件的字节码生成子类**来处理，其中主要是生成的子类去覆盖原本委托类中的方法，并在覆盖方法中实现增强，但是因为采用的是继承，所以对于final类或者方法是无法继承和代理的。

#### 1. JDK动态代理 VS CGLIB动态代理

- JDK动态代理：在调用代理类方法时，是通过引用调用InvocationHandler实现类的invoke方法，然后再反射调用委托类的方法，**属于反射调用，存在一定的性能花销**。
- CGLIB动态代理：在调用代理类方法时，是通过引用调用MethodInterceptor实现类的intercept方法，然后通过方法签名的index索引，去代理类的FastClass查找到代理类中具体的方法，最后该方法调用父类（原委托类）的方法, **属于父类方法调用，性能花销小**。

|               | JDK动态代理                              | CGLIB动态代理                                                |
| ------------- | ---------------------------------------- | ------------------------------------------------------------ |
| 生成代理Class | 生成效率高                               | 每次都会生成新的FastClass文件，所以Class生成效率会比JDK动态代理的低 |
| 方法调用      | 属于反射调用，调用效率较低               | 属于父类方法调用，所以调用效率会比JDK动态代理的高            |
| 实现原理      | 如果原委托类没有实现接口时，则不可以使用 | 原委托类有无实现接口一样可以使用，但不可以代理private和final修饰的方法 |
| 使用场景      | 比较适合代理非代理对象                   | 无需频繁创建代理对象，比较适合代理单例对象                   |
| 迭代状态      | 每个JDK版本都有迭代，性能得到增强        | 止步不前                                                     |

#### **2. JDK动态代理**

为了解决静态代理中代理类接口过多的问题，可以通过JDK自带的java.lang.reflect.Proxy类，通过反射实现动态代理。

##### 使用步骤

1. 编写一个委托类的接口：如UserService，把实现方法save（）声明出去。
2. 实现一个真正的委托类：即UserServiceImpl，实现接口save（）方法。
3. 创建一个动态代理类：实现InvocationHandler接口，并重写invoke方法，在实际调用前后编写需要代理的业务逻辑。其中**动态代理类需要持有委托类的引用**，用于反射调用委托类的save()实现方法。
4. 客户端生成代理对象：在客户端中生成动态代理类对象，调用声明的save（）方法。

- **newProxyInstance（）方法参数**：
  - **ClassLoader loader**：原委托类的类加载器。
  - **Class<?>[] interfaces**：原委托类实现的接口类型数组。
  - **InvocationHandler**：事件处理类，代理对象方法调用的实际处理者。在执行原委托类方法时，会触发该事件处理器，把原委托类的方法作为Method参数传入，供代理对象使用。

```java
// 委托类接口：用户服务接口
public interface UserService {

    public void save();
}

// 真正的委托类：用户服务接口实现类
public class UserServiceImpl implements UserService {

    @Override
    public void save() {
        System.out.println("保存用户信息...");
    }
}

// 动态代理类：用户服务实现JDK动态代理类
public class UserServiceImplJdkProxy implements InvocationHandler {

    private UserService userService;

    public UserServiceImplJdkProxy(UserService userService) {
        this.userService = userService;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("JDK动态代理前...");

        Object result = method.invoke(userService, args);

        System.out.println("JDK动态代理后...");
        return result;
    }
}

// 客户端生成代理对象
public class Client {

    public static void main(String[] args) throws Throwable {
        UserServiceImplJdkProxy userServiceImplJdkProxy = new UserServiceImplJdkProxy(new UserServiceImpl());
        
        UserService userService = (UserService) Proxy.newProxyInstance(
                UserServiceImpl.class.getClassLoader(), new Class[]{UserService.class}, userServiceImplJdkProxy);
        
        userService.save();
    }
}
```

##### 实现原理

- **源码分析**：

1. newProxyInstance（）通过反射生成含有接口方法的Proxy Class，其中Proxy Class又继承了Proxy类。
2. $Proxy0构造方法中，调用父类的构造方法，Proxy父类得到InvocationHandler的实例引用。
3. 最后该代理对象的所有方法调用，都会反射转发到InvocationHandler.invoke（）方法。
4. InvocationHandler.invoke（）：允许在原委托类的业务方法的反射调用前后，织入其他代码，从而实现动态代理。

```java
// com/sun/proxy/$Proxy0.java
public final class $Proxy0 extends Proxy implements UserService
{
    private static Method m3;// com.jsonyao.cs.proxyPattern.UserServic => save()

    static
    {
            // 反射获取UserService接口的save()方法
            m3 = Class.forName("com.jsonyao.cs.proxyPattern.UserService").getMethod("save", new Class[0]);
            ...
    }
    
    // 20201112 构造方法
    public $Proxy0(InvocationHandler invocationhandler)
    {
        // 20201112 调用父类构造器, 赋值自定义InvocationHandler
        super(invocationhandler);
    }
    
    // 20201112 实现了UserService的save()方法
    public final void save()
    {
            // 20201112 调用父类注入的invocationHandler实例实现的invoke()方法
            // 20201112 参数分别为Object proxy, Method method, Object[] args
            super.h.invoke(this, m3, null);
            return;
    }
    
    ...
}
```

#### 3. CGLIB动态代理

解决委托类没有实现任何接口时的动态代理。

##### 使用步骤

1. 实现一个MethodInterceptor：方法调用会被转发到该类的intercept（）方法。
2. 客户端构建CGLIB Enhacner：指定原委托类，以及回调接口实现类MethodInterceptor。
3. 客户端获取代理对象执行业务方法：调用Enhacner#create（）方法得到代理对象，使用代理对象调用业务方法。

```java
// CGLIB动态代理方法拦截类
public class MyMethodInterceptor implements MethodInterceptor {

    public static final HelloCglib helloCglib = new HelloCglib();

    /**
     * @param obj => 20201113 增强后的代理对象
     * @param method => 20201113 原始方法
     * @param objects => 20201113 参数数组
     * @param methodProxy => 20201113 可以使用methodProxy#invokeSuper调用FastClass方法
     */
    @Override
    public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
        System.out.println("CGLIB动态代理前...");

// 20201113 实际是调用了FastClass的invoke方法, 去调用父类的原方法, 对比JDK动态代理提高了性能
        Object object = methodProxy.invokeSuper(o, objects);
     
        System.out.println("CGLIB动态代理后...");
        return object;
    }
}

public class Client {

    public static void main(String[] args) throws Throwable {
        // 设置代理类生成的目录
        System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, ".\\cglib\\classes");

        // 构建CGLIB Enhacner, 指定原委托类，以及回调接口实现类MethodInterceptor
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(HelloCglib.class);
        enhancer.setCallback(new MyMethodInterceptor());
        
        // 客户端获取代理对象执行业务方法：final方法不会被代理
        HelloCglib helloCglib = (HelloCglib) enhancer.create();
        helloCglib.helloAagin();
    }
}
```

##### 实现原理

- 利用ASM开源包，通过**修改委托类Class文件的字节码**生成子类，去覆盖原委托类的方法，并在覆盖方法中实现了增强。
- 在调用代理类方法时，通过引用调用MethodInterceptor实现类的invoke方法，然后通过**方法签名的index索引去代理类的FastClass中查找**代理类中具体的方法，最后调用该方法时调用父类即原委托类的方法，从而实现动态代理。
- **源码分析**：
  1. Enhancer#setSuperclass（Class）：设置委托类为Enhancer的成员变量。
  2. Enhancer#setCallback（Callback）：设置回调函数实例为Enhancer的成员变量。
  3. Enhancer#create（）：使用父类、接口、过滤器、回调函数、版本号等信息生成标识类的key -> 构造出multi-values key对象 => 用于获取/设置缓存。
  4. AbstractClassGenerator#create（Object key）：生成字节码增强文件，并设置multi-values key对应的缓存。
  5. Enhancer#createUsingReflection（Class）：设置代理对象的回调函数实例（其中MethodInterceptor实现了Callback接口，实际上callback就是实现的MethodInterceptor实例）以及反射生成代理对象实例。
  6. 代理对象HelloCglib$$EnhancerByCGLIB$$6bf7bfad的static初始化块：调用MethodProxy.create生成原委托类方法、代理对象代理方法的签名。
  7. MethodProxy.create（Class, Class, String，String, String）：生成原委托类方法、代理对象代理方法的签名。
  8. MethodProxy#invokeSuper(o, objects)：o: 增强后的代理对象, objects参数列表。
  9. 代理对象的FastClass HelloCglib$$EnhancerByCGLIB$$6bf7bfad$$FastClassByCGLIB$$9448a271#getIndex（Signature）：根据原委托类方法、代理对象的代理方法的签名生成FastClassInfo索引。
  10. 代理对象的FastClass HelloCglib$$EnhancerByCGLIB$$6bf7bfad$$FastClassByCGLIB$$9448a271#invoke(int , Object , Object)：根据代理方法索引、代理对象、参数列表调用FastClass方法。
  11. 代理对象HelloCglib$$EnhancerByCGLIB$$6bf7bfad#CGLIB$helloAagin$5()：调用代理对象的CGLIB$helloAagin$5()方法。
  12. 原委托类HelloCglib#helloAagin（）：调用父类HelloCglib原委托类的helloAagin方法，避免反射调用，提高性能。

```java
// Enhance类
public class Enhancer extends AbstractClassGenerator
{
    // 1. 设置委托类为Enhancer的成员变量
    public void setSuperclass(Class superclass) {
    	...
        // 如果不是接口且父类不是Object类, 则设置父类为自己本身
        this.superclass = superclass;
    }
    
    // 2. 设置回调函数为Enhancer的成员变量
    public void setCallback(final Callback callback) {
        setCallbacks(new Callback[]{ callback });
    }
    
    // 3. Enhancer#create()
    private Object createHelper() {
    	...
        // 使用父类、接口、过滤器、回调函数、版本号等信息生成标识类的key -> 构造出multi-values key对象 => 用于获取/设置缓存
        return super.create(KEY_FACTORY.newInstance((superclass != null) ? superclass.getName() : null, ReflectUtils.getNames(interfaces), 
        											filter,
                                                    callbackTypes,
                                                    useFactory,
                                                    interceptDuringConstruction,
                                                    serialVersionUID));
                                                    
    // 类abstract public class AbstractClassGenerator implements ClassGenerator
    // 4. super#create()生成字节码增强文件，并设置multi-values key对应的缓存
    protected Object create(Object key) {
    	...
		if (gen == null) {
			// 根据默认策略生成代理对象的Class文件字节流
			byte[] b = strategy.generate(this);
			// 根据字节流获取Class文件名
			String className = ClassNameReader.getClassName(new ClassReader(b));
			// 添加Class文件名到类加载器中
			getClassNameCache(loader).add(className);
			// 根据Class文件名 & Class文件字节流 & 类加载器生成代理对象的Class
			gen = ReflectUtils.defineClass(className, b, loader);
		}
		// 添加代理类Class对象到类加载器缓存中
		if (useCache) {
			cache2.put(key, new WeakReference(gen));
		}
		
		// 5. 生成代理对象实例
		return firstInstance(gen);
    }
    // 类abstract public class AbstractClassGenerator implements ClassGenerator
    
    // 5. Enhancer类生成代理对象实例
    protected Object firstInstance(Class type) throws Exception {
        if (classOnly) {
            return type;
        } else {
            return createUsingReflection(type);
        }
    }
    private Object createUsingReflection(Class type) {
        // 5. 设置代理对象的回调函数, 其中MethodInterceptor实现了Callback接口, 实际上callback就是实现的MethodInterceptor
        setThreadCallbacks(type, callbacks);
        ...
        // 5. 反射生成代理对象实例
        return ReflectUtils.newInstance(type);
    }
}

// CGLIB代理类，原委托类为HelloCglib
public class HelloCglib$$EnhancerByCGLIB$$6bf7bfad extends HelloCglib implements Factory
{
	    static void CGLIB$STATICHOOK1()
    {
    	// Method数组: 含动态代理生成的方法 & 原委托类所有非Final的方法
        Method amethod[];
        // 之前设置的回调函数
        CGLIB$THREAD_CALLBACKS = new ThreadLocal();
        // 代理对象的Class对象
        Class class1 = Class.forName("com.jsonyao.cs.proxyPattern.HelloCglib$$EnhancerByCGLIB$$6bf7bfad");
        // 原委托类的Class对象
        Class class2;
        
        // 6. 静态代码块: 调用MethodProxy#create生成原委托类方法、代理对象代理方法的签名
        CGLIB$helloAagin$5$Proxy = MethodProxy.create(class2, class1, "()V", "helloAagin", "CGLIB$helloAagin$5");
        ...
    }
    
    // 11. 调用代理对象的CGLIB$helloAagin$5()
    final void CGLIB$helloAagin$5()
    {
    	// 12. 最后一步：调用父类HelloCglib原委托类的helloAagin方法，避免反射调用，提高性能
        super.helloAagin();
    }
}

// MyMethodInterceptor#invoke（）入参：MethodProxy
public class MethodProxy {

    // 7. 生成原委托类方法、代理对象代理方法的签名
    public static MethodProxy create(Class c1, Class c2, String desc, String name1, String name2) {
        MethodProxy proxy = new MethodProxy();
        proxy.sig1 = new Signature(name1, desc);
        proxy.sig2 = new Signature(name2, desc);
        proxy.createInfo = new CreateInfo(c1, c2);
        return proxy;
    }

    // 8. Object object = methodProxy.invokeSuper(o, objects);
    // 8. o: 增强后的代理对象, objects参数列表
    public Object invokeSuper(Object obj, Object[] args) throws Throwable {
        try {
        	// 9. 根据原委托类方法、代理对象代理方法的签名生成FastClassInfo索引
            init();
            FastClassInfo fci = fastClassInfo;
            
            // 10. 根据代理方法索引、代理对象、参数列表调用FastClass方法
            return fci.f2.invoke(fci.i2, obj, args);
        } catch (InvocationTargetException e) {
            throw e.getTargetException();
        }
    }
    
    private static class FastClassInfo
    {
        FastClass f1;
        FastClass f2;
        int i1;
        int i2;
    }
    
    // 9. 根据原委托类方法、代理对象代理方法的签名生成FastClassInfo索引
    private void init()
    {
        if (fastClassInfo == null)
        {
            synchronized (initLock)
            {
                if (fastClassInfo == null)
                {
                    CreateInfo ci = createInfo;

                    FastClassInfo fci = new FastClassInfo();
                    fci.f1 = helper(ci, ci.c1);
                    fci.f2 = helper(ci, ci.c2);
                    fci.i1 = fci.f1.getIndex(sig1);
                    // 9. 根据原委托类方法、代理对象代理方法的签名生成FastClassInfo索引
                    fci.i2 = fci.f2.getIndex(sig2);
                    fastClassInfo = fci;
                    createInfo = null;
                }
            }
        }
    }
}

// FastClass抽象父类
abstract public class FastClass
{
	abstract public int getIndex(Signature sig);
    
    abstract public Object invoke(int index, Object obj, Object[] args) throws InvocationTargetException；
}

// 20201113 HelloCglib代理后的FastClass文件
public class HelloCglib$$EnhancerByCGLIB$$6bf7bfad$$FastClassByCGLIB$$9448a271 extends FastClass {
    
    // 9. 根据原委托类方法、代理对象代理方法的签名生成FastClassInfo索引
     public int getIndex(Signature var1) {
        String var10000 = var1.toString();
         switch(var10000.hashCode()) {
            ...
        	case -1512990617:
            	if (var10000.equals("CGLIB$helloAagin$5()V")) {
                	return 16;
            	}
            	break;  
            ...
         }
     }
    
    // 10. 根据代理方法索引、代理对象、参数列表调用FastClass方法
    public Object invoke(int var1, Object var2, Object[] var3) throws InvocationTargetException {
        6bf7bfad var10000 = (6bf7bfad)var2;
        int var10001 = var1;
        try {
            switch(var10001) {
                ...
                case 16:
                    // 11. 调用代理对象的CGLIB$helloAagin$5()
                	var10000.CGLIB$helloAagin$5();
                	return null;
                ...
            }
        }
    }
}
```

### 2.7. 值传递、引用赋值、引用复制？

- **值传递**：基本类型变量的赋值为**值传递**，比如int i = 1。
- **引用赋值**：对象变量的赋值为**引用赋值**，即新变量和老变量具有相同的引用。
- **引用复制**：对象作为方法参数传递，传递的是原对象引用的副本，即发生了**引用复制**。
  - 在引用副本所引用的对象，如果没有提供操作对象成员变量的方法，该引用副本不会修改原引用的对象，比如String。
  - 在引用副本所引用的对象，如果有提供操作对象成员变量的方法，该引用副本会修改原引用的对象，比如StringBuilder.append(i)。
  - 引用副本在被更改后，不会影响到原引用的值。

### 2.8. 基本类型、对象类型、数组类型引用的内存分布情况？

- **基本类型**：boolean、byte、short、char、int、float以及对应的引用类型**在栈上**占4个字节，long、double在栈上占8字节。也就是此时对于每个方法来说，栈上的空间在编译时已经确定了的。
- **对象类型**：比如new Object（）**在堆中分配空间**，再由**栈引用指向堆中的对象**。
  - **字符串类型**：比如String str = new String("hello")，此时类似于对象类型的内存分布情况，**栈中的str**引用指向**堆中**的String对象的首地址，而String对象里有char[] chars、int startIndex、int length属性，其中chars引用指向‘h’ ‘e’ ‘l’ ‘l’ ‘o’**字符数组**的首地址。
- **数组类型**：**栈中**的引用指向**一维数组（行）**的首地址，**堆中**开辟实际数组的空间。
  - **一维数组**：比如int[] arr = new int[2]，此时栈中的arr引用占4个字节，指向堆中开辟的2个连续的int 4个字节空间的首地址。
  - **二维数组**：比如int[][] arr2 = new int[2] [4]，此时栈中的arr2引用还是占4个字节，指向堆中开辟的2个连续的int[]4个字节的空间的首地址，而每个int[]引用又指向堆中开辟的4个连续的int 4个字节空间的首地址。
    - **二维空数组**：比如int[][] arr3 = new int[2] []，此时栈中的arr2引用还是占4个字节，指向堆中开辟的2个连续的int[] 4个字节的空间的首地址，而每个int[]引用为null。

### 2.9. 引用与指针？

- **引用**：**引用一旦指向了对象，则不能再被更改，即使对象变了引用的东西也会跟着变，强调的是对象的不变性**（即一定要"小明干活"），**类似于对象的别名**，比如对象（员工）"小明"改名为了"小强"，此时引用（上司）还是知道那个对象叫是"小强"，即引用强调的是员工（对象）的不变性。
- **指针**：**指针允许自由操作地址的指向，强调的是指向的地址是自由的**，即关系自由性（谁干活不重要, 但一定要有人干），比如指针（上司）与地址"小明"分配工作内容，但第二天地址"小明"辞职了，这时指针（上司）可以把活分配给新的地址"小强"，即改变了指向的地址。
- **混淆点**：引用类似于指针，与指针一样，查看引用可以知道具体指向的地址，但引用并不能操作该地址的指向。但是**Java中没有指针，只有引用**：
  - **Java中谈引用是从内存分析的角度思考的**，分析引用指向那个对象，这种引用的对象到底什么时候可以被回收等等。
  - 而**谈的“指针’”是从数据结构的角度思考**，比如这个链表头指针移动到哪里哪里等等，实际上移动到哪里哪里，但实际也还是引用的赋值，因为从内存的角度来说，就是把新的头节点的引用赋值给原来的头节点，因此也还是引用。
  - 所以**Java没有指针，只有引用**。

### 3.0. Java四种引用类型？

![1623655664473](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1623655664473.png)

#### 强引用

- **概念**：
  - jdk 1.8包中没有这个类，是普通类的引用。
  - M m = new M（），此时m为强引用对象。
- **特点**：
  - **强引用“引用”（动词）的对象永远不会被垃圾收集器回收**，即使将要发生OOM（OutOfMemoryError）。
  - **普通引用**就是强引用对象，可直接访问“引用”的对象。
- **使用场景**：直接访问“引用”的对象，做业务操作。

#### 软引用

- **概念**：
  - SoftReference，Reference引用抽象基类的实现类。
  - SoftReference m = new SoftReference（new M（）)，此时m为软引用对象。要注意的是，虽然m为软引用对象SoftReference，但在内存分布中，栈m到堆SR之间是强引用（普通引用）关系，而**SR内部到M才是真正的软引用关系**。
- **特点**：
  - 只被软引用“引用”的对象不会被垃圾收集器立即回收，垃圾收集器会根据内存需求自行是否决定清除“引用”的对象：**只有在堆内存不足时**，垃圾收集器才会去回收只被软引用“引用”的对象。
  - 在虚拟机抛出 OutOfMemoryError 之前，保证清除软可达对象的所有软引用，鼓励虚拟机实现偏向于**清除最近创建或最近使用的软引用**。
  - **先清除软引用，再将软引用加入引用队列**：垃圾收集器在某个时间点确定被软引用"引用"的对象是软可达的，此时会以原子方式清除“引用”的对象的所有软引用，以及对任何其他软可达对象的所有软引用，**同时或稍后会将已经注册到引用队列的新清除的软引用加入引用队列**。
- **使用场景**：常用于实现内存敏感的缓存，比如Guava中的LocalCache。

#### 弱引用

- **概念**：
  - WeakReference，Reference引用抽象基类的实现类。
  - WeakReference m = new WeakReference(new M（）)，此时m为弱引用对象。要注意的是，虽然m为弱引用对象WeakReference，但在内存分布中，栈m到堆WR之间是强引用（普通引用）关系，而**WR内部到M才是真正的弱引用关系**。
- **特点**：
  - 垃圾收集器一旦发现了只被弱引用“引用”的对象，**无论堆内存是否足够**，都会回收“引用”的对象的内存。
  - **先清除弱引用，再将弱引用加入引用队列**：垃圾收集器在某个时间点确定被弱引用“引用”的对象是弱可达的，此时会以原子方式清除“引用”的对象的所有弱引用，以及对任何其他弱可达对象的所有弱引用，以及声明所有以前弱可达的对象是可终结的，**同时或稍后会将已注册到引用队列的弱引用加入队列**。
- **使用场景**：
  - 常用于实现规范化Map集合，如ThreadLocal的Entry#Key对象。
  - 这是因为在Map集合实现的缓存中，会出现**无用Key对象被Map实例强引用导致出现内存泄露问题**（即没用的对象没被释放掉），这时弱引用包装的真实的Key对象，使用弱引用实例来作为key，可以缩短Key的生命周期，使得Key可以更快地被垃圾收集器回收掉，从而解决无用Key对象带来的内存泄露问题。
  - 要注意的是，如果使用弱引用包装Key对象，在真实的Key对象被回收后，弱引用实例的Key会被置为null，形成null-Value的键值对，导致**出现无用Value对象的内存泄露问题**。这就需要真实的Key对象被回收时，删除对应的弱引用实例-Value键值对，解决无用Value对象带来的内存泄露问题。

#### 虚引用

- **概念**：
  - PhantomReference，Reference引用抽象基类的实现类。
  - PhantomReference m = new PhantomReference（new M（），new ReferenceQueue（）），此时m为虚引用对象。要注意的是，虽然m为虚引用对象PhantomReference，但在内存分布中，栈m到堆PR之间是强引用（普通引用）关系，而**PR内部到M才是真正的虚引用关系**，且虚引用创建时必须绑定一个引用队列。
- **特点**：
  - 只被虚引用“引用”的对象跟没有被“引用”是一样的，**“引用”的对象随时会被垃圾收集器回收**。
  - 虚引用“引用”的对象不能被检索到，即通过**调用虚引用的get（）总是返回null**。
  - **加入引用队列不需要先清除与对象的“引用”**：在垃圾收集器确定**“引用”的对象可能会被回收后**，会将其上的虚引用对象加入引用队列进行排队（此时没有清除与对象之间的“引用”）。
- **使用场景**：常用于调度预检清理操作，比如JVM用于管理堆外内存（直接内存）的释放。

![1623670905412](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1623670905412.png)

### 3.1. ArrayList与LinkedList？

|                    | ArrayList                                      | LinkedList                         |
| ------------------ | ---------------------------------------------- | ---------------------------------- |
| 实现接口           | List                                           | List、Deque                        |
| 数据结构           | 基于数组实现                                   | 基于双向链表实现                   |
| 提供的API          | List方法                                       | 栈、队列、双端队列方法             |
| 插入元素           | 数组尾部                                       | 链头、链尾两个方向都可以           |
| 初始容量与扩容机制 | 10，每次扩容1.5倍容量                          | 无容量限制，无扩容机制             |
| 适用场景           | 支持对元素进行快速随机访问，适合随机查找和遍历 | 适合数据的动态插入和删除           |
| 不适合场景         | 不适合大量插入和删除                           | 不支持元素的随机访问，必须遍历链表 |

### 3.2. 如何实现List线程安全？

- List API外层使用**锁**保证线程安全。
- **Collections内部类SynchronizedList**，通过持有传入的List引用，以及Object mutex对象锁，提供synchronized关键字修饰List接口方法，从而包装成线程安全的List。
- **Vector**，可增长数组，默认容量10，默认容量扩容2倍，通过使用synchronized关键字修饰方法保证线程安全。
- **CopyOnWriteArrayList**，写时复制，读操作不需要加锁，只保证数据最终一致性，无法保证实时性。

### 3.3. 快速失败fail-fast机制？

- **大多数迭代器都是快速失败的**，即如果在创建迭代器后的任何时间**对结构进行结构修改（modCount）**，则除了通过迭代器自己的remove方法之外，该迭代器都将抛出{ @link ConcurrentModificationException}。
- 这在**面对并发修改时，迭代器可以快速干净地失败**，而不是在未来不确定的时间冒着任意、非确定性行为的风险去修改。
- 无法保证迭代器的快速失败行为，因为一般而言，在存在非同步并发修改的情况下，不可能做出任何硬保证，**只会尽最大努力抛出ConcurrentModificationException，**因此，编写一个依赖于这个异常来保证其正确性的程序是错误的，**快速失败行为只适用于检测错误**。

### 3.4. 详细介绍HashMap?

#### 特点

- **HashMap，Map接口基于散列表的非线程安全的实现，允许null值和null键，不保证元素的顺序**。所以，在散列表均匀分散元素的情况下，get和put方法时间复杂度为O（1），而迭代所需的时间与其**容量**（散列表桶数）和**实际大小**（键值对数）成正比，因此不要设置过高的初始容量或者过低的负载因子（会导致大容量）。
- 几个重要的参数：
  - **当前容量**：当前容量是散列表中存储桶的数量，而初始容量只是创建散列表的容量。
  - **负载因子**：等于实际大小 / 当前容量，当散列表中的条目数超过阈值（负载因子和当前容量的乘积）时，HashMap发生扩容，使散列表具有大约两倍容量（桶数）。
  - **阈值**：等于负载因子 * 当前容量，默认为16（即默认容量），当table为空表时，则在扩容时用作新表的容量；否则，用作判断是否扩容的条件，如果当前容量大于阈值，则需要扩容散列表。
  - **实际大小**：HashMap所有的条目总数。
- **默认提供的负载因子0.75，在时间和空间成本之间提供了很好的权衡**：
  - 较高会减少空间的开销，但增加了查找的成本（由于高负载因子，导致扩容次数减少，桶拉链变长）。
  - 较低会增加扩容的次数，增加空间的开销，但好在桶拉链变短，查找效率高，哈希冲突少。
- HashMap的所有迭代器都是**快速失败**的，即如果在创建迭代器后的任何时间对结构进行结构修改，则除了通过迭代器自己的remove方法之外，该迭代器都将抛出{ @link ConcurrentModificationException}。

#### 数据结构

数组 + 链表 + 红黑树：

![1625405326188](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1625405326188.png)

#### 构造方法

- 4个构造方法，分别为空参的、指定初始容量的、指定初始容量和负载因子的、指定复制集合的。
- 默认负载因子为0.75，默认容量为16。

#### HashCode扰动函数

- **hash（Object）**，将HashCode右移16位，从而混合HashCode的高位和低位，加大低位的随机性，减少哈希碰撞发生的概率，是一种**性能、效用和质量**的折衷方案。
  - 使用简单的位移与异或操作，减少系统的计算损耗；使用高位异或，可以减少低位冲突的可能性，保证查
    找效率。
  - HashCode右移16位，使得高位能被利用起来，保证了效用性。
  - 使用高位异或，可以减少低位冲突的可能性，保证散列表的质量。

#### 哈希索引的计算方法

- **（n - 1） & hash，相当于hash % n**：n指散列表的当前容量（桶数量），hash指获取hash（key）即key的hashCode扰动后结果。
  - **不能直接使用HashCode作为索引的原因**：int类型的hashCode，范围为[-2^32，2^32 - 1]，如果散列表
    数组与HashCode一一对应，需要40亿的空间（int[40亿]），明显这在内存是放不下的，也就是说明
    hashCode是不能直接作为数组索引的。因此，如果使用hashCode对散列表数组长度取模，那么就可以解决这个问题，从而保证较小的数组也还能利用上hashCode。
  - **n为2的幂次原因**：为了解决hashCode对散列表数组长度取模，设计了HashCode的扰动函数以及为2幂次的容量n，可以通过n-1来获得取模操作的低位掩码，此时**只需要通过低位掩码与扰动后的**
    **hashCode（hash值）进行一次与运算**，即可得到该hash值在散列表数组中的索引。其次通过在扩容方
    法中，经过hash值与低位掩码相与，可以保证扩容后，**只会移动少部分相与结果高位为1的桶链表**，其他
    保持不变，减少了扩容时的时间。
- **通过tableSizeFor（int）返回给定目标容量的2的幂次**，底层通过-1，右移1、2、4、8、16位，再+1得到目标容量。

#### resize扩容方法

1. **扩容前分3种情况判断，来确定新容量和阈值**：
   - 当前容量 > 0，则容量 * 2，阈值 * 2。
   - 当前容量 <= 0，且阈值 > 0，说明HashMap已被初始化且表为空表，则使用阈值作为新的容量。
   - 当前容量 <= 0，且阈值 <= 0，说明HashMap还没被初始化，则使用默认容量16以及默认阈值12=16 * 0.75。
2. **创建新容量的散列表**：(Node<K,V>[])new Node[newCap]；
3. **从头遍历散列表，移动结点**：
   - 如果桶j只有一个元素，则重新计算哈希索引，转移元素到新表即可。
   - 如果桶j为红黑树，则调用红黑树的split方法，拆分红黑树，以重新计算每个结点的哈希索引。根据哈希索引是否不变，拆分成高低lo和hi链表，lo链表移动到新桶时保持原桶位置不动，hi链表往前移动oldCap长度的位置。其中如果拆分后的链表长度小于等于6时，则会把**红黑树退化成普通链表**。
   - 如果桶j为普通链表，则重新计算每个结点的哈希索引，根据哈希索引是否不变，拆分成高低lo和hi链表，lo链表移动到新桶时保持原桶位置不动，hi链表往前移动oldCap长度的位置。

#### put方法

3个常用的顶层API方法put、putIfAbsent、putAll，它们依赖于putVal方法，其步骤为：

1. hash（key）计算key的hash值，(n - 1) & hash计算出哈希索引，tab[i]得到哈希索引对应散列表的桶p。
2. 如果p桶为null，则直接new Node放到该桶即可。
3. 如果p桶不为null，则分4种情况判断：
   - 如果桶头结点p的hash值相等且（key相等 或者 equals），说明p就是要找的结点，如果此时onlyIfAbsent为false，则发生值替换，直接返回即可。
   - 否则，如果桶头结点p为红黑树结点，则使用**TreeNode的实例方法putTreeVal**添加key：value。
   - 否则，p为普通链表结点，则遍历p链表，如果找到hash值相等且（key相等 或者 equals）的结点，如果此时onlyIfAbsent为false，则发生值替换，直接返回即可。
   - 如果找不到对应的结点，则在链尾new Node一个结点，并且添加后如果当前链表至少有8个结点，则调用**HashMap的实例方法treeBin**将当前桶链表树化为红黑树（treeBin还会判断散列表容量是否大于等于64）。
4. 如果发生的不是值替换，则更新修改模数、实际大小，如果实际大小大于阈值，则还需要调用resize（）进行扩容并转移结点。最后返回null，代表结点插入成功。

#### remove方法

2个常用的顶层API方法remove（Object）和remove（Object，Object），它们都依赖removeNode方法，其步骤为：

1. hash（key）计算key的hash值，(n - 1) & hash计算出哈希索引，tab[i]得到哈希索引对应散列表的桶p。
2. 如果桶p为null，则返回null，代表HashMap不存在对应的结点。
3. 如果p桶不为null，则分4种情况判断：
   - 如果桶头结点p的hash值相等且（key相等 或者 equals），说明p就是要找的结点，将p引用赋值给node引用，待后面做删除操作。
   - 否则，如果桶头结点p没有后继，则将p引用赋值给node引用，待后面做删除操作。
   - 否则，如果p有后继且p为红黑树结点，则调用**TreeNode的实例方法getTreeNode**获取hash和key对应的结点，并将其引用赋值给node引用，待后面做删除操作。
   - 如果p有后继且p为普通结点，则遍历p链表，如果找到hash值相等且（key相等 或者 equals）的结点，并将其引用赋值给node引用，待后面做删除操作。如果找不到，则设置node引用为null。
4. 如果node引用为null，则返回null，代表HashMap不存在对应的结点；如果node引用不为null，说明找到了对应结点（如果此时matchValue为true，则还需要判断value是否equals），则分为3种情况判断：
   - 如果node为红黑树结点，则调用**TreeNode的实例方法removeTreeNode**删除该结点。
   - 如果node为普通结点，且为桶头结点，则脱钩node结点，并更新桶头结点为它的后继。
   - 如果node为普通结点，但不为桶头结点，则链接它的前驱和后继，脱钩node结点。
5. 最后如果脱钩结点成功，则更新修改模数、实际大小，返回node结点。

#### get方法

2个常用的顶层API方法get、getOrDefault，它们都依赖getNode方法，其步骤为：

1. hash（key）计算key的hash值，(n - 1) & hash计算出哈希索引，tab[i]得到哈希索引对应散列表的桶first。
2. 如果桶first为null，则返回null，代表HashMap不存在对应的结点。
3. 如果first桶不为null，则分4种情况判断：
   - 如果桶头结点first的hash值相等且（key相等 或者 equals），说明first就是要找的结点，则直接返回first结点。
   - 否则，如果桶头结点first没有后继，则返回null，代表HashMap不存在对应的结点。
   - 否则，如果first有后继且first为红黑树结点，则调用**TreeNode的实例方法getTreeNode**获取hash和key对应的结点并返回。
   - 如果first有后继且first为普通结点，则遍历first链表，如果找到hash值相等且（key相等 或者 equals）的结点并返回。如果找不到，则返回null，代表HashMap不存在对应的结点。

### 3.5. HashMap红黑树？

#### TreeNode性质

- **性质1**：红黑树的结点要么是红色，要么是黑色。
- **性质2**：红黑树的根结点是黑色的。
- **性质3**：红黑树的叶子结点（nil）都是黑色的。
- **性质4**：红黑树的红色结点必须有两个黑色结点。
  - **推论**：从根结点到每个叶子结点的所有路径上，不可能存在两个连续的红色结点。
- **性质5**：红黑树是黑色平衡的，即从根结点到每个叶子结点的所有路径中，所经过的黑色结点数都是一样的。
  - **推论**：如果一个结点右黑色的子结点，那么该结点一定是有两个孩子结点，因为必须有另一半才能保证该
    结点黑色平衡。

#### 旋转

- 背景：在结点的添加和删除后，**为了避免子树高度变化，需要通过子树内部调整来保证树达到平衡**，其中2-3-4树是通过结点旋转和结点元素变化实现的，红黑树是通过结点**旋转和变色**实现。
- **左旋**：口诀，**左右左右右**，即以x结点作为旋转点进行**左**旋，旋转后，x的**右**结点p成为x的父结点，p原本的**左**结点成为x结点的**右**结点，p原本的**右**结点保持不变。
- **右旋**：口诀，**右左右左左**，即以x结点作为旋转点进行**右**旋，旋转后，x的**左**结点p成为x的父结点，p原本的**右**结点成为x结点的**左**结点，p原本的**左**结点保持不变。

#### 插入后平衡红黑树

**balanceInsertion（TreeNode，TreeNode）**：对应2-3-4树的情况：

- **a. 空结点新增**：成为一个2结点，插入前树为null，插入后x需要变黑色，作为根结点。
- **b. 合并到2结点中**：成为一个3结点，插入前2结点为黑色，插入后无论是（上黑下左红 |  上黑下右红）, 都符合3结点要求，因此无需调整。
- **c. 合并到3结点中**：成为一个4结点，插入前为3结点（上黑下左红 |  上黑下右红），插入后成为4结点黑红红的情况，根据x插入位置不同分为6种情况：
  - **c.2.1.**  左三(中左左*) ，黑红红，不符合红黑树定义 => 需要调整，则中1右旋，中1变红，左1变黑。
  - **c.2.2.** 中左右*(其实就相当于左三，因为对父结点进行左旋，即得到左三) ，黑红红，不符合红黑树定义 => 需要调整，则左1左旋（得到左三），中1右旋，中1变红，新左变黑。
  - **c.2.3.** 右三(中 右右*) ，黑红红，不符合红黑树定义 => 需要调整，则中1左旋，中1变红，右1变黑。
  - **c.2.4.** 中 右左*(其实就相当于右三，因为对父结点进行右旋，即得到右三) 黑红红，不符合红黑树定义 => 需要调整，则右1右旋（得到右三），中1左旋，中1变红，新右变黑。
  - **c.2.5.** 中左 右*，黑红 红，符合红黑树定义 => 无需调整。
  - **c.2.6.** 中左* 右，黑红 红，符合红黑树定义 => 无需调整。
- **d. 合并到4结点中**：成为一个裂变状态（变色后相当于升元了），插入前为4结点（黑红红），插入后4结点颜色反转，爷结点成为新的x结点，准备下一轮的向上调整，根据x插入的位置不同分为4种情况：
  - **d.2.1.** 中左左* 右(黑红红 红)，不符合红黑树定义 => 需要调整，则中变红，左1变黑，左2保持为红， 右1变黑，中看作为“插入结点”，继续向上调整。
  - **d.2.2.** 中左右* 右(黑红红 红)，不符合红黑树定义 => 需要调整，则中变红，左1变黑，右1保持为红，右2变黑，中看作为“插入结点”，继续向上调整。
  - **d.2.3.** 中左 右左*(黑红 红红)，不符合红黑树定义 => 需要调整，则中变红，左1变黑，左2保持为红，右1变黑，中看作为“插入结点”，继续向上调整。
  - **d.2.4.** 中左 右右*(黑红 红红)，不符合红黑树定义 => 需要调整，则中变红，左1变黑，右1变黑，右2保持为红，中看作为“插入结点”，继续向上调整。

#### 删除结点前/后平衡红黑树

**balanceDeletion（TreeNode，TreeNode）**：删除结点前/后平衡红黑树，如果x所在结点为2-3-4树的2结点，则平衡后再删除，如果x所在结点为3结点或者4结点，在平衡前对应的结点就已经删除了，此时x作为该结点的替代结点而保留下来：

- **x自己搞得定**：
  - 自己搞得定的意思就是，可以**在自己结点内部处理完毕**（对应2-3-4树结构），不影响其他树的结构。
  - **a.1. x为3结点或者4结点的红结点**：直接置黑返回x结点即可调整完毕（因为x是作为替代结点而保留下来的），然后交由上层方法删除x结点。
- **x自己搞不定，兄弟搞得定**：
  - 自己搞不定的意思就是，自身结点为黑结点，如果直接删除会导致父结点所在的树黑色不平衡。
  - 兄弟搞得定的意思就是，**兄弟结点存在多余的子结点**（即兄弟结点为3结点或者4结点），此时，x的父结点就可以借出结点下来合并到x结点中，兄弟结点再借出结点合并到父结点中，这样x就可以顺利删除了，同时2-3-4树的结构还保持不变。
  - 但是，**前提是x的兄弟结点是真正的兄弟结点，即为黑色的结点**，如果为红色的结点，说明其只是父结点（3结点）的红结点，此时需要对父结点进行旋转，以保证x有真正的兄弟结点。
  - **b.1. 兄弟结点为3结点，但无右（左）**：在x在左子树一方时，x的兄弟结点xpr为右子树，如果xpr无右孩子在对父结点左旋时，会导致xpr为null，导致2-3-4树的结构不正确，因此，**b.1是一个临时情况，需要对xpr进行右旋，转换为b.2有右进一步处理**。x为右子树一方时则相反。
  - **b.2. 兄弟结点为3结点，但有右（左）**：在x在左子树一方时，x的兄弟结点xpr为右子树，如果xpr有右，则可以顺利地对父结点xp进行左旋。左旋后，在2-3-4树结构看来，xp作为xpr的左孩子（相当于父结点借出去一个结点，合并到x结点中），xpr作为xp的父亲（**相当于兄弟结点借出去一个结点，合并到父结点中**），xpr借出去的结点颜色为xp借出去的结点颜色，xp借出去的结点颜色一定要为黑色（相当于3结点），xpr剩余结点一定要为黑色（相当于叶子结点），返回x结点即可调整完毕，交由上层方法删除x结点。x为右子树一方时则相反。
  - **b.3. 兄弟结点为4结点，肯定有右**：在x在左子树一方时，x的兄弟结点xpr为右子树，如果xpr有右，则可以顺利地对父结点xp进行左旋。左旋后，在2-3-4树结构看来，xp作为xpr的左孩子（相当于父结点借出去一个结点，合并到x结点中），xpr作为xp的父亲（**相当于兄弟结点借出去一个结点，合并到父结点中，而且还多借出左孩子合并到x结点中**），xpr合并到父结点的颜色为xp借出去的结点颜色（而借出去的左孩子本来为红色所以不用变），xp借出去的结点颜色一定要为黑色（相当于4结点），xpr剩余结点一定要为黑色（相当于叶子结点），返回x结点即可调整完毕，交由上层方法删除x结点。x为右子树一方时则相反。
  - 在b.3中对于兄弟结点为4结点时，兄弟结点可以借出1个结点（需要旋转两次）或者2个结点（只需要旋转一次），**在JDK中无论是HashMap还是TreeMap，都选择借出2个结点，因为可以减少花销。**
- **x自己搞不定，而且兄弟也搞不定**：
  - 自己搞不定的意思就是，自身结点为黑结点，如果直接删除会导致父结点所在的树黑色不平衡。
  - 兄弟也搞不定的意思就是，**兄弟结点也为黑结点，没有多余的子结点**，如果直接删除x，则导致叔结点所在路径多了一个黑色结点，造成黑色不平衡。
  - **c.1. 兄弟结点为2结点**：此时，为了让x能够顺利删除，**兄弟结点需要置红（自损）**，这样x在删除后，x父结点所在树还是黑色平衡的。但是，如果x父结点为黑色，x爷结点所在树则不黑色平衡了（因为父结点这边少了一个黑色结点），所以父结点的叔结点要也要被置红。**因此需要一路向上自损，直到碰到任意一个终止条件即可结束**：
    - **自损的终止条件1（向上碰到根结点）**：经过一路置红叔结点（置红叔结点是没问题的，因为出现该情况是叶子结点为3结点黑黑黑的时候，此时如果叔结点没有孩子结点即为黑色，而对于更上层的叔结点来说，貌似不会出现叔为黑红红这种情况），直到循环到根结点时（因为上面已经没有父节点了），则代表自损完毕，此时整棵树都是黑色平衡的了（都减少了一个黑色结点）。
    - **自损的终止条件2（向上碰到红结点）**：如果碰到红色结点时，只需要把该结点置黑，则不需要在置红叔结点了，此时相当于在父结点这边子树补回了一个黑色结点，而不影响叔结点那边子树的黑色结点数目，因此整棵树还是黑色平衡的。

#### 链表树化成红黑树

HashMap的实例方法treeBin，先判断散列表容量是否大于等于64，如果不是则调用resize扩容即可，否则维护桶链表为**双向无环链表**，接着底层调用**TreeNode的实例方法treeify**树化该链表成为红黑树，其步骤为：

1. 取桶头结点作为根结点，置黑。
2. 遍历桶链表，比较根结点hash值比较当前结点x的hash值大小，小于等于的继续遍历左子树，大于的遍历右子树，然后插入当前遍历结点到对应的位置，再平衡红黑树。

#### 红黑树退化成普通链表

**untreeify（HashMap）**：

1. 遍历桶链表，重新构建后继为null的Node结点，再重新维护每个结点的next指针。
2. 遍历结束，最后返回链头指针hd即可。

#### 添加红黑树结点

**putTreeVal（HashMap，Node，int，K，V）**：红黑树结点的添加方法（插入成功则返回null，插入失败则
返回已经存在的结点）。其步骤为：

1. 从根结点遍历比较插入结点x的hash值，小于等于0的说明x应该在左边，大于0的说明
   x应该在右边。
2. 找到合适位置后（叶子结点），构建TreeNode结点，维护x与父结点、prev结点、next结点的关系。
3. 插入后平衡红黑树，返回null，表示插入成功。

#### 删除红黑树结点

**removeTreeNode（HashMap，Node，boolean）**：

- **替代结点**：红黑树是一种自平衡的二叉搜索树，而二叉搜索树删除，本质上是**找前驱或者后继结点来替代删除**（这里是replacement替代p然后删除p）。
- **A. 如果要删除的结点是叶子结点**：则直接删除即可（肯定为黑色）。
- **B. 如果要删除的结点只有一个孩子结点**：则使用孩子结点进行替代，然后删除"替代结点"。
- **C. 如果要删除的结点有两个孩子结点**：则需要找到前驱或者后继进行替代，然后删除"替代结点"。
  - **C.1. 如果替代结点没有孩子结点**：此时所在的结点为2-3-4树的2结点，则直接要"替代结点"即可。
  - **C.2. 如果替代结点有孩子结点且孩子结点为替代方向**：此时所在的结点为2-3-4树的3结点或者4结点，则继续使用孩子结点进行替代，然后“替代结点”即可（二次替代）。
- 无论是哪种情况，红黑树结点的删除方法，都要调用平衡红黑树的方法，在删除结点前/后平衡红黑树。

#### 获取红黑树结点

**getTreeNode（int，Object）**：

1. 根据hash值和key值，从根结点开始查找红黑树结点，小于等于0的说明x应该在左边，大于0的说明x应该在右边。
2. 直到找到hash值相等且（key相等 或者 equals），说明该结点就是要找的结点，则返回即可。
3. 如果找不到，则返回null，代表没找到对应的结点。

### 3.6. JDK1.7 HashMap与JDK1.8 HashMap的区别？

JDK1.8 主要解决或者优化了以下问题：

- resize（）扩容优化：取消了rehash，分高低位转移链表，保证转移后结点相对顺序不变，从而解决了多线程死循环问题。但HashMap仍是非线程安全的，并发添加结点可能会造成数据丢失。
- 插入方式改成尾插法，同时引用红黑树，避免链表过长影响查找效率，同时保证插入的性能。
- **解决了tomcat臭名昭著的url参数dos攻击问题？**

|                  | JDK1.7 HashMap                                               | JDK1.8 HashMap                                               |
| ---------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 数据结构         | 数组 + 链表                                                  | 数组 + 链表 + 红黑树                                         |
| HashCode扰动函数 | 9次扰动（4次移位，5次异或），有哈希种子影响                  | 2次扰动（1次移位，1次异或），无哈希种子                      |
| 扩容方法         | 可以rehash（容量 > 哈希种子阈值时），转移后结点相对顺序反转（头插法） | 无rehash，分高低位转移链表，转移后结点相对顺序不变           |
| 插入方法         | 无冲突，则插入数组；有冲突，则插入链表（头插法）             | 无冲突，则插入数组；有冲突，则插入链表（尾插法）；有冲突 & 插入后链表长度 >= 8，且散列表容量 >=64，则把链表树化成红黑树 |

### 3.7. 如果实现散列表线程安全？

- HashMap API外层使用**锁**保证线程安全。
- **Collections内部类SynchronizedMap**，通过持有传入的Map引用，以及Object mutex对象锁，提供synchronized关键字修饰Map接口方法，从而包装成线程安全的Map。
- **HashTable**，散列表的线程安全实现类，默认初始容量11，默认负载因子0.75，不允许为null键和null值，通过使用synchronized关键字修饰方法保证线程安全，效率低下。
- **ConcurrentHashMap**，支持高并发检索和更新的散列表实现类，默认初始容量和负载因子与HashMap一样，不允许为null键和null值，可在保持并发可读的同时最小化锁竞争。

### 3.8. 详细介绍ConcurrentHashMap？

#### 特点

- ConcurrentHashMap，**一个支持高并发检索和高并发更新的散列表实现类**，实现ConcurrentHashMap接口，不允许为null键和null值。其主要设计目标是**保持并发可读性，同时最小化更新时的锁争用**，次要目标是保持与java.util.HashMap相同或更好的空间消耗，并支持许多线程对空表的高初始插入率（自旋+CAS保证）。
- 几个重要的参数：
  - **当前容量**：当前容量是散列表中存储桶的数量，而初始容量只是创建散列表的容量。
  - **控制变量sizeCtl**：通常等于通常等于0.75 * 容量，但在构造函数中等于初始容量；散列表初始化时为-1；散列表在扩容时，高16位为扩容标记，低16位为并发扩容线程数（从2开始, 步长为+1）。
  - **分布计数变量**：计数基数baseCount，分布计数单元格数组counterCells，单元格繁忙标记cellsBusy。
  - **转移相关变量**：转移最小块索引transferIndex，可以减少协助转移结点时的竞争；转移目标散列表nextTable。
- 几种类型的结点：
  - **Node**：实现Map.Entry，是ConcurrentHashMap中最普通的链表结点，拥有hash、key、val、next成员变量，是其他类型结点的父类，其中val和next使用volatile修饰，保证线程可见性。
  - **TreeNode**：继承Node结点，是ConcurrentHashMap中的红黑树结点，在Node结点的基础上还维护了parent、left、right、red红黑树成员变量。
  - **TreeBins**：
    - 继承Node结点，是ConcurrentHashMap中红黑树的桶结点，hash值为-2，持有红黑树根结点root指针和链头first指针，不保存键和值。
    - 同时维护了读写锁，强迫写线程必须等待所有读线程完成后，才能进行红黑树结点操作。
    - 当读时不存在并发写线程，使用root指针走红黑树遍历方式查找结点；当读时存在并发写线程，使用first指针走链表遍历方式查找结点。
  - **ForwardingNode**：
    - 继承Node结点，是ConcurrentHashMap中的转发结点，hash值为-1，持有nextTable引用，没有键和值。
    - 在线程协助转移结点到新表后，会在旧表原位置维护一个Forwarding结点，以标识旧表正在发生扩容操作，让下一个线程碰到时可以协助进行转移旧表结点。
  - ReservationNodes：（不懂不要说）不保存hash值、key和value。用作占位符，同时在computeIfAbsent和相关方法中建立值。
- 几个重要方法：
  - **get方法**：
    - 一般不会阻塞，可与put和remove等更新方法同时执行，**反映的是最近完成更新的结果**，因此，对于putAll操作，并发检索可能只反映出插入的某些条目。
    - 类似的，迭代器反映的也是散列表在迭代器创建时，或者创建后的某个时刻的状态的
      元素，不会抛出 {@link java.util.ConcurrentModificationException
      ConcurrentModificationException}。
  - **size方法**：
    - 通常仅在Map不存在并发更新时才有用，否则结果反映的是瞬态状态，并不是准确的数值。
    - 因此可以用于监测或估计目的，而不适用于程序控制。
    - 其中size并发计数实现参考的是LongAdder，CounterCell计数数组机制避免了更新计数时的锁争用，但如果在并发访问期间读取过于频繁，可能会遇到缓存抖动（为了保证缓存一致性而出现的等待）。
  - **put与remove方法**：
    - 对于hash值为-1的ForwardingNode结点，会协助进行转移结点。
    - 对于hash值为-2的TreeBins结点，会先对结点进行加锁，获取到锁后才再用红黑树方式添加key-value。
    - 对于普通Node结点，会对桶头结点进行加锁，获取到锁后再使用链表方法添加key-value。
  - **扩容方法**：
    - 当散列表容量超过阈值时（ 0.75），则需要扩容散列表，sizeCtl字段中的生成戳resizeStamp，可保证其扩容不会重复执行。
    - 在启动扩容和设置nextTable之后，任何注意到forwarding结点或者桶过满的线程，都可以协助转移散列表结点，转移线程会根据transferIndex索引字段，小块小块地进行转移结点，从而减少争用。然而，这些线程可能会继续进行插入等操作，而不是停顿。
    - 由于散列表根据2的幂次进行扩容，所以每个桶中的元素要么保持相同的索引，或者以2次幂的偏移量
      进行移动。通过捕获可以重用的旧结点，来消除不必要的结点创建，因为它们的next指针不会改变。
    - 在结点转移后，会在旧表桶中保留一个特殊的转发节点（具有哈希字段“MOVED”），在遇到转发节点时，访问和更新操作会使用持有的nextTab作为新的散列表而重新启动。

#### 数据结构

数组 + 链表 + 红黑树，锁有CAS+自旋锁、synchronized可重入锁、TreeBin读写锁。

![1625493877273](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1625493877273.png)

#### 构造方法

- 5个构造方法，分别为空参的、指定初始容量的、指定初始容量和负载因子的、指定初始容量、负载因子和并发线程数的（concurrencyLevel只是为了兼容JDK1.7 ，第一不为负数就好，第二在initialCapacity < concurrencyLevel时赋值initialCapacity 为concurrencyLevel）、指定复制集合的。
- 默认负载因子为0.75，默认容量为16。

#### HashCode扰动函数

- **spread（int）**：HashCode右移16位，从而**混合HashCode的高位和低位，加大低位的随机性，减少哈希碰**
  **撞发生的概率**，是一种性能、效用和质量的折衷方案。
  - 使用简单的位移与异或操作，减少系统的计算损耗；使用高位异或，可以减少低位冲突的可能性，保证查
    找效率。
  - HashCode右移16位，使得高位能被利用起来，保证了效用性。
  - 使用高位异或，可以减少低位冲突的可能性，保证散列表的质量。

#### 哈希索引的计算方法

- **（n - 1） & hash，相当于hash % n**：n指散列表的当前容量（桶数量），hash指获取hash（key）即key的hashCode扰动后结果。
  - **不能直接使用HashCode作为索引的原因**：int类型的hashCode，范围为[-2^32，2^32 - 1]，如果散列表
    数组与HashCode一一对应，需要40亿的空间（int[40亿]），明显这在内存是放不下的，也就是说明
    hashCode是不能直接作为数组索引的。因此，如果使用hashCode对散列表数组长度取模，那么就可以解决这个问题，从而保证较小的数组也还能利用上hashCode。
  - **n为2的幂次原因**：为了解决hashCode对散列表数组长度取模，设计了HashCode的扰动函数以及为2幂次的容量n，可以通过n-1来获得取模操作的低位掩码，此时**只需要通过低位掩码与扰动后的**
    **hashCode（hash值）进行一次与运算**，即可得到该hash值在散列表数组中的索引。其次通过在扩容方
    法中，经过hash值与低位掩码相与，可以保证扩容后，**只会移动少部分相与结果高位为1的桶链表**，其他
    保持不变，减少了扩容时的时间。
- **通过tableSizeFor（int）返回给定目标容量的2的幂次**，底层通过-1，右移1、2、4、8、16位，再+1得到目标容量。

#### 获取扩容标记方法

- **resizeStamp（int）**：
  - 获取容量n的扩容标记位，用于更新为sizeCtrl。
  - 等于容量n的高0位数值 | 1 << 15。高16为扩容标记，第16位为并发扩容线程数(从2开始, 步长+1)。结果肯定为负数。

#### 并发计数更新方法

在putVal和removeNode方法更新元素后，先并发叠加计数x，叠加成功后做扩容判断。其并发叠加计数x步骤为：

1. 先尝试在baseCount叠加x，如果叠加成功，则继续做扩容判断。
2. 如果baseCount叠加x失败，则根据当前线程哈希值h=ThreadLocalRandom.getProbe()，尝试在CounterCell[h * (n-1)]叠加x，如果叠加成功，则继续做扩容判断。
3. 如果CountCell叠加x失败，则调用fullAddCount 自旋+CAS 竞争添加到CounterCell[] as，其步骤为：
   - 如果as不为null，则判断CounterCell[h & (n-1)]是否为null：
     - 如果CounterCell[h & (n-1)]为null，则CAS竞争创建CounterCell[h & (n-1)]，竞争成功则叠加x结束自旋，竞争失败则继续自旋，如果创建前as繁忙（as正在初始化/扩容/叠加x），则标志为已冲突，获取新的线程哈希值h，继续自旋。
     - 如果CounterCell[h & (n-1)]不为null，则CAS竞争在CounterCell[h & (n-1)]上叠加x，竞争成功则结束自旋，竞争失败则获取新的线程哈希值h，继续自旋。
     - 否则，如果CounterCells数组引用发生变更或者长度超出CPU核心数，则也会标志为已冲突，获取新的线程哈希值h，继续自旋。
     - 否则，如果连续冲突2次，还没竞争叠加x成功，则扩容2倍CounterCells数组，扩容完毕后继续自旋。
   - 如果as为null或者为空，则CAS竞争初始化as = new CounterCell[2]，竞争成功则叠加x到as[h & 1]中，结束自旋。
   - 如果as竞争初始化失败，则叠加x到baseCount中，结束自旋。

#### 并发扩容方法

- 并发扩容时使用到的一些判断条件：

```java
// 第一个扩容线程时，CAS更新并发阈值sizeCtl，此时sc为rs <<< 16 + 2
U.compareAndSwapInt(this, SIZECTL, sc, (rs << RESIZE_STAMP_SHIFT) + 2)
    
// 其他协助转移线程加入结点转移工作时，CAS更新并发阈值sizeCtl，此时sc + 1
U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)
    
// 通过sizeCtl判断当前线程扩容是否为ConcurrentHashMap的同一次扩容
(sc >>> RESIZE_STAMP_SHIFT) == rs 

// 当前线程完成转移工作后，CAS更新并发阈值sizeCtl，此时sc-1
U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)
    
// 通过sizeCtl判断当前线程是否为最后一个提交转移工作的线程
(sc - 2) != resizeStamp(n) << RESIZE_STAMP_SHIFT
```

- 启动扩容前判断：如果sumCount（）> sizeCtl且 当前容量 < 最大容量，则说明需要扩容，扩容启动步骤为：
  1. resizeStamp（n）获取扩容标记rs，如果rs小于0，说明散列表正在被其他线程扩容，则CAS更新sizeCtrl=sc+1，更新成功后调用transfer(tab, nt)，加入扩容一起转移结点。
  2. 如果rs大于等于0，说明散列表还没被扩容，则CAS更新sizeCtrl=(rs << RESIZE_STAMP_SHIFT) + 2)，更新成功后调用transfer(tab, null)，开始扩容创建nextTab并转移结点。
  3. 要注意的是，在addCount（long，int）方法中，转移tab到nextTab完成返回后，还要继续判断nextTab是否需要扩容，如果nextTab也在扩容中，则加入扩容一起转移结点。
- transfer（Node[]，Node[]）：转移旧散列表tab中的结点到新散列表nextTab中，会在启动扩容、协助扩容处调用。其转移结点的步骤为：
  - 如果nextTab还没创建，则先创建nextTab。
  - 如果nextTab已创建，则转移线程步骤为：
    - 划分转移区间 -> i为转移结点 -> 继续前进划分转移区间，直到没有划分到散列表开头。
    - 划分转移区间 -> i为业务结点-> 锁桶头+转移普通链表/红黑树 -> 转移完成（会在桶处留下forwarding结点） -> 继续前进划分转移区间，直到没有划分到散列表开头。
    - 如果当前线程不为最后一个转移完成线程，即**(sc - 2) != resizeStamp(n) << RESIZE_STAMP_SHIFT**，则直接返回即可，无需提交新散列表nextTab。
    - 如果当前线程为最后一个转移完成线程，即**(sc - 2) == resizeStamp(n) << RESIZE_STAMP_SHIFT**，则进行最后一次检查i与transferIndex（是否到散列表开头），没问题则提交新散列表nextTab（设置为table）。

#### put方法

3个常用的顶层API方法put、putIfAbsent、putAll，它们依赖于putVal方法，其步骤为：

1. hash（key）计算key的hash值，(n - 1) & hash计算出哈希索引，tab[i]得到哈希索引对应散列表的桶p。
2. 如果散列表为null或者n为0，则初始化容量为16的散列表，sizeCtl为12=16 * 0.75。
3. 否则，如果p桶为null，则直接new Node再CAS放到该桶即可。
4. 否则，如果p桶结点hash值-2，说明p为Forwardding结点，则当前线程加入扩容一起转移结点。
5. 否则，如果p不为Forwardding结点，则对桶头结点进行加synchronized锁，再判断桶头结点的哈希值：
   - 如果桶头结点的hash值大于等于0，说明它为普通链表结点，则遍历p链表，如果找到hash值相等且（key相等 或者 equals）的结点，如果此时onlyIfAbsent为false，则发生值替换，直接返回即可。
   - 如果找不到对应的结点，则在链尾new Node一个结点，并且添加后如果当前链表至少有8个结点，则调用**ConcurrentHashMap的实例方法treeBin**将当前桶链表树化为红黑树（treeBin还会判断散列表容量是否大于等于64）。
   - 否则，如果桶头结点的hash小于0即TreeBin结点，说明p为红黑树，则使用**TreeBin的实例方法putTreeVal**添加key：value。
6. 如果发生的不是值替换，则并发更新计数、判断是否需要扩容（要的话则发起扩容）。最后返回null，代表结点插入成功。

#### remove方法

2个常用的顶层API方法remove（Object）和remove（Object，Object），它们都依赖replaceNode方法，其步骤为：

1. hash（key）计算key的hash值，(n - 1) & hash计算出哈希索引，tab[i]得到哈希索引对应散列表的桶p。
2. 如果散列表为null或者n为0，则返回null，代表ConcurrentHashMap不存在对应的结点。
3. 如果桶p为null，则返回null，代表ConcurrentHashMap不存在对应的结点。
4. 否则，如果桶头结点hash值为-2，说明它为Forwardding结点，则当前线程加入扩容一起转移结点。
5. 否则，如果p不为Forwardding结点，则对桶头结点进行加synchronized锁，再判断桶头结点的哈希值：
   - 如果桶头结点的hash值大于等于0，说明它为普通链表结点，则遍历p链表，如果找到hash值相等且（key相等 或者 equals）的结点（如果此时指定了value，则还需要判断value是否equals），则脱钩该结点。
   - 如果找不到，则返回null，代表ConcurrentHashMap不存在对应的结点。
   - 否则，如果桶头结点的hash小于0即TreeBin结点，说明p为红黑树，则调用**TreeNode的实例方法getTreeNode**获取hash和key对应的结点，调用**TreeNode的实例方法removeTreeNode**删除该结点。
6. 最后如果脱钩结点成功，则并发更新计数，返回旧值，代表删除成功。

#### get方法

2个常用的顶层API方法get、getOrDefault，getOrDefault依赖get方法，其中val和next使用volatile修饰，保证线程可见性，所以get方法可以不加锁地照常遍历，而读红黑树由于会涉及到旋转，所以有写时会走链表读，树读时不能写。其步骤为：

1. hash（key）计算key的hash值，(n - 1) & hash计算出哈希索引，tab[i]得到哈希索引对应散列表的桶e。
2. 如果散列表为null或者n为0，则返回null，代表ConcurrentHashMap不存在对应的结点。
3. 如果桶e为null，则返回null，代表ConcurrentHashMap不存在对应的结点。
4. 如果e桶不为null，则分4种情况判断：
   - 如果桶头结点e的hash值相等且（key相等 或者 equals），说明e就是要找的结点，则直接返回e结点。
   - 否则，如果e的hash小于0，说明e可能为转发结点、红黑树结点、computeIfAbsent临时结点，则根据调用各自实现的find方法：
     - 如果e为转发结点，则根据hash以及key对象查找nextTable结点，找到hash相等，且Key
       相等或者equals的结点并返回。
     - 如果e为红黑树结点，则根据hash值和key值，从根结点开始查找红黑树结点 => 同
       HashMap#getTreeNode（int，Object）。
     - 如果e为computeIfAbsent临时结点，则返回null。
   - 否则，如果桶头没找e结点, 则继续遍历e链表, 找到hash值相等, 且Key相等或者equals结点并返回。
5. 最后如果实在找不到key对应的结点，则返回null，代表ConcurrentHashMap不存在对应的结点。

### 3.9. ConcurrentHashMap红黑树？

- 红黑树过程与HashMap类似，但不同的地方在于，TreeBin维护了一个读写锁（写时加锁），读红黑树由于会涉及到旋转，所以有写时会走链表读，树读时不能写。
- 对于TreeBin#putTreeVal或者TreeBin#removeTreeNode方法，即使外层有获取可重入锁synchronized，在操作红黑树之前，也要调用lockRoot()，调用完成后再unlockRoot()。其原理如下：

1. TreeBin持有lockState读写锁状态（WRITER=1，WAITER=2，READER=4，读/写状态可与等待状态结合），以及waiter等待写锁线程。
2. 调用lockRoot时，首先CAS竞争更新lockState为【WRITER】，竞争成功则说明当前线程持有写锁成功，可以继续做红黑树操作，操作完后unlockRoot释放写锁，置lockState为0。
3. 竞争失败，则调用contendedLock继续**争抢写锁**，争抢不到写锁的会进入阻塞状态，直到所有调用TreeBin#find（int，Object）的线程调用完毕后才会被唤醒，然后重新争抢写锁。
   - 如果当前红黑树不存在写或者读线程【((s = lockState) & ~WAITER) == 0】，则当前线程去竞争写锁，如果竞争成功则返回，否则继续自旋。
   - 否则，如果还不存在等待写锁的线程【(s & WAITER) == 0】，则当前线程去竞争成为等待写锁的线程，竞争成功则成为等待写锁的线程，否则继续自旋。
   - 否则，说明当前线程为等待锁的线程，但竞争写锁还是失败，则进入阻塞状态。而那些争抢不到写锁, 也进入不了阻塞状态成为等待写锁的线程，会一直自旋等待锁状态变更。
4. TreeBin#find（int，Object）**更新读锁状态**：
   - 如果当前红黑树存在写线程或者等待写锁线程【((s = lockState) & (WAITER|WRITER)) != 0】, 为了减少锁竞争以便写操作尽快完成，则以遍历链表的方式去遍历出红黑树结点并返回。
   - 否则，说明当前红黑树没有写线程或者等待写锁线程，则CAS叠加lockState读锁状态（每个读线程叠加一次【READER】）， 然后再以红黑树方式去遍历红黑树结点并返回。

### 4.0. JDK1.7 ConcurrentHashMap与JDK1.8 ConcurrentHashMap的区别？

JDK1.8 主要优化了以下内容：

- 取消Segment[]+HashEntry[]+链表的数据结构，改用Node[]+链表+红黑树的数据结构，提升查找效率。
- 取消了hashSeed参与HashCode扰动。
- 取消了Segment+HashEntry+ReentrantLock分段锁，改用Node+CAS自旋锁+synchronized+TreeBin读写锁来保证并发安全，其中synchronized只锁定桶结点，红黑树读写锁使并发读性能得到提升。
- 取消了concurrencyLevel作为Segment[]长度，JDK 1.8 ConcurrentHashMap的concurrencyLevel为了兼容JDK1.7 ConcurrentHashMap，实际意义不大（第一不为负数就好，第二在initialCapacity < concurrencyLevel时赋值initialCapacity 为concurrencyLevel）。
- 取消了获取可重入锁后添加结点+计数+扩容的方式，改用添加结点后，释放synchronized+CAS自旋锁+并发计数+并发扩容方式提高并发量。

|                  | JDK1.7 HashMap                                        | JDK1.8 HashMap                                               |
| ---------------- | ----------------------------------------------------- | ------------------------------------------------------------ |
| 数据结构         | 数组 + 链表                                           | 数组 + 链表 + 红黑树                                         |
| HashCode扰动函数 | 16次扰动（7次移位，4次相加，5次异或），有哈希种子影响 | 2次扰动（1次移位，1次异或），无哈希种子                      |
| 并发安全原理     | Segment+HashEntry+ReentrantLock分段锁                 | Node+CAS自旋锁+synchronized+TreeBin读写锁                    |
| 构造方法         | concurrencyLevel作为Segment[]长度                     | concurrencyLevel为了兼容JDK1.7 ConcurrentHashMap，实际意义不大 |
| 扩容方法         | 获取可重入锁后，添加结点+计数+扩容                    | 添加结点后，释放synchronized+CAS自旋锁+并发计数+并发扩容     |

# 二、JVM篇 

### 1.1. JDK、JRE、JVM的区别？

![1625884268478](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1625884268478.png)

从图中可以看出，**JDK包含了JRE，而JRE又包含了JVM**。

- **JDK**，Java Development Kit，是Java的软件开发工具包（SDK），包含JRE和Java工具。
- **JRE**，Java Runtime Environment，是Java的运行时环境，大部分都是C和C++语言编写的，可以在其上运行、测试应用程序的Java平台，包括JVM和Java核心类库。
- **JVM**，Java Virtual Machine，Java虚拟机，是一种用于计算设备的规范，是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的，屏蔽了与具体平台相关的信息，使得Java语言编译程序只需要在Java虚拟机上运行的字节码，就可以不加修改地在多种平台上运行。

### 1.2.  JVM整体架构？

![1625963806257](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1625963806257.png)

- JVM包含**2个子系统和2个组件**：2个子系统分别为Class Loader（类加载子系统）、Execution Engine（执行引擎）；2个组件分为别Runtime data area（运行时数据区）、Native Interface（本地接口）。
  - **Class loader（类加载子系统）**：根据给定的全限定名类名（如java.lang.Object）来装载class文件到Runtime data area中的Method Area（方法区）。
  - **Runtime data area（运行时数据区域）**：这就是我们常说的JVM的内存。
  - **Execution engine（执行引擎）**：执行class文件中的指令。
  - **Native Interface（本地接口）**：与native libraries交互，是其它编程语言交互的接口。
- 架构整体流程：

1. 通过编译器把 Java 代码转换成字节码，**类加载器（ClassLoader）**再把字节码加载到内存中，将其放在**运行时数据区（Runtime data area）**的方法区内。
2. 而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器**执行引擎（Execution Engine）**，将字节码翻译成底层系统指令，再交由 CPU 去执行。
3. 而这个过程中需要调用其他语言的**本地接口（Native Interface）**来实现整个程序的功能。

### 1.3. 详细介绍类加载机制？

![1625975271139](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1625975271139.png)

程序主动使用某个类时，如果这个类还未被加载到内存中，则JVM会通过**加载、链接、初始化**3个步骤来对该类进行初始化。如果没有意外，JVM将会连续完成3个步骤，所以有时也把这个3个步骤统称为**类加载或类初始化**。

1. **加载**：指的是将类的**class文件（二进制数据）**读入到内存，并转换成**方法区中的运行时数据结构**。同时在堆中生成一个代表这个类的**java.lang.Class对象**，该对象封装了类在方法区中的数据结构，并且向用户提供了访问方法区数据结构的接口，即Java反射的接口。
   - 加载过程需要**类加载器**参与。类加载器，可以从不同来源加载类的二进制数据，比如：本地Class文件、Jar包Class文件、网络Class文件等等。
   - Java类加载器由JVM提供，是所有程序运行的基础，JVM提供的这些类加载器通常被称为系统类加载器。
   - 除此之外，开发者可以通过继承ClassLoader基类来创建自己的类加载器。
   - Java的类加载是动态的，不会一次性将所有类全部加载后再运行，而是保证程序运行的基础类完全加载到JVM中。至于其他类，则**在需要的时候才加载**（为了节省内存开销）。
     - **隐式加载**：程序在运行过程中，当碰到通过new 方式生成对象时，将会隐式调用类装载器，加载对应的类到JVM中。
     - **显式加载**：通过class.forname（）反射方法，显式加载需要的类。
2. **链接**：该阶段负责把**类的二进制数据合并到JRE中**，可分为如下3个阶段：
   - **验证**：验证Class文件是否符合规范，是否能被当前的虚拟机加载处理，确保加载的类没有安全方面的问题。
     - 文件验证：是否以0xCAFEBABE开头、版本号是否合理等。
     - 元数据验证：是否有父类、是否继承了final类、非抽象类是否实现了所有抽象方法等。
     - 字节码验证：运行检查、栈数据类型和操作码的操作参数是否吻合（不能大于栈空间）、跳转指令是否指向合理的位置。
     - 符号引用验证：常量池中描述的类是否存在、访问的方法或字段是否存在且有足够的权限。
     - 可使用**-Xverify:none**关闭验证：比如提高IDEA的启动速度。
   - **准备**：为类的静态变量（static）分配内存，并初始化为初始值（0或null）。而对于静态常量（final static修饰）会直接被赋值为用户定义的值。
   - **解析**：将Class常量池（Constant Pool）的符号引用转换为直接引用。
   - 实际上，JVM不一定完全按照类加载机制顺序执行，比如解析操作有可能会发生在初始化操作之后。
3. **初始化**：类初始化是类加载的最后一步，真正执行Java代码，主要工作是为静态变量（static）赋值为用户定义的值。初始化完毕类就可以被使用了。
   - 执行< clinit >方法，clinit方法由编译器自动收集类里面的**所有静态变量的赋值动作及静态语句**合并而成，也叫**类构造器方法**。
     - 初始化的顺序和源文件中的顺序一致。
     - 子类的< clinit >被调用前，会先调用父类的< clinit >。
     - JVM会保证clinit方法的线程安全性。
   - 即执行顺序为：JVMTest5静态块 -> super静态块 -> Sub静态块 -> Super构造块 -> Super构造方法 -> Sub构造块 -> Sub构造方法。
     - 类初始化后，如果是实例化一个新对象，还会调用< init >方法，与< clinit >类似，< init >方法可以看作是**对象构造方法**，是由编译器自动收集类中所有实例变量的赋值动作、实例代码块和构造函数合并而成的。
     - 如果是对实例变量直接赋值或者使用实例代码块赋值，那么编译器会将这些代码合并到实例构造函数中去，并且它们还会被放在对父类构造函数的调用语句之后（因为Java要求构造函数的第一条语句必须是父类构造函数的调用语句)，自身构造函数的代码之前去执行。
     - 因此，类构造器和对象构造器的初始化过程为：**父类的类构造器 -> 子类的类构造器 -> 父类成员变量的赋值和实例代码块 -> 父类的构造函数 -> 子类成员变量的赋值和实例代码块 -> 子类的构造函数。**

```java
// JVMTest5不用被实例化，所以不会调用JVMTest5的构造块和构造方法
public class JVMTest5 {
    static {
        System.out.println("JVMTest5静态块");
    }

    {
        System.out.println("JVMTest5构造块");
    }

    public JVMTest5() {
        System.out.println("JVMTest5构造方法");
    }

    public static void main(String[] args) {
        new Sub();
    }
}

class Super {
    static {
        System.out.println("Super静态块");
    }

    public Super() {
        System.out.println("Super构造方法");
    }

    {
        System.out.println("Super构造块");
    }
}

class Sub extends Super {
    static {
        System.out.println("Sub静态块");
    }

    public Sub() {
        System.out.println("Sub构造方法");
    }

    {
        System.out.println("Sub构造块");
    }
}
```

### 1.4. 什么是类加载器？类加载器有哪些？

![1625986988156](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1625986988156.png)

**类加载器**，是能够实现通过类的全限定名，获取该类的二进制字节流的**代码块**。JVM提供了3种类加载器，启动类加载器、扩展类加载器、系统类加载器（也叫应用类加载器），以及用户自定义的类加载器（其父类为应用类加载器）。

- **启动类加载器**：Bootstrap ClassLoader，该类加载使用C++实现，其引用为null，无法被java程序直接引用。用于加载Java核心类库，即负责把**/lib**目录下或者**-Xbootclasspath**参数指定路径下的Jar包加载到内存中。
  - 注意，JVM是按照文件名识别加载Jar包，如rt.jar，如果文件名不被虚拟机识别，即使把Jar包丢到lib目录下也是没有作用的。
  - 处于安全考虑，启动类加载器只能加载包名为java、javax、sun等开头的类。
- **扩展类加载器**：ExtClassLoader，由Java实现，父类加载器为启动类加载器（持有为null的parent引用，并不是真正的继承关系）。用于加载 Java 的扩展库，即负责把**/lib/ext**目录下或者**-Djava.ext.dir**参数指定路径下的类库加载到内存中。
  - 开发者可以直接使用标准的扩展类加载器。
- **系统类加载器**：AppClassLoader，也叫应用类加载器，由Java实现，父类加载器为ExtClassLoader（持有ExtClassLoader的parent引用，并不是真正的继承关系）。用于加载一般的Java 应用类，即负责把**java -classpath**或者**-D java.class.path**指定路径下的类库加载到内存中。
  - 一般情况下，系统类加载器是程序中默认的类加载器。
  - 开发者可以直接使用应用类加载器，可以通过**ClassLoader.getSystemClassLoader（）**来获取。
- **用户自定义的类加载器**：用户可以通过继承 java.lang.ClassLoader类的方式，来自定义自己的加载器。
  - 应用场景：
    - 加密编译后的class字节码 ->  自定义ClassLoader -> 加载该class时解密字节码。
    - 自定义ClassLoader，加载时从非标准来源加载字节码：比如数据库、网络上。

### 1.5. 什么是双亲委派机制？

#### 概念

加载器之间存在着"父子关系"（区别于Java里的继承），子加载器保存着父加载器的引用。

1. 当一个类加载器需要加载一个目标类时，先会去缓存中查找，如果找到，则解析或者返回。
2. 如果缓存中找不到，则委托给父加载器加载，父加载器会在自己的加载路径中搜索目标类，如果找到，则解析或者返回。
3. 如果找不到，才会交还子加载器加载目标类，查找逻辑交由子加载器实现。

#### 实现原理

- **java.lang.ClassLoader**：扩展类、系统类以及自定义的加载器都继承这个类，需要实现findClass方法。
- **loadClass（String，boolean）**：类加载方法，子类在查询缓存中没有加载该Class后，会调用该方法，走双亲委派机制去查找。
- **findClass（String）**：加载器自身去加载Class的方法，交由子类去实现。比如子类URLClassLoader（ExtClassLoader和AppClassLoader的父类），根据URL找到对应的Class文件后，会调用**defineClass（String，Resource）**方法生成Class对象。
- **resolveClass（Class<?>）**： 底层调用native方法，解析生成出来的Class对象，将Class常量池（Constant Pool）的符号引用转换为直接引用，且为类变量（静态变量/实例变量[在该对象实例化时]）分配内存并设置初始值。
- **defineClass（String，Resource）**：在Java堆区生成Class对象。

```java
// java.lang.ClassLoader#loadClass：扩展类、系统类以及自定义的加载器都继承这个类，需要实现findClass方法
public abstract class ClassLoader {
    
    // 类加载方法，子类在查询缓存中没有加载该Class后，会调用该方法，走双亲委派机制去查找
    protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
        synchronized (getClassLoadingLock(name)) {
            // 当一个类加载器需要加载一个目标类时，先会去缓存中查找，如果找到，则解析或者返回
            Class<?> c = findLoadedClass(name);// native方法
            if (c == null) {
                long t0 = System.nanoTime();
                try {
                    // 如果缓存中找不到，则委托给父加载器加载，父加载器会在自己的加载路径中搜索目标类，如果找到则解析或者返回
                    if (parent != null) {
                        c = parent.loadClass(name, false);
                    } 
                    // 交由启动类加载器加载
                    else {
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // ClassNotFoundException thrown if class not found
                    // from the non-null parent class loader
                }

                if (c == null) {
                    // If still not found, then invoke findClass in order
                    // to find the class.
                    long t1 = System.nanoTime();
                    c = findClass(name);

                    // this is the defining class loader; record the stats
                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);
                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);
                    sun.misc.PerfCounter.getFindClasses().increment();
                }
            }

            // 底层调用native方法，解析生成出来的Class对象，将Class常量池（Constant Pool）的符号引用转换为直接引用，且为类变量（静态变量/实例变量[在该对象实例化时]）分配内存并设置初始值
            if (resolve) {
                resolveClass(c);
            }

            // 返回class
            return c;
        }
    }
    protected final Class<?> findLoadedClass(String name) {
        if (!checkName(name))
            return null;
        return findLoadedClass0(name);
    }
    private native final Class<?> findLoadedClass0(String name);
    
    // 底层调用native方法，解析生成出来的Class对象，将Class常量池（Constant Pool）的符号引用转换为直接引用，且为类变量（静态变量/实例变量[在该对象实例化时]）分配内存并设置初始值
    protected final void resolveClass(Class<?> c) {
        resolveClass0(c);
    }
    private native void resolveClass0(Class<?> c);

    // 加载器自身去加载Class的方法，交由子类去实现。比如子类URLClassLoader（ExtClassLoader和AppClassLoader的父类），根据URL找到对应的Class文件后，会调用defineClass(String，Resource)方法生成Class对象
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        throw new ClassNotFoundException(name);
    }
}
```

#### 双亲委派模型好处

- 此机制保证了Java核心类库被优先加载，避免了用户编写的类动态替换Java核心类的错误，使得Java程序能够稳定运⾏。
- 同时也避免了类的重复加载，使用双亲委派模型，JVM能够根据**类的完整类名+ClassLoader实例对象**来区分不同的类。如果不使⽤双亲委派模型，⽽是每个类加载器⾃⼰加载的话，会出现⼀些问题。⽐如编写⼀个称为 java.lang.Object 类的话，在程序运⾏的时候，系统会有多个不同的Object 类，此时会出现Object类的选择问题。

#### 双亲委派模型局限

1. SPI接口，Service Provider Interface，允许第三方为其提供实现，如JDBC、JNDI等 。
2. SPI接口属于Java核心类库，由启动类加载器加载（rt.jar），而SPI的第三方代码则是作为Java应用所依赖的Jar中（Classpath下）。
3. 其中SPI接口中的代码经常需要加载具体的第三方实现类，并调用其相关方法，此时由于双亲委派模型的存在，启动类加载器无法直接加载SPI实现类，也无法反向委托给系统类加载器加载，从而让JDK SPI机制产生了问题。

#### 打破双亲委派模型

如果不想打破双亲委派模型，则只需要重写findClass方法即可；如果想打破双亲委派模型，则需要重写整个loadClass方法。

##### 线程上下文类加载器

- **背景**：由于双亲委派模型存在SPI局限，需要一种特殊的类加载器来加载第三方类库，此时线程上下文加载器是个很好的选择。
- **线程上线文类加载器**：是从JDK 1.2开始引入的，可以通过java.lang.Thread#getContextClassLoader（）和setContextClassLoader（ClassLoader）方法来获取和设置线程的上下文类加载器。如果没有手动设置，则线程将会继承父线程的上下文类加载器，默认为系统类加载器，即在线程中运行的代码可以通过此类来加载Classpath下的类和资源。
- **打破双亲委派**：从图中可以看到，启动类加载器委派线程上下文加载器，把jdbc.jar中的实现类加载到内存中以便SPI相关类使用，因此打破了双亲委派模型，使得Java类加载更加灵活。

![1625996283343](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1625996283343.png)

- **实现原理**：
  - contextClassLoader是在ClassLoader.SystemClassLoaderAction#run（）方法进行了赋值，其中构造了**java.system.class.loader**加载器实例（实际上为AppClassLoader？），并持有当前加载器的parent作为其父加载器。
  - 接着，ClassLoader.SystemClassLoaderAction#run（）方法通过Thread#setContextClassLoader（ClassLoader）设置到当前线程的实例变量中，从而使得当前Thread实例持有contextClassLoader的引用。
  - 最后，java.sql.DriverManager在调用sevice.loader（Driver.class）时，jdbc.jar中在META-INF/sevice/java.sql.Driver配置的**com.mysql.cj.jdbc.Driver**，就会在java.util.ServiceLoader#load（Class）方法调用Thread.currentThread().getContextClassLoader()时进行类加载，从而达到SPI的目的。
  - 可以看出虽然java.util.ServiceLoader是rt.jat包的核心类库，由启动类加载器加载，但通过Thread.currentThread().getContextClassLoader()确实加载到了第三方包下的com.mysql.cj.jdbc.Driver，因此线程上下文类加载器可以打破双亲委派模型。

```java
// java.sql.DriverManager，启动类加载器加载
public class DriverManager {
 	static {
        loadInitialDrivers();
        println("JDBC DriverManager initialized");
    }
    
    private static void loadInitialDrivers() {
        AccessController.doPrivileged(new PrivilegedAction<Void>() {
            public Void run() {
                // SPI加载
                ServiceLoader<Driver> loadedDrivers = ServiceLoader.load(Driver.class);
                Iterator<Driver> driversIterator = loadedDrivers.iterator();
            }
            ...
        }
    }      
}    


// java.util.ServiceLoader，启动类加载器加载
public final class ServiceLoader<S>implements Iterable<S> {  
    // SPI加载: 获取当前线程上下文类加载器进行SPI加载，从而打破了双亲委派模型
    public static <S> ServiceLoader<S> load(Class<S> service) {
        ClassLoader cl = Thread.currentThread().getContextClassLoader();
        return ServiceLoader.load(service, cl);
    }
    ...
}
```

##### Tomcat类加载机制

- **背景**：
  - a. 一个web容器可能要部署两个或者多个应用程序，不同的应用程序可能会依赖同一个第三方类库的不同版本，因此要保证每一个应用程序的类库都是**独立、相互隔离**的。
  - b. 同一个web容器中的**相同类库的相同版本**可以共享，否则会有**重复的类被加载进JVM**。
  - c. **web容器也有自己的类库**，不能和应用程序的类库混淆，基于安全考虑，需要相互隔离。
  - d. Jsp文件也是要编译成class文件的，web容器需要支持在**Jsp**文件修改后，可以实现**HostSwap（热替换）**的功能。

![1626065847576](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1626065847576.png)

- **类加载器逻辑关系**：

  Common、Catalina、Shared类加载器（本质上是URLClassLoader）分别加载/common/、/server/、/shared/路径下的Class，但在Tomcat6后已经统一合并到了/lib目录下了。

  - **CommonClassLoader**：Tomcat最基本的类加载器，加载对应路径中的Class，可**以被Tomcat容器本身以及各个webapp访问**。
  - **CatalinaClassLoader**：Tomcat容器私有的类加载器，加载对应路径中的class，**对于webapp不可见**。
  - **SharedClassLoader**：各个webapp共享的类加载器，加载对应路径中的class，**对于所有webapp可见，但对于Tomcat容器不可见**。
  - **WebappClassLoader**：各个webapp私有的类加载器，每一个webapp对应一个WebAppClassLoader实例，加载路径中的class，**只对当前webapp可见**。
  - **JasperClassLoader**：
    - 每一个Jsp文件对应一个JasperClassLoader实例，**加载范围仅仅是这个Jsp文件所编译出来的那一个Class文件**。
    - JasperClassLoad出现的目的就是为了被丢弃，当Web容器检测到Jsp文件被修改时，会替换掉目前的JasperClassLoader实例，并通过重新建立一个新的JasperClassLoader实例来实现JSP文件的HostSwap（热替换）功能。

![1626066067882](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1626066067882.png)

![1626090586657](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1626090586657.png)

- **类加载流程**：WebappClassLoaderBase#loadClass(String, boolean)流程：

1. 先查找Tomcat缓存，如果找得到，则返回Tomcat缓存中的Class对象。
2. 如果Tomcat缓存中找不到，则查找JVM缓存，如果找得到，则返回JVM缓存中的Class对象。
3. 如果JVM缓存中也找不到，则用扩展类加载器来加载（**重点！这里并没有首先使用系统类加载器，而是直接使用了扩展类加载器来加载，也就是打破了系统类加载器的双亲委派机制**），根据双亲委派机制，扩展类加载器会委派启动类加载器来加载Class，从而保证了JRE核心类库不会被重复加载。
4. 如果指定了delegateLoad（需要先委托父类加载），则**先调用父类加载器加载**（share -> common -> app -> ext -> bootstrap，这里是为了保持顺序加载机制），如果找不到**才调用本地的findClass（String）**搜索本地存储库（WEB-INF/classes -> WEB-INF/lib），找到则返回，找不到则抛出ClassNotFoundException异常。
5. 如果没有指定delegateLoad（需要先委托父类加载），则**先调用调用本地的findClass（String）**搜索本地存储库（WEB-INF/classes -> WEB-INF/lib），如果找不到**才调用父类加载器加载**（share -> common -> app -> ext -> bootstrap，这里是为了保底机制），找到则返回，找不到则抛出ClassNotFoundException异常。

![1626090700749](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1626090700749.png)

- **总结**：可以看到，Tomcat#WebappClassLoaderBase的类加载机制是**打破了双亲委派模型**的：
  - **ext -> bootstarp模型**：保证了JRE核心类库不会被重复加载，满足了背景b加载JVM共同类库的需求。
  - **ext -> webapp模型**：实现了每个web应用只加载自己的类库（WEB-INF/classes -> WEB-INF/lib），从而实现了应用间的类库隔离，满足了背景a的需求。
  - **webapp -> share -> common模型**：实现了所有web应用之间、web与Tomcat之间，能够加载相同的类库，避免指定的类库不会被重复加载，满足了背景b加载其他共同类库的需求。
  - **（不确定）catalina -> 父类加载器模型**：实现了只加载Tomcat容器自身的类库，对于webapp是看不到的（可在config/catalina.properties的server.loader中配置jar和class的路径），满足了背景c的需求。
  - **（不确定）Jsp -> webapp -> 父类加载器模型**：通过在jsp修改后卸载再生成新的Jsp类加载器，重新加载新生成的Jsp class，从而实现Jsp的HostSwap（热替换），满足了背景d的需求。

### 1.6. JVM运行时数据区？

![1626181528728](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1626181528728.png)

JVM在执行 Java 程序的过程中会把它所管理的内存区域划分为若干个不同的数据区域。

这些区域都有各自的用途，以及创建和销毁的时间，有些区域随着JVM进程的启动而存在（**线程共享**），有些区域则是依赖线程的启动和结束而建立和销毁（**非线程共享**）。

JVM所管理的内存被划分为如下几个区域：

- **程序计数器**：Program Counter Register，非线程共享，JVM当前线程所执行的**字节码的行号指示器**，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成。
- **虚拟机栈**：Java Virtual Machine Stacks，非线程共享，每个方法在执行的同时都会在Java 虚拟机栈中创建一个栈帧（Stack Frame），用于存储**局部变量表、操作数栈、动态链接和方法返回地址**；
- **本地方法栈**：Native Method Stack，非线程共享，与虚拟机栈的作用是一样，只不过虚拟机栈是服务Java方法的，而本地方法栈是为虚拟机调用Native方法服务的。
- **堆**：Java Heap，线程共享，在JVM启动时创建，是Java虚拟机中内存最大的一块，**专门用来保存对象，几乎所有对象以及数组的内存都在堆上分配**。
- **方法区**：Methed Area，别命Non-Heap（非堆），线程共享，是JVM规范中定义的一个逻辑概念，用于存储已被虚拟机加载的**类信息、常量、静态变量和即时编译后的代码**等数据，具体放在哪里，不同的实现可能会放在不同的地方。

### 1.7. 详细介绍程序计数器？

- **概念**：程序计数器，Program Counter Register，非线程共享，JVM当前线程所执行的字节码的行号指示器，字节码解析器的工作是通过改变这个计数器的值，来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能，都需要依赖这个计数器来完成。

- **出现的原因**：由于JVM多线程是通过线程轮流切换，并分配处理器执行时间的方式来实现的，一个处理器只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，需要**记住原线程的下一条指令的位置**，所以每条线程都要有一个独立存储、互不影响的程序计数器，称之为“**线程私有**”的内存。

- **例子**：

  1. 比如线程A在看直播。
  2. 突然，线程B来了一个视频电话，就会抢夺线程A的时间片，就会打断了线程A，线程A就会挂起。
  3. 然后，视频电话结束，如果没有线程计数器，此时线程A就不知道要干什么了；如果有线程计数器，此时线程A就可以想起来要去看直播了。

  => 线程是最小的执行单位，不具备“记忆”功能，只负责去干，这就需要**由程序计数器来为线程提供保护和恢复现场**的功能。

### 1.8. 详细介绍虚拟机栈？

![1626137840755](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1626137840755.png)

Java虚拟机栈**是线程私有的（非线程共享）**，每个线程都会有自己的虚拟机栈，其生命周期与线程生命周期一致。单位是**栈帧**，在每个方法执行的时候，都会创建一个栈帧，在被调用直至执行完毕的过程，对应一个栈帧在虚拟机栈中**从入栈到出栈**的过程。

每个栈帧都存放着**局部变量表、操作数栈、动态链接和方法返回地址**。

> 在JVM规范中，对此区域规定了两种异常状况：在固定情况下，如果线程请求的栈深度大于虚拟机所允许的最大栈深度，则会抛出**StackOverflowError**异常；在可动态扩展情况下，如果虚拟机栈无法申请到足够的内存，或者在创建新线程的时候没有足够的内存去创建对应的虚拟机栈，则会抛出**OutOfMemoryError**异常。

在Hotspot虚拟机中，**栈内存是不允许扩展的**，且不区分虚拟机栈和本地方法栈，统一使用-Xss设置栈的大小，但同样会抛StackOverflowError异常，以及OutOfMemoryError异常。在有些VM中是有区分开的，比如使用-Xss设置虚拟机栈大小，-Xoss设置本地方法栈大小。

- **局部变量表**：

  - 是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。
  - 存放了编译期可知的各种**基本数据类型**（boolean、byte、char、short、int、float、long、double，对包装类型在栈中保存地址、在堆中保存值）、**对象引用**（Reference类型，可能是一个指向对象起始地址的引用指针，也可能是一个代表对象的句柄或者其他与对象相关的位置）和**returnAddress类型**（指向下一条字节码指令的地址）。
  - 局部变量表所需的内存空间在编译期间完成分配，方法在运行之前，该局部变量表所需要的内存空间是固定的，运行期间不会发生改变。

- **操作数栈**：

  - 用于保存计算过程中的**中间结果**，同时作为计算过程中变量临时的存储空间。
  - 操作数栈在方法的执行过程中，根据字节码指令往操作数栈中写入数据或提取数据，即入栈和出栈操作。
  - 比如add（）方法执行过程中，其操作数栈与局部变量表的交互顺序为：15入栈（操作数栈写入数据） -> 15出栈（操作数栈提取数据到局部变量表） -> 1入栈（操作数栈写入数据） -> 1出栈（操作数栈提取数据到局部变量表） -> 15入栈（加载局部变量表变量15） -> 1入栈（加载局部变量表变量1） -> iadd（执行相加15 + 1指令） -> 16出栈（操作数栈提取结果到局部变量表）-> return（如果返回值为void，则当前栈帧出栈即可，如果带有返回值，则局部变量表中的结果16，还会入栈操作数栈中）。

  ```java
  public class Test {
      public void add() {
          int a = 15;
          int b = 1;
          int c = a + b;
      }
  }
  ```

- **动态链接**：

  - 每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态链接（Dynamic Linking）。
  - Class 文件的常量池中存在大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数，这些符号引用一部分会在类加载阶段或**第一次使用时转化为直接引用，这种转化成为静态解析**。另一部分将在**每一次运行期间转化为直接引用，这部分称为动态连接**。

- **方法返回地址**：returnAddress类型（**指向下一条字节码指令的地址**）:

  - 当一个方法开始执行后，只有两种方式可以退出这个方法。一种是执行引擎遇到**任意一个方法返回的字节码指令**，这时候可能会有返回值传递给上层方法的调用者，是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为**正常完成出口**。
  - 另一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是 Java 虚拟机内部产生的异常，还是代码中使用 athrow 字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种称为**异常完成出口**。一个方法使用异常完成出口的方式退出，是不会给上层调用者产生任何返回值的。
  - 无论采用何种退出方式，在方法退出后都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来恢复它的上层方法的执行状态。一般来说，方法正常退出时，**调用者的PC计数器的值可以作为返回地址**，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中一般不会保存这部分信息。
  - 方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上次方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，**调整PC计数器的值以指向方法调用指令后面的一条指令等**。

- 附加信息：虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧中，例如与调试相关的信息，这部分信息完全取决于具体的虚拟机实现。实际开发中，一般会把动态连接、方法返回地址与其他附加信息全部归为一类，成为栈帧信息。

### 1.9. 详细介绍本地方法栈？

- 本地方法栈，Native Method Stack，非线程共享，与虚拟机栈的作用是一样，只不过虚拟机栈是服务Java方法的，而本地方法栈是为虚拟机调用Native方法服务的。
- Native方法是看不到的，必须要去oracle官网去下载才可以看的到，而且native关键字修饰的大部分源码都是C和C++的代码。
- 在Hotspot虚拟机中，**栈内存是不允许扩展的**，且不区分虚拟机栈和本地方法栈，统一使用-Xss设置栈的大小，因此同样会抛StackOverflowError异常，以及OutOfMemoryError异常。
  - 在有些VM中是有区分开的，比如使用-Xss设置虚拟机栈大小，-Xoss设置本地方法栈大小。

### 2.0. 详细介绍堆？

![1626349372632](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1626349372632.png)

- **堆**：Java Heap，线程共享，在JVM启动时创建，是Java虚拟机中内存最大的一块，**专门用来保存对象，几乎所有对象以及数组的内存都在堆上分配**。
  - 非栈上分配情况下，**创建的对象会存储在堆内存中，在栈上存储该对象的引用**（栈空间只包含方法基础数据类型的局部变量以及引用堆对象的引用变量）。
  - ClassA a = new ClassA（）；此时a叫实例，不能说a对象，**实例在栈上，对象在堆中**，操作实例实际上是通过实例指针间接操作对象，多个实例可以指向同一个对象。
  - 栈中的数据和堆中的数据销毁并不是同步的，方法一旦结束，**栈中的局部变量会立即销毁**；堆中的对象不一定会销毁，因为可能有其他变量也指向了该对象，直到没有变量指向该对象，才有可能会被垃圾回收。
  - 类的成员变量在对象中，每个对象都有自己成员变量的存储空间；而**类的方法只有一套**，存储在方法区中，被该类的所有对象共享，对象在使用方法的时候才会将方法压入栈中，而**方法在不使用时并不会占用内存**。
- 对象在堆中分配好以后，会在栈中保存一个4字节的实例（指向对象堆内存地址），用来定位对应的对象在堆中的位置，便于找到该对象。但在开启逃逸分析后，某些未逃逸的对象也可以通过标量替换的方式在**栈上分配**。
- 堆是垃圾回收（GC）的主要场所，从内存回收角度来看，可以分为**新生代和老年代，默认内存大小比值为1：2**，对于新生代又可以分为**Eden区（伊甸园）、Survivor区（存活区），默认内存大小比值默认为8：2**，而Survivor区又分为**Surviver0（From Survivor）和Survivor1（To Survivor），默认内存大小比值默认为1：1**。
- **TLAB**：Thread Local Allocation Buffer，线程私有分配缓存区，是一块**线程专用的内存分配区域**，JVM会为每个线程分配一块TLAB区域，**实质占用的是Eden区的空间（即分配独享、使用共享）**，用于给每个线程往自己的TLAB中分配小对象，这样可以避免堆分配对象时的线程冲突，从而提升分配对象的效率。
  - **优点 - 加速对象分配**：
    - 当多个线程同时在堆上分配对象时，由于堆是线程共享的，为了保证线程同步，JVM底层采用CAS + 失败重试的方式来做同步处理，如果多线程竞争非常激烈，那么此时在堆中分配对象性能是非常差的。因此，JVM设计了TLAB，来避免堆分配对象时的线程冲突，从而提升分配对象的效率。
  - **缺点 - 大对象无法分配**：TLAB空间比较小，所以大对象无法在TLAB分配，这时只能直接分配到线程共享的堆里面。
- 堆可以处于物理上不连续的内存空间中，可通过 -Xmx（最大堆内存）和 -Xms（初始堆内存） 来扩展空间大小。如果堆中没有内存可以完成对象分配，且堆也无法再扩展时，将会抛出OutOfMemoryError异常。

### 2.1. 详细介绍方法区？

![1626181213768](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1626181213768.png)

- **方法区**：Methed Area，别命Non-Heap（非堆），线程共享，是JVM规范中定义的一个逻辑概念，用于存储已被虚拟机加载的**类信息、常量、静态变量和即时编译后的代码**等数据，具体放在哪里，不同的实现可能会放在不同的地方。
  - **永久代**：是Hotspot虚拟机特有的概念（在别的JVM没有），是方法区的一种实现，主要存放类信息、常量等方法区内容。
    - 在JDK1.6 中，方法区中包含的数据，除了JIT编译生成的代码是存放在native memory的CodeCache区域，其他都存放在永久代。
    - 移除永久代的工作从JDK1.7就开始了，在JDK1.7中，存储在永久代的部分数据就已经转移到了Java Heap或者是Native Heap。但永久代仍存在于JDK1.7中，并没完全移除，比如**符号引用**（Symbols）转移到了native heap，**字面量**（interned strings，见字符串常量池）转移到了java heap，**类的静态变量**（class statics）转移到了java heap。
    - 在Java 8中，永久代被彻底移除，取而代之的是另一块与堆不相连的本地内存：元空间（Metaspace）中，此时‑XX：MaxPermSize 参数失去了意义，取而代之的是-XX：MaxMetaspaceSize。
  - **元空间**：JDK8后用于替代永久代，存储类的元数据信息，存放在本地内存中。
    - **元空间与永久代最大的区别**：元空间并不是在JVM虚拟机中 ，而是使用了本地内存，默认情况下，元空间的大小仅受本地内存限制，解决了永久代容易溢出的问题。
  - **元空间替代永久代的原因**：
    - 字符串存在永久代中，容易出现性能问题和内存溢出。
    - 类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则会导致空间的浪费。
    - JRockit虚拟机方法区没有永久代的实现，Oracle需要将HotSpot与JRockit合二为一 ，剔除永久代。
    - （？）永久代会为GC带来不必要的复杂度，并且回收效率偏低。
- 在JDK8以后，元空间替代了永久代，使得方法区与堆存在交集，静态变量和字符串常量池存放在堆中，类信息和运行时常量池放在元空间中，而静态常量池是class文件里的常量池，未加载前并不占用内存。
  - **常量池 - 静态常量池**：也叫class文件常量池，即class文件中的常量池，占用class文件绝大部分空间。主要存放：
    - **字面量**：相当于Java语言层面常量的概念，如文本字符串、final修饰的变量。
    - **符号引用**：属于编译原理方面的概念，包括类和接口的全限定名、字段的名称和描述符、方法的名称和描述符。
  - **常量池 - 运行时常量池**：当class文件加载到内存后，JVM会将静态常量池中的内容存放到运行时常量池中，这就是常说的“常量池”，主要存放：
    - 编译期间产生的字面量、符号引用。
    - 注意，运行时常量池具有动态性，也就是并非只有通过class文件常量池才能进入，运行期间也可能将新的常量放入池中，比如调用String#intern（）方法。
  - **常量池 - 字符串常量池**：可以理解为运行时常量池中分出来的一部分，当类加载到内存时，**字符串**会存到字符串常量池里面，即在编译阶段把所有字符串放到一个常量池中。
    - String#intern（）方法，native方法，返回规范的字符串，equals判断常量池是否有存在的字符串，如果没有则会将实参字符串加入常量池。
    - 程序运行时，除非手动向常量池中添加常量，比如调用String#intern（）方法，否则JVM不会自动添加常量到常量池。
    - 至于程序启动时，哪些字符串或常量、变量会加入常量池，取决于本身的编译性质，如果本身是字面量则会加入常量池；如果是变量，由于地址不能确定，所以在不调用String#intern（）时是并不会加入常量池的。
    - JDK5以后，除了有字符串常量池，实际上还有数值型常量池，也就是Java中大部分基本类型的包装类都实现了常量池技术，比如Byte、Short、Integer、Long、Character、Boolean，而两种浮点数类型的包装类Float、Double并没有实现常量池技术。其中，只有Integer常量池缓存区间（-128~127），可通过-XX:AutoBoxCacheMax参数进行设置。
  - **常量池的好处**：
    - 常量池是为了避免频繁的创建和销毁对象而影响系统性能，实现了对象的共享。
    - 常量池可以节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。
    - 常量池可以节省运行时间：在比较字符串时，==比equals（）快，所以对于两个引用变量，只用==判断引用是否相等，就可以判断实际值是否相等了。
- 垃圾回收在方法区出现得比较少，这个区域回收的目的主要是针对**常量池的回收和类的卸载**。
- 方法区也是可以由内存不连续的内存区域组成，也是可扩展的，当方法区无法满足内存分配需求时，则会抛出OutOfMemoryError异常。

### 2.2. 堆和虚拟机栈的区别？

|              | 堆                                                           | 虚拟机栈                                                     |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 物理地址     | 堆的物理地址是不连续的，因此分配对象的速度较慢               | 虚拟机栈使用的是栈数据结构，物理地址是连续的，因此分配对象的速度较快 |
| 内存大小     | 由于堆是不连续的，所以分配到的内存是在运行期才确定的，因此大小不固定，一般堆大小远远大于虚拟机栈 | 虚拟机栈是连续的，所以分配到的内存大小在编译期就已经确定好了，因此大小是固定的 |
| 存放内容     | 堆存放的是对象的实例和数组，所以更关注的是数据的存储         | 虚拟机栈存放的是局部变量、操作数栈、动态链接和方法返回地址，所以更关注的是程序方法的执行 |
| 程序的可见性 | 堆是线程共享的                                               | 栈是线程私有的，只对于线程是可见                             |
| 生命周期     | 堆的生命周期与JVM的生命周期相等                              | 虚拟机栈的生命周期与所在线程的生命周期相等                   |

### 2.3. 详细介绍直接内存？

- **直接内存**：DirectBuffer，是一块由操作系统直接管理的内存，也叫**堆外内存**，并不是JVM运行时数据区的一部分，也不是JVM规范中定义的内存区域，是利用本地方法库直接在堆外申请的内存区域，这部分内存会被频繁使用，而且也可能会导致OOM错误的出现。

- 直接内存（堆外内存）的使用，**避免了在I/O操作时Java堆和Native堆中来回复制数据**，从而提高性能。

  - 在JVM层面，每当程序需要执行一个I/O操作时，都需要将数据先从**Java Heap**复制到**C Heap**中，才能够触发系统调用完成操作。
  - 其中，C Heap内存站在JVM角度来看，属于堆外内存，但是站在操作系统的角度来看，其实都属于进程的Heap，**操作系统并不知道JVM的存在**，所以认为都是普通的用户程序。因此，JVM在I/O时永远比使用Native方法多一次数据复制。
  - **为什么必须有这一次的数据复制呢**？
    - 这是因为JVM只是一个用户程序，本身并没有直接访问硬件的能力，所有的I/O操作都需要借助于系统调用来实现。在Linux系统中，与I/O相关的read（）和write（）系统调用，都需要传入一个指向在程序中分配的一片内存区域的起始地址指针，然后操作系统才会将数据填入到这片区域或者从这片区域中读出数据。
    - 如果直接使用JVM堆中对应byte[]类型的地址的话，则会有两个无法解决的问题：一是，**Java中的对象实际的内存布局跟C不一样**，不同的JVM可能有不同的实现，byte[]的首地址可能只是个对象头，并不是真实的数据；二是，**垃圾收集器的存在使得JVM会经常移动对象的位置**，这样同一个对象的真实内存地址随时都有可能发生变化，而虽然JVM知道对象地址变了，但是操作系统并不知道。
  - 因此，在适当的位置直接使用直接内存，可以避免数据从JVM Heap到C Heap的拷贝。

- **API上**：可以使用**Unsafe**类或者**ByteBuffer**类分配直接内存：

  - **Unsafe**：Unsafe.allocateMemory（size）：
    - Unsafe可用来直接访问系统内存资源并自主管理，在提升Java运行效率、增强Java语言底层操作能力方面起了很大的作用。
    - 可以认为，**Unsafe类是Java中留下的后门**，提供了一些底层的操作，比如直接访问内存、线程调度等。
    - Unsafe不属于Java标准，官方并不建议使用Unsafe，并且从JDK 9开始去Unsafe，然而目前业界有很多好用的类库大量用了Unsafe类，比如JUC atomic包下的类、Netty、Hadoop、Kafka等，所以了解一下还是有好处的。
    - 不同JDK版本中，Unsafe类有区别：在JDK 8中归属于sun.misc包下；在JDK 11中归属于sun.misc包下与jdk.internal.misc下（这个功能更强大）。

  ```java
  public class DirectMemoryTest1 {
      private static final int MB_1 = 1024 * 1024;
  
      public static void main(String[] args) throws IllegalAccessException, NoSuchFieldException {
          //通过反射获取Unsafe类并通过其分配直接内存
          Field unsafeField = Unsafe.class.getDeclaredFields()[0];
          unsafeField.setAccessible(true);
          Unsafe unsafe = (Unsafe) unsafeField.get(null);
  
          // 分配1M内存，并返回这块内存的起始地址
          long address = unsafe.allocateMemory(MB_1);
  
          // 向内存地址中设置对象
          unsafe.putByte(address, (byte) 1);
  
          // 从内存中获取对象
          byte aByte = unsafe.getByte(address);
          System.out.println(aByte);
  
          // 释放内存
          unsafe.freeMemory(address);
      }
  }
  ```

  - **ByteBuffer**：ByteBuffer.allocateDirect（size）：

  ```java
  public class DirectMemoryTest2 {
      private static final int ONE_MB = 1024 * 1024;
  
      public static void main(String[] args) {
          // 底层使用unsafe分配内存，unsafe.freeMemory(address)释放内存
          ByteBuffer buffer = ByteBuffer.allocateDirect(ONE_MB);
          
          // 相对写，向position的位置写入一个byte，并将postion+1，为下次读写作准备
          buffer.put("abcde".getBytes());
          buffer.put("fghij".getBytes());
  
          // 转换为读取模式
          buffer.flip();
  
          // 相对读，从position位置读取一个byte，并将position+1，为下次读写作准备
          // 读取第1个字节(a)
          System.out.println((char) buffer.get());
  
          // 读取第2个字节
          System.out.println((char) buffer.get());
  
          // 绝对读，读取byteBuffer底层的bytes中下标为index的byte，不改变position
          // 读取第3个字节
          System.out.println((char) buffer.get(2));
      }
  }
  ```

- **JVM参数上**：可以使用-XX：MaxDirectMemorySize控制，默认是0，表示不控制。

- **优点**：

  - **减少了垃圾回收的工作**：因为直接内存是由操作系统直接管理的内存，分配到直接内存的对象不受JVM管理，也就不用JVM对其进行垃圾回收了。
  - **I/O效率高**：由于I/O操作中，使用直接内存可以减少一次Java Heap与C Heap之间的内存拷贝，从而提高了性能。

- **缺点**：

  - **直接内存难以控制**：直接内存不受JVM管理，需要用户自己来释放内存，当发生内存溢出时排查问题可能会变得非常困难。

- **适用场景**：

  - **需要存储的数据大且生命周期长**。
  - **频繁的I/O操作**，比如并发网络通信。

### 2.4. JVM执行引擎？

- JVM核心的组件就是**执行引擎**，负责执行虚拟机的字节码，一般会先编译成机器码后执行。
- “虚拟机”是一个相对于“物理机”的概念，虚拟机的字节码是不能直接在物理机上运行的，需要执行引擎编译成机器码后才可在物理机上执行。

### 2.5. 编译器优化机制？

#### 字节码运行模式

- **解释执行**：由解释器一行一行翻译字节码执行。
  - 优势在于没有编译的等待时间，可以节省内存（不存放到CodeCache），但由于要一行一行去翻译性，所以能差一些。
- **编译执行**：把字节码编译成字节码，直接执行机器码。
  - 运行效率会高很多，一般比解释执行快一个数量级，但带来了额外的内存（CodeCache）和CPU的开销。
- 相关命令：

| JVM参数              | 显示值                             | 说明                                                  |
| -------------------- | ---------------------------------- | ----------------------------------------------------- |
| java -version        | mixed mode，表示混合模式           | 查看字节码运行模式                                    |
| java -Xint -version  | interpreted mode，表示解释执行模式 | 指定解释执行模式                                      |
| java -Xcomp -version | compiled mode，表示编译执行模式    | 指定JVM优先以编译模式运行，不能编译的再以解释模式运行 |
| java -Xmixed         | mixed mode，表示混合模式           | 指定以混合模式运行（默认）                            |

#### JIT即时编译器

- **背景**：

  - JVM一般开始会以解释器解释执行，当发现某个方法或者代码块的运行特别频繁，则会认为这些代码为**热点代码**。
  - 为了提高热点代码的执行效率，JVM会使用**即时编译器**，把这些热点代码编译成与本地平台相关的机器码，并进行**各层次的优化**。

- **概念**：Just In Time Compiler，JIT即时编译器，简称JIT编译器，在运行时JVM将会把热点代码编译成与本地平台相关的机器码，并进行各种层次的优化（比如锁粗化等），从而提高热点代码的执行效率。

  - **Hotspot - C1即时编译器**：也被称为Client  Compiler，是一个简单快速的编译器，主要关注局部性的优化，适用于执行时间较短或者对启动性能有要求的程序。比如GUI应用对界面启动速度就有一定的要求，此时适合用C1 编译器。
  - **Hotspot - C2 即时编译器**：也被称为Server Compiler，是为长期运行的服务器端应用程序做性能调优的编译器，适用于执行时间长或者对峰值性能有要求的程序。
  - **javac是前端编译**（也叫前期编译），负责把java代码编译成class字节码；而**JIT是后端编译**，负责把字节码编译成本地平台相关的机器码。

- **分层编译优化**：

  - level 0：解释执行。
  - level 1：简单的C1编译，使用C1编译器进行一些简单的优化，不开启Profiling（JVM的性能监控）。
  - level 2：受限的C1编译，仅执行**带方法调用次数**以及**循环回边执行次数**Pofiling的C1编译。
  - level 3：完全的C1编译，会执行带有所有Profiling的C1代码。
  - level 4：C2编译，使用C2编译器进行优化，该级别会启用一些编译耗时较长的优化，在一些情况下，会根据性能监控信息进行一些非常激进的性能优化。

  => 级别越高，应用启动越慢，优化的 开销越高，峰值性能也越高。

| JVM参数                                          | 默认值 | 说明                    |
| ------------------------------------------------ | ------ | ----------------------- |
| -XX：-TieredCompilation                          | ？     | 只开启C2（禁用123层）   |
| -XX：+TieredCompilation -XX：TieredStopAtLevel=1 | -      | 只开启C1（只开启0~1层） |

#### CodeCache

- **概念**：CodeCache，代码缓存区，是非堆区域，缓存的是JIT编译器编译后的代码（即机器码），以及部分JNI的机器码，不过JIT编译生成的机器码占主要部分。
  - 解释执行可以节省内存，不存放到CodeCache，立即执行。
  - 编译执行后的代码会存放在CodeCache里，虽然CodeCache在即将耗尽时会尝试回收，但满了后却会让JIT停止工作，此后已编译过的代码会继续以编译模式执行，还没有编译过的代码将会退化成以解释执行模式执行，从而出现系统运行变慢、响应时间增大的现象。

#### 热点代码

- **概念**：JVM一般开始会以解释器解释执行，当发现某个方法或者代码块的运行特别频繁，则会认为这些代码为**热点代码**。

- **探测方法**：

  - **基于采样的热点探测**：周期性检查各个线程的栈顶，经常出现在栈顶的则为热点方法。
  - **基于计数器的热点探测**：Hotspot使用的方法，思路是为每个方法或者代码块建立一个**计数器**，统计其执行的次数，如果超过某个阈值，则认为它是热点代码。

- **Hotspot内置计数器**：

  - **方法调用计数器**：Invocation Counter，用于统计方法被调用的次数（不是绝对次数，而是在一个相对的执行频率，即一段时间内方法被调用的次数），在不开启分层编译的情况下，默认C1阈值为1500次，C2为10000次。

  | JVM参数                  | 默认值 | 说明                                                     |
  | ------------------------ | ------ | -------------------------------------------------------- |
  | -XX：CompileThreshold=？ | ？     | 指定方法调用计数器阈值命令（开启分层编译后，此阈值失效） |

  ![1626357990780](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1626357990780.png)

  - **回边计数器**：

    - 回边，Back Edge，指定的是在字节码中遇到控制流向后跳转的指令。
    - 回边计数器，Back Edge Counter，用于统计一个方法中循环体代码执行的次数，在不开启分层编译的情况下，默认C1为13995次，C2为10700次。
    - 建立回边计数器的目的是为了触发OSR，OnStackReplacement编译，是一种在运行时替换正在运行函数或者方法的栈帧的技术，是一种用于提升benchmark跑分非常有效的技术。

    | JVM参数                         | 默认值 | 说明                                                 |
    | ------------------------------- | ------ | ---------------------------------------------------- |
    | -XX：OnStackReplacePercentage=? | ?      | 指定回边计数器阈值命令（开启分层编译后，此阈值失效） |

  ![1626358121407](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1626358121407.png)

#### 方法内联

- **概念**：把目标方法的代码复制到发起调用的方法之中，即方法内联，避免发生真实的方法调用，从而减少方法调用时压栈和出栈的操作，以减少内存消耗和操作的时间，提高系统性能。
  - 方法内联，本质上是空间换时间的方式，也就是即时编译器在编译期间把方法调用连接起来，从而减少入栈和出栈的开销。
- **内联条件**：
  - **方法体足够小**：
    - 热点方法，方法体小于325字节会尝试内联，可用-XX：FreqInlineSize命令修改阈值大小。
    - 非热点方法，方法体小于35字节会尝试内联，可用-XX：MaxInlineSize命令修改阈值大小。
  - **被调用的方法运行时的实现可以被唯一确定**：
    - static方法、private方法以及final方法，JIT可以唯一确定具体的实现代码，此时会尝试内联。
    - 而public的实例方法，指向的实现可能是自身、父类或者子类的代码，仅当JIT能够唯一确定其唯一实现时，才有可能完成内联。
- **内联带来的问题**：
  - 由于经过内联后的代码会变多，其增加的代码量取决于方法的调用次数和方法本身的大小，在一些极端情况下，内联可能会引起CodeCahce溢出，可能会导致JVM退化成解释执行模式。
    - CodeCahce：是热点代码的一个缓存区，即时编译器编译后的代码以及本地方法代码都会存放在这个区间内，空间大小比较有限（JDK 8中只有240M内存），比较容易出现CodeCahce溢出。

| JVM参数                             | 默认值 | 说明                                                         |
| ----------------------------------- | ------ | ------------------------------------------------------------ |
| -XX：+Printlnlining                 | -      | 打印内联详情，该参数需和-XX：+UnlockDiagnosticVMOption配合使用 |
| -XX：+UnlockDiagnosticVMOption      | -      | 打印JVM诊断相关的信息                                        |
| -XX：MaxlnlineSize=？               | 35     | 如果非热点方法的字节码超过该值（单位字节），则无法内联       |
| -XX：FreqlnlineSize=？              | 325    | 如果热点方法的字节码超过该值（单位字节），则无法内联         |
| -XX：lnlineSmallCode=？             | 1000   | 如果目标编译后生成的机器码大小大于该值（单位字节），则无法内联 |
| -XX：MaxlnlineLevel=？              | 9      | 内联方法的最大调用帧数（嵌套调用的最大内联深度）             |
| -XX：MaxTrivialSize=？              | 6      | 如果方法的字节码少于该值（单位字节），则直接内联             |
| -XX：MinlnlingThreshold=？          | 250    | 如果目标方法的调用次数低于该值，则不去内联                   |
| -XX：LiveNodeCountlnliningCutoff=？ | 40000  | 编译过程中最大活动节点（IR节点）的上限，仅对C2编译器有效     |
| -XX：lnliningFrequencyCount=？      | 100    | 如果方法的调用点（call site）的执行次数超过该值，则触发内联  |
| -XX：MaxRecursivelnlining Level=？  | 1      | 如果递归调用大于该值，则不去内联                             |
| -XX：+lnlineSynchronizedMethods     | 开启   | 是否允许同步方法的内联                                       |

#### 逃逸分析

- **概念**：分析变量能否逃出它的作用域。

- **4种逃逸场景**：

  - **全局变量赋值逃逸**：局部变量作用域放大到全局变量。

  ```java
  public static SomeClass someClass;
  
  // 全局变量赋值逃逸
  public void globalVariablePointerEscape() {
      someClass = new SomeClass();
  }
  ```

  - **方法返回值逃逸**：变量作用域随着方法返回而放大。

  ```java
  // someMethod(){
  //   SomeClass someClass = methodPointerEscape();// 方法返回值逃逸
  // }
  public SomeClass methodPointerEscape() {
      return new SomeClass();
  }
  ```

  - **实例引用逃逸**：变量作用域随着方法参数逃逸到其他作用域。

  ```java
  // 实例引用传递逃逸
  public void instancePassPointerEscape() {
      this.methodPointerEscape().printClassName(this);
  }
  
  
  ```

  - **线程逃逸**：类变量或者可以被其他线程中访问的实例变量，即共享变量，可以随着线程共享发生的逃逸。

- **逃逸状态标记**：JVM针对每个逃逸场景进行分析，分析后会给对象做一个逃逸状态标记。

  - **全局逃逸标记**：一个对象可能从**方法**或者**线程**中逃逸，即其他方法或者其他线程也可以访问这个对象。
    - 对象被作为方法的返回值。
    - 对象作为静态字段或者成员变量。
    - 如果某个类重写了析构函数finalize（）方法，则整个类的对象都会被标记为全局逃逸状态，并且一定会放到堆内存里面。
  - **参数逃逸状态**：一个对象被作为参数传递给一个方法，但在接收参数的方法之外无法访问该对象，且该对象对其他线程也是不可见的。
  - **无逃逸状态**：一个对象不会发生逃逸。

| JVM参数                    | 默认值       | 说明             |
| -------------------------- | ------------ | ---------------- |
| -XX：+DoEscapeAnalysis     | JDK8默认开启 | 是否开启逃逸分析 |
| -XX：+EliminateAllocations | JDK8默认开启 | 开启标量替换     |
| -XX：+EliminateLocks       | JDK8默认开启 | 是否开启锁消除   |

#### 逃逸分析优化 - 标量替换

标量替换指的是，在通过逃逸分析确定对象不会被外部访问，且对象可以进一步被分解后（聚合量），JVM不会创建该对象，而是创建其成员变量（标量）去代替。

- **标量**：不能被进一步分配的量，比如基础数据类型和对象的地址引用。
- **聚合量**：可以进一步分解的量，可以由标量聚合而成，比如字符串、自己定义变量。

```java
public void someTest() {
    // someTest没有逃逸时, 且可以进一步分解, 则可以进行标量替换
    SomeTest someTest = new SomeTest();
    someTest.age = 1;
    someTest.id = 1;

    // 开启标量替换之后, 上述代码会被优化成: 并不会创建SomeTest对象
    int age = 1;
    int id = 1;
}


```

#### 逃逸分析优化 - 栈上分配

栈上分配指的是，在通过逃逸分析确定对象不会被外部访问后，并且对象足够的小，那么JVM会直接在栈上分配对象，而其对象内存在出栈时会被回收，从而减少垃圾回收的压力。

#### 逃逸分析优化 - 锁消除

等到并发章节再写。

### 2.6. 详细介绍创建一个对象的步骤？

**步骤：类加载检查、类加载（加载、链接、初始化）、分配内存、初始化零值、设置对象头、执行init方法**

1. **类加载检查** ：当JVM遇到new指令时，⾸先去检查是否能在常量池中定位到这个类的符号引⽤，并且检查这个符号引⽤代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执⾏相应的类加载过程。

2. **类加载 - 加载**：指的是将类的**class文件（二进制数据）**读入到内存，并转换成**方法区中的运行时数据结构**。同时在堆中生成一个代表这个类的**java.lang.Class对象**，该对象封装了类在方法区中的数据结构，并且向用户提供了访问方法区数据结构的接口，即Java反射的接口。

3. **类加载 - 链接**：该阶段负责把**类的二进制数据合并到JRE中**，可分为如下3个阶段：

   - **验证**：验证Class文件是否符合规范，是否能被当前的虚拟机加载处理，确保加载的类没有安全方面的问题。
   - **准备**：为类的静态变量（static）分配内存，并初始化为初始值（0或null）。而对于静态常量（final static修饰）会直接被赋值为用户定义的值。
   - **解析**：将Class常量池（Constant Pool）的符号引用转换为直接引用。

4. **类加载 - 初始化**：类初始化是类加载的最后一步，真正执行Java代码，主要工作是为静态变量（static）赋值为用户定义的值。初始化完毕类就可以被使用了。

   - 执行clinit 方法，clinit方法由编译器自动收集类里面的**所有静态变量的赋值动作及静态语句**合并而成，也叫**类构造器方法**。

5. **分配内存**：在确定对象需要创建后，接下来JVM将为对象分配内存，分配⽅式有 **“指针碰撞”** 和 **“空闲列表”** 两种，在分配内存的过程中，需要注意使用的是哪一种垃圾收集算法，因为垃圾收集算法的不同会导致内存块是否规整，从而影响到分配内存的方式是使用指针碰撞还是使用空闲列表。

   - 在进行内存分配的时候，如果使用的是指针碰撞方法，还需要注意并发情况下，内存的分配是否是线程安全的。一般使用**加同步块**的方式和**线程私有分配缓存区**这两种方式解决线程安全的问题。

6. **初始化零值**：对象内存分配完成后，JVM需要将分配到的内存空间都初始化为零值，这⼀步操作保证了对象的**实例字段**在Java代码中可以不赋初始值就直接使⽤，程序能访问到这些字段的数据类型所对应的零值。

7. **设置对象头**： 初始化零值完成之后，JVM要对对象进⾏必要的设置，比如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息，这些信息将存放在对象头中。另外，根据JVM当前运⾏状态的不同，比如是否启⽤偏向锁等，对象头会有不同的设置⽅式。

   - **对象头主要包括两部分**：用于存储对象自身的运行时数据（哈希码、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳）以及类型指针（即对象指向该类元数据的指针，JVM通过这个指针来确定这个对象是哪个类的实例）。

   ![1626822381182](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1626822381182.png)

8. **执⾏init⽅法**： 从JVM的视⻆来看，⼀个新的对象已经产⽣了，但从Java程序的视⻆来看， init⽅法还没有执⾏，所有的字段都还为零。所以⼀般来说（除循环依赖），执⾏new指令之后会接着执⾏init⽅法，这样⼀个真正可⽤的对象才算产⽣出来。

   - 类初始化后，如果是实例化一个新对象，还会调用< init >方法，与< clinit >类似，< init >方法可以看作是**对象构造方法**，是由编译器自动收集类中所有实例变量的赋值动作、实例代码块和构造函数合并而成的。
   - 如果是对实例变量直接赋值或者使用实例代码块赋值，那么编译器会将这些代码合并到实例构造函数中去，并且它们还会被放在对父类构造函数的调用语句之后（因为Java要求构造函数的第一条语句必须是父类构造函数的调用语句)，自身构造函数的代码之前去执行。
   - 因此，类构造器和对象构造器的初始化过程为：**父类的类构造器 -> 子类的类构造器 -> 父类成员变量的赋值和实例代码块 -> 父类的构造函数 -> 子类成员变量的赋值和实例代码块 -> 子类的构造函数。**

### 2.7. 对象内存分配过程？

![1626823040622](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1626823040622.png)

1. 对象首先尝试栈上分配，如果栈上分配成功，则直接在栈上分配对象。
   - **栈上分配**指的是，在通过**逃逸分析**确定对象不会被外部访问后，并且**对象足够的小**，那么JVM会直接在栈上分配对象，而其对象内存在出栈时会被回收，从而减少垃圾回收的压力。
2. 如果不能在栈上分配，且**对象也足够的小**，则尝试TLAB分配，如果TLAB分配成功，则直接在TLAB分配对象。
   - **TLAB**：Thread Local Allocation Buffer，线程私有分配缓存区，是一块**线程专用的内存分配区域**，JVM会为每个线程分配一块TLAB区域，**实质占用的是Eden区的空间（即分配独享、使用共享）**，用于给每个线程往自己的TLAB中分配**小对象**，这样可以避免堆分配对象时的线程冲突，从而提升分配对象的效率。
3. 如果也不能在TLAB分配（大部分对象），则对象在创建时会优先存放到**Eden区**，当Eden区满时会触发Minor GC，即JVM会将Eden区存活的对象拷贝到**Survivor区（From Survivor/To Survivor）**里。而在下次Minor GC时，JVM又会将存活的对象拷贝到To Survivor/From Survivor区里，下下一次再周而复始。对象每经历一次垃圾回收后，如果仍然存活，则**该对象年龄+1**，当对象年龄达到阈值（默认15），则会晋升到**老年代**。
4. 然而，**新建的对象不一定直接分配到Eden区**：如果对象非常大，而新生代空间又不足，则会将该对象直接放到老年代去担保，主要是为了避免分配到采用复制算法的新生代，在大对象存活时内存拷贝带来的大量消耗。
5. 同时还要注意的是，**由于JVM有动态年龄判定机制，对象不一定要达到年龄才能进入老年代**：
   - **动态年龄**：如果Survivor区中相同年龄对象的大小总和，超过了Survivor区空间大小的一半时，则会晋升大于等于该年龄的对象到老年代。

### 2.8. Java垃圾回收机制？

- **背景**：
  - 在Java中，程序员是**不需要显式去释放一个对象的内存**的，而是由虚拟机自行执行。
  - 在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。
- **使用场景原则**：
  - **内存要求**：内存不够，则需要想办法提高对象的回收率，以多回收一些对象，从而腾出更多的内存。
  - **CPU要求**：CPU不够，则需要降低垃圾回收频率，让CPU多去执行业务，而不是垃圾回收。
- **垃圾回收的区域**：虚拟机栈、本地方法栈和程序计数器是线程独享的，是随着线程的创建而创建的，随着线程的销毁而销毁的， 是不需要考虑垃圾回收的；而堆和方法区是线程共享的，需要关注垃圾回收。
  - **堆**：是垃圾回收的主要区域，用于回收创建的对象。
  - **方法区**：用于回收废弃的常量以及不需要的类。
- **回收时机**：由对象存活算法决定。

### 2.9. 对象存活算法？

#### 引用计数法

通过对象的引用计数器，来判断该对象是否被引用，比如有对象引用就+1，其引用失效就-1，当为0时，则代表该对象没有被引用。

- **优缺点**：实现简单，判断效率高；但无法解决对象循环引用的问题，**目前Java并不使用该算法**。

![1626436324696](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1626436324696.png)

#### 可达性分析

以**根对象（GC Roots）**作为起点向下搜索，走过的路径被称为**引用链**（Reference Chain），如果某个对象到根对象之间没有引用链相连，则认为该对象是不可达的，是可以被回收的。**Java使用的是该存活算法**。

- **根对象**包括：
  - 虚拟机栈（栈帧中的局部变量表）中Reference对象所引用的对象。
  - 方法区中类的静态属性（static）Reference对象所引用的对象。
  - 方法区中常量（final）Reference对象所引用的对象。
  - 本地方法栈中JNI（即Native方法）Reference对象所引用的对象。

![1626436445717](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1626436445717.png)

- **可达性分析完整流程**：注意，一个对象即使不可达，也不一定会被回收，还要继续判断有无必要执行析构函数**finalize（）**方法，如果方法里面重新建立了与根对象之间的引用链，则不会去回收，否则还是会被回收。
  - **两次标记过程**：
    - 第一次标记不在“关系网”中的对象。
    - 第二次先判断该对象有没有实现finalize（）方法，如果没有实现，则直接判断该对象可回收；如果实现了，则会先放在一个队列中，并由JVM建立的一个低优先级的线程去执行它，随后会进行第二次的小规模标记，而在这次被标记的对象就会真正地被回收了。
  - **使用建议**：
    - 避免使用finalize（）方法，操作不当可能会导致问题。
    - finalize（）方法优先级低，什么时候会被调用也无法确定，因为什么时候发生GC是不确定的。
    - 建议使用try...catch...finally来代替finalzie（）方法。

![1626437028531](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1626437028531.png)

### 3.0. JVM垃圾回收算法

分为**基础垃圾回收算法**（标记清除算法、标记整理算法和复制算法）和**综合垃圾回收算法**（分代搜集算法和增量算法）。

#### 基础 - 标记清除算法

- **优缺点**：实现简单；但存在内存碎片，影响对象的内存分配速度，在极端情况下需要遍历整个内存链表。
- **算法流程**：

1. 通过可达性分析，标记需要回收的对象。
2. 再清理掉要回收的对象。

![1626437545225](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1626437545225.png)

#### 基础 - 标记整理算法

也叫标记压缩算法。

- **优缺点**：无内存碎片；但由于整理需要计算和时间整理对象到一端，存在CPU和时间的开销。
- **算法流程**：

1. 通过可达性分析，标记需要回收的对象。
2. 然后把所有存活对象压缩到内存的一端。
3. 再清理掉边界外的所有空间。

![1626437785184](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1626437785184.png)

#### 基础 - 复制算法

- **优缺点**：性能好（无需标记所有对象，只需找出存活的并移动即可），无内存碎片；但内存利用率低，最多才达到50%。
- **算法流程**：

1. 把内存分为两块，每次只使用其中一块。
2. 通过可达性分析，将存活的对象复制到另一块未使用的内存中，然后清除掉正在使用的那块内存中的所有对象。
3. 最后交换两块内存块的角色，等待下次回收重复执行上述操作。

![1626437874675](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1626437874675.png)

#### 综合 - 分代收集算法

- **概念**：

  - 各种商业虚拟机堆内存的垃圾收集基本上都采用了分代收集算法。
  - 根据对象的存活周期，把内存分为多个区域，**不同区域使用不同的回收算法**来回收对象，以提升整体性能。
  - 堆是垃圾回收的主要区域，其内存可以划分为以下区域：

  ![1626349372632](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1626349372632.png)

- **垃圾回收类型**：

  - **新生代回收**：Minor GC或者Young GC
  - **老年代回收**：Major GC，执行Major GC往往伴随一次Minor GC，所以**Major GC  ≈ Full GC**。
  - **清理整个堆**：Full GC = Major GC + Minor GC。

- **对象内存分配过程**：

  - **典型模型**：
    - **回收新生代使用复制算法**，因此新生代需要有两块内存（Eden区和Survivor区，8：2），Survivor区也有两块内存（From Survivor和To Survivor，1：1）。
      1. 对象在创建时会优先存放到**Eden区**，当Eden区满时会触发Minor GC，即JVM会将Eden区存活的对象拷贝到**Survivor区（From Survivor/To Survivor）**里。
      2. 而在下次Minor GC时，JVM又会将存活的对象拷贝到To Survivor/From Survivor区里，下下一次再周而复始。
      3. 对象每经历一次垃圾回收后，如果仍然存活，则**该对象年龄+1**，当对象年龄达到阈值（默认15），则会晋升到**老年代**。
    - **回收老年代使用标记清除或者标记整理算法**，老年代：新生代，默认内存大小比值为2：1。
  - **新建的对象不一定直接分配到Eden区**：
    - 如果对象大于-XX：PretenureSizeThreshold（默认为0，表示所有对象都优先在Eden区分配），则会直接分配到老年代。
    - 如果对象非常大，而新生代空间又不足，则会将该对象直接放到老年代去担保，主要是为了避免分配到采用复制算法的新生代，在大对象存活时内存拷贝带来的大量消耗。
  - **对象不一定要达到年龄才能进入老年代**：
    - **动态年龄**：如果Survivor区中相同年龄对象的大小总和，超过了Survivor区空间大小的一半时，则会晋升大于等于该年龄的对象到老年代。

- **触发垃圾回收的条件**：

  - **新生代Minor GC**：Eden区空间不足时。
  - **老年代/Full GC**：
    - **老年代空间不足**：没有足够空间，或者内存碎片过多导致没有足够的连续空间去分配对象。
    - **元空间不足**：方法区的元空间不足也会触发Full GC。
    - **显示调用System.gc（）**：该方法的作用是建议垃圾回收器执行垃圾回收，会触发Full GC，可以使用-XX：+DisableExplicitGC参数忽略System.gc（）的调用。

- **分代收集算法的好处**：

  - **更有效的清除不再需要的对象**：对于生命周期比较短的对象，在新生代就会被回收掉了。
  - **提升了垃圾回收的效率**：如果不做分代处理，每次回收需要扫描整个堆的对象，而分代回收则需要扫描新生代或者老年代就可以了。

- **分代收集算法的调优原则**：

  - **合理设置Survivor区的大小，避免内存浪费**：因为Survivor区的内存利用率不高，如果设置得过大，则会导致内存浪费严重。
  - **让GC尽量发生在Minor GC级别，尽量减少Full GC的发生**。

| JVM参数                        | 默认值 | 说明                                                         |
| ------------------------------ | ------ | ------------------------------------------------------------ |
| -XX：+NewRatio=？              | 2      | 老年代：新生代的内存大小比值                                 |
| -XX：SurvivorRatio=？          | 8      | Eden区：Survivor区的内存大小比值                             |
| -XX：PretenureSizeThreshold=？ | 0      | 分配到老年代的对象大小阈值，为0表示不做限制，所有对象都优先在Eden区分配 |
| -Xms                           | -      | 最小堆内存                                                   |
| -Xmx                           | -      | 最大堆内存                                                   |
| -Xmn                           | -      | 新生代大小                                                   |
| -XX：+DisableExplicitGC        | 开启   | 忽略掉System.gc（）的调用                                    |
| -XX：NewSize=？                | -      | 新生代初始内存大小                                           |
| -XX：MaxNewSize=？             | -      | 新生代最大内存                                               |

#### 综合 - 增量算法

每次只收集一小片区域内存的垃圾，从而减少系统的停顿时间，见G1收集器的实现。

### 3.1. JVM垃圾收集器？

#### 相关概念

- **垃圾回收算法**：为实现垃圾回收提供理论支持。
- **垃圾收集器**：利用垃圾回收算法，实现垃圾回收的实践落地。
- **Stop The World**：**简写为STW，也叫全局停顿**，处于该状态时，Java代码将停止运行，而native代码可以继续运行，但无法与JVM进行交互。
  - **原因**：多半由于垃圾回收导致，也有可能由Dump线程、Dump堆、死锁检查等操作导致。
  - **危害**：服务会停止，没有响应；STW时间过长，可能会导致主从发生切换，影响生产环境。
- **并行收集**：指多个垃圾收集线程同时并行工作，但在收集过程中，用户线程处于等待状态。
- **并发收集**：指用户线程与垃圾收集线程同时工作。
- **应用吞吐量**：指的是CPU用于运行业务代码的时间，与CPU总消耗时间的比值。
  - **计算公式**：应用吞吐量 = 运行业务代码时间 / （运行用户代码时间 + 垃圾收集时间）* 100%，垃圾收集时间越长，应用吞吐量越小。

 ![1626495749202](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1626495749202.png)

#### 新生代 - Serial收集器

- **背景**：最基本的、发展历史最悠久的收集器。
- **垃圾收集算法**：复制算法。
- **特点**：
  - **单线程、简单、相对高效**：由于是单线程实现的，不存在与其他线程的交互开销，可以专心做垃圾回收。
  - **收集过程全程Stop The World**。
- **适用场景**：
  - **用于客户端程序**：如果应用以java -client -jar方式启动时，默认使用的就是Serial收集器。
  - **用于单核机器上**：常见于一些嵌入式低性能的机器上运行。
- **执行过程**：
  - **Safepoint**：当发生GC时，用户线程必须全部停下来，才可以进行垃圾回收，这个状态可以认为JVM 是安全的（safe），整个堆的状态是稳定的。如果在GC前，有线程迟迟进入不了safepoint状态，那么整个 JVM都在等待这个线程，从而造成了GC整体时间变长。

![1626496514434](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1626496514434.png)

#### 新生代 - ParNew收集器

- **背景**：Serial收集器的多线程版本，除了使用多线程不同以外，其他都和Serial收集器一样，包括JVM参数、Stop The World别的表现和垃圾收集算法。
- **垃圾收集算法**：复制算法。
- **特点**：
  - **多线程、收集过程全程Stop The World**。
  - 可使用**-XX：ParallelGCThreads**设置垃圾收集的线程数，一般设置为CPU核心数就可以了。
- **适用场景**：主要用来和CMS收集器配合使用。
- **执行过程**：

![1626505507768](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1626505507768.png)

#### 新生代 - Parallel  Scavenge收集器

- **背景**：也叫吞吐量优先收集器，也是并行的多线程收集器（多线程的方式与ParNew收集器类似）。
- **垃圾收集算法**：复制算法。
- **特点**：
  - **可以达到一个可控制的吞吐量**：
    - -XX：MaxGCPauseMillis，设置阈值后，JVM将**尽力控制**最大的垃圾收集停顿时间为该阈值。
    - -XX：GCTimeRatio，设置吞吐量的大小，取值0~100，设置后JVM将花费不超过1 + / （1+n）的时间用于垃圾收集。
  - **自适应GC策略**：可用-XX：+UseAdptiveSizePolicy启用，启用后无需手动设置-Xmn、-XX：SurvivorRatio等参数，虚拟机会根据系统的运行状况收集性能监控信息，动态地调整这些参数，从而达到最优的停顿时间以及吞吐量。因此Parallel  Scavenge收集器存在着一定的智能性。
- **适用场景**：比较注重吞吐量的场景。
- **执行过程**：

![1626505950316](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1626505950316.png)

#### 老年代 - Serial Old收集器

- **背景**：也叫串行老年代收集器，可以认为是Serial收集器的老年代版本。
- **垃圾回收算法**：标记整理算法。
- **特点**：除了算法采用标记整理算法与Serial收集器不同之外，其他都是一样的。
- **适用场景**：
  - 可以和Serial、ParNew、Parallel Scavenge三个新生代收集器配合使用。
  - CMS收集器在出现故障时，会使用Serial Old收集器作为备用。
- **执行过程**：

![1626506526709](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1626506526709.png)

#### 老年代 - Parallel Old收集器

- **背景**：可以认为是Parallel Scavenge的老年代版本。
- **垃圾回收算法**：标记整理算法。
- **特点**：只能和Parallel Scavenge新生代收集器使用。
- **适用场景**：关注吞吐量的场景。
- **执行过程**：

![1626506871826](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1626506871826.png)

#### 老年代 - CMS收集器

- **背景**：CMS，Concurrent Mark Sweep，并发标记清除，是一个并发收集器，可以与用户线程同时工作。
- **垃圾回收算法**：标记清除算法。Serial Old与Parallel Scavenge采用的是标记整理算法。
- **特点**：
  - **优点**：
    - **Stop The World时间比较短，大多过程都是并发执行的**：只有1. 初始标记和5. 重新标记阶段存在Stop The World，其他阶段都是并发执行的）。
  - **缺点**：
    - **CPU资源比较敏感，并发执行的阶段会导致应用吞吐量的降低**：由于垃圾收集线程也需要占用一定的CPU资源，与业务线程一起去争抢CPU时间片，导致影响业务线程的执行效率，降低应用吞吐量。
    - **无法处理浮动垃圾**：由于并发清除阶段用户线程仍在并发执行，其可能会产生新的垃圾，这部分垃圾称为浮动垃圾，而CMS无法在本次GC清理掉这些浮动垃圾，需要留到下次GC才能清理掉。
    - **不能等到老年代几乎满了才开始收集**：因为用户线程并发执行，必须为老年代预留足够的内存给用户线程使用。如果CMS执行期间预留的内存不能满足用户程序的需要，则会出现一次Concurrent Mode  Failure异常，这将会导致JVM**改用备用的Serial Old收集器**去收集老年代的垃圾，从而导致Stop The World时间加长。
      - 可使用CMSInitiatingOccupancyFraction，设置老年代占比达到多少后（默认68%），就会触发CMS垃圾收集。
    - **存在内存碎片（最令人诟病的地方）**：标记清除算法会导致内存碎片的产生。
      - 可使用UseCMSCompactAtFullCollection，在完成Full GC后是否要进行内存碎片的整理（默认打开）。
      - 也可使用CMSFullGCsBeforeCompaction，在进行几次Full GC后就进行一次内存碎片的整理（默认为0）。
  - **其他**：对于CMS收集器，Major GC和Full GC并不约等于，因为CMS是作用在老年代的垃圾回收，这里讲的Major GC并不是之前讲的Full GC。
- **适用场景**：
  - **希望系统停顿时间短，响应速度快的场景**：比如各种服务端应用场景。
- **执行过程**：

1. **初始标记**： 
   - initial  mark，标记根对象（GC Roots）能直接关联到的对象，因此能够标记到的对象会比较少。
   - 存在Stop The World，不过由于标记的对象比较少，所以STW的时间也是比较短的。
2. **并发标记**：
   - concurrent mark，找出所有根对象（GC Roots）能够关联到的对象。
   - 垃圾收集线程和用户线程并发执行，没有Stop The World。
3. **并发预清理**：
   - concurrent-preclean，**不一定会执行的阶段**，可用-XX：-CMSPrecleaningEnabled，关闭并发预清理阶段，默认是打开的。
   - 重新标记那些在并发标记阶段，引用被更新了的对象（比如新晋升到老年代的对象），从而减少后面重新标记阶段的工作量。
   - 垃圾收集线程和用户线程并发执行，没有Stop The World。
4. **并发可中止的预清理阶段**：
   - concurrent-abortable-preclean，**不一定会执行的阶段**，使用该阶段的前提条件是：当Eden区使用量大于CMSScheduleRemarkEdenSizeThreshold的阈值（默认2M）时，才会执行该阶段。
   - 与并发预清理阶段所工作的事情是一样的。
   - 垃圾收集线程和用户线程并发执行，没有Stop The World。
   - 该阶段的主要作用是：允许用户能够控制预清理阶段的结束时机。
     - 比如，扫描多长时间：可用CMSMaxAbortablePrecleanTime进行设置，默认为5秒。
     - 再如，当Eden区使用占比达到多大阈值就结束本阶段：可用CMSScheduleRemarkEdenPenetration进行设置，默认为50%。
5. **重新标记**：
   - remark，修正并发标记期间，由于用户线程并发运行，导致标记发生变动的那些对象的标记。
     - 比如在并发标记期间，错误地把已经死亡了的对象，标记为了存活，会导致部分垃圾不被回收。
     - 再如把存活的对象错误地标记成为了死亡，可能会导致用户程序之后无法继续执行。
   - 存在Stop The World，一般来说（经验之谈），重新标记所花费的时间会比初始标记阶段的要长一些，但会比并发标记阶段的段一些。
6. **并发清理**：
   - concurrent sweep，或者叫**并发清除**，会基于标记结果，清除掉要前面标记出来需要清除的垃圾（会存在内存碎片）。
   - 垃圾收集线程和用户线程并发执行，没有Stop The World。
   - 为什么是并发清除，而不是并发整理？
     - 由于本阶段是并发执行的，如果还要整理对象的话，则还需要移动对象的位置。
     - 试想一下如果既要回收垃圾，又要整理移动对象的位置，还要与用户线程并发执行，保证业务程序没有问题，这实现起来会变得非常困难，还容易出错。
     - 而采用并发清除就变得容易了许多，因此这里是并发清除而不是并发整理。
7. **并发重置**：
   - concurrent reset，清理本次CMS GC的上下文信息，为下一次GC做准备。
   - 垃圾收集线程和用户线程并发执行，没有Stop The World。

![1626507231972](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1626507231972.png)

#### 新生代&老年代 - G1收集器

- **背景**：Garbge First，是一款面向服务器端应用的垃圾收集器，既可以用在新生代，又可以用在老年代，即整个堆内存，会优先处理那些垃圾多的Region（First是价值优先的意思）。

- **垃圾回收算法**：复制算法。

- **革命性变化**：

  - **堆内存布局上的变化**：G1将整个堆划分成了若干个大小相等的区域，每个区域叫一个Region。
    - Region的大小可通过-XX：G1HeapRegionSize来指定，取值范围为1M~32M，必须为2的N次幂。
    - 在G1收集器里，同一代的对象可能是不连续的：一共分为4类Region，分别为Eden Region（伊甸园）、Survivor Region（存活区）、Old Region（老年代）、 Humongous Region（用于存储大对象，即超过Region大小一半的对象，而特大对象会分配到连续的Humongous Region里面）。

  ![1626511732234](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1626511732234.png)

  - **设计思想上的变化**：**化整为零，分而治之**，本质上是应用了**增量算法**的思想。
    - 将堆内存按照Region分成多个块。
    - 然后会去跟踪每个Region里面的垃圾堆积的价值大小（即回收一个Region能够获取到多大的剩余空间）。
    - 最后构建一个优先列表，根据允许的收集时间，**优先回收价值高的Region**（回收后能够得到大的空间），以获得更高的垃圾收集效率。

- **特点**：

  - 可以作用在整个堆，既可以作用在新生代，又可以作用在老年代。
  - 垃圾回收时的停顿时间是可控的。
    - 可用MaxGCPauseMillis=？去控制。
  - 回收Region使用的是复制算法，无内存碎片的问题。

- **适用场景**：

  - 占用内存较大的应用（比如6G以上）。
  - 用于替换CMS垃圾收集器。
    - 对于JDK 8，G1和CMS的性能差异并不大，都可以使用。（经验之谈）如果内存<=6G，建议使用CMS；如果内存>6G，可以考虑使用G1。
    - 对于> JDK 8，则使用G1，因为CMS从JDK 9就已经被废弃了。

- **垃圾收集机制**：

  - **Young GC**：过程上与之前的Minor GC差不多（**复制算法**），只不过回收的单位是Region。

    - 所有Eden Region都满了时，会触发Young GC。
    - 所有Eden Region里面存活的对象，都会转移到Survivor Region里面去。
    - 而原先在Survivor Region中存活的对象，则会转移到新的Survivor Region中，或者晋升到Old Region中。
    - 其中，回收后空闲的Region会被放入空闲的列表中，等待下次被使用。

  - **Mixed GC**：最能体现G1的设计思想，与CMS有类似之处，但也有许多差异，比如使用的是复制算法。

    - 老年代大小占整个堆的百分比达到一定阈值时，则会触发Mixed GC。
      - 可用-XX：InitiatingHeapOccupancyPercent指定，默认为45%。
    - Mixed GC会回收所有Young Region，同时回收**部分**Old Region，回收那些根据收集时间与回收价值而选择的Old Region。
    - **执行过程**：除2. 并发标记是并发执行，其他阶段都是需要Stop The World的，但由于每次只回收部分Region，所以**Stop The World的时间是可控的**。

    1. **初始标记**：
       - Initial Marking，与CMS的初始标记类似，都是标记根对象（GC Roots）能直接关联到的对象。
       - 存在Stop The World，不过由于标记的对象比较少，所以STW的时间也是比较短的。
    2. **并发标记**：
       - Concurrent Marking，与CMS的并发标记类似，用于找出所有根对象（GC Roots）能够关联到的对象。
       - 垃圾收集线程和用户线程并发执行，没有Stop The World。
    3. **最终标记**：
       - Final Marking，与CMS的重新标记类似，用于修正并发标记期间，由于用户线程并发运行，导致标记发生变动的那些对象的标记。
         - 比如在并发标记期间，错误地把已经死亡了的对象，标记为了存活，会导致部分垃圾不被回收。
         - 再如把存活的对象错误地标记成为了死亡，可能会导致用户程序之后无法继续执行。
       - 存在Stop The World。
    4. **筛选回收**：
       - Live Data Counting and Evaluation，会对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间（MaxGCPauseMillis）来制定回收计划，并选择一些Region进行回收。
       - **回收过程：复制算法，无内存碎片**。
         - 选择一系列Region构成一个回收集。
         - 接着把决定要回收的Region中的存活对象复制空的 Region中。
         - 最后删除掉需要回收的Region。
       - 存在Stop The World。

  ![1626513840821](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1626513840821.png)

  - **Full  GC**：
    - 当G1在复制对象时发现内存不够，或者无法分配足够内存（比如特大对象没有足够的连续Humongous Region可分配）时，则会触发Full GC。
    - 一旦触发Full GC，在Full GC模式下使用的是Serial Old模式的垃圾回收，将会出现长时间的Stop The World。

- **G1调优原则**：

  - 尽量减少Full GC的发生，尽量只停留在Young GC或者Mixed GC的模式上进行垃圾回收。
  - **减少Full GC的思路**？
    - **增加预留的内存**：可用过加大-XX：G1ReserveRercent来实现，默认为堆的10%。
    - **更早地回收垃圾，可降低老年代大小占整个堆的百分比的阈值，提早触发Mixed GC**：可通过减少-XX：InitiatingHeapOccupancyPercent来实现，默认为45%。
    - **增加并发阶段使用的线程数**：可增大-XX：ConcGCThreads，这样就可以有更多的垃圾回收线程去工作，但会降低业务应用的吞吐量。

#### 其他垃圾收集器

Shenandoah、ZGC、Epsilon，JDK 14处于实验状态，不建议在生产环境中使用。

#### 如何选择垃圾收集器？

不能纸上谈兵，要根据实际情况选择。

- 应用系统所关注的最主要的矛盾点？
  - 响应快、吞吐量高：Parallel Scaveng。
  - Web应用，低延迟：CMS或者G1。
  - 桌面端应用，启动慢：Serial & -Xverify：none参数。
- 应用系统的基础设施？
  - 单核：Serial。
  - Windows + JDK11：应用不了ZGC，需要升级到JDK14才支持。
- 应用系统的JDK的版本？
  - JDK6用不了G1。
  - Oracle JDK用不了Shenandoah。

#### 垃圾收集器相关JVM参数

详细见《JVM参数选型-高级选型-常用高级垃圾收集选项》一栏。

### 3.2. JVM性能调优工具？

详细见《JVM调优工具集锦》：基于JDK 11编写。

#### JDK内置 - 监控类工具

##### jps

Java Virtual Machine Process Status Tool，实验性工具，用于查看所有Java进程，比ps -ef  | grep java方便。

```java
eg：
jps -q：只查看进程号。
jps -m：查看传递给main方法的参数。
jps -l：查看启动类的全限定名。
jps -v：查看JVM启动时的参数。


```

##### jstat

JVM Statistics Monitoring Tool，实验性工具，⽤于监控JVM的各种运⾏状态息，包括**内存状态**和**垃圾回收**。

```java
命令格式：jstat -<option> [-t] [-h<lines>] <vmid> [<interval> [<count>]]
  -<option> ：指定参数，取值可⽤jstat -options查看
  -t        ：⽤来展示每次采样花费的时间
  <lines>   ：每抽样⼏次就列⼀个标题，默认0，显示数据第⼀⾏的列标题
  <interval>：抽样的周期，格式使⽤:<n>["ms"|"s"]，n是数字，ms/s是时间单位，默认是ms
  <count>   ：采样多少次停⽌，默认是一直打印

option参数解释：
-class    :：显示类加载器的统计信息
-gcutil    ：垃圾回收统计概述
-gc        ：垃圾回收堆的行为统计
-gcnew     ：新生代行为统计
-gcold     ：年老代和永生代行为统计
-gccapacity：各个垃圾回收代容量(young,old,perm)和他们相应的空间统计


```

#### JDK内置 - 故障排查类工具

##### jinfo

Java Configuration Info，实验性参数，主要⽤来查看以及调整JVM参数。

```java
命令格式：jinfo <option> <pid>

1）查看能力:
jinfo 11666：查看11666进程的Java System Properties、VM Flags、VM Arguments
jinfo -sysprops 11666          ：只查看11666进程的Java System Properties
jinfo -flags 11666             ：只查看11666进程的VM Flags
jinfo -flag 11666 Xmx          ：只查看11666进程的Xmx参数（最大堆内存大小）
jinfo -flag 11666 Xms          ：只查看11666进程的Xms参数（初始堆内存大小）
jinfo -flag 11666 Xmn          ：只查看11666进程的Xmn参数（新生代内存大小）
jinfo -flag 11666 MetaspaceSize：只查看11666进程的MetaspaceSize参数（元空间内存大小）

2）动态修改能力：不用重启JVM就可以生效，但能力比较有限
java -XX:+PrintFlagsInitial | grep manageable：只有显示出来的结果才能被动态修改。
开关类（打开/关闭）：jinfo -flag +HeapDumpAfterFullGC 11666
赋值类（更新为60） ：jinfo -flag MinHeapFreeRatio=60 11666


```

##### jmap

Java Memory Map，实验性工具，⽤来展示对象内存映射或者堆内存详细信息。

- **生成堆dump的8种方式**：
  - **jmap**：jmap -dump:live,format=b,file=mydump.hproft 11666：转储java的堆Dump文件为mydump.hprof。
  - **jcmd**：jcmd 11666 GC.heap_dump -all mydump.hprof：⽣成Java堆Dump⽂件（HPROF格式）。
  - **jhsdb jmap**：jhsdb jmap --binaryheap --dumpfile mydump.hprof --pid 11666：生成11666进程的堆dump文件。
  - **Visual VM**：Monitor界面的Heap Dump按钮Dump堆，相当于jmap dump命令。
  - **OOM异常自动后生成**：使用-XX：+HeapDumpOnOutOf  MemeoryError，使JVM在OOM异常出现后自动生成堆Dump文件。
  - **Ctrl + （Pause）Break生成**：使用-XX：+HeapDumpOnCtrBreak，开启后可使用Ctrl + （Pause）Break，让虚拟机生成堆Dump文件。
  - **kill -3命令**：在Linux操作系统下，发送kill -3 pid命令生成堆Dump文件。
  - **借助SpringBoot Actuator生成**：对于SpringBoot应⽤，可以使⽤SpringBoot Actuator提供的/actuator/heapdump来实现堆Dump的生成。

```java
命令格式：jmap [option] <pid>

option参数解释：
-heap             ：打印java heap摘要
-clstats          ：打印Java堆的类加载器统计信息
-finalizerinfo    ：打印等待finalization的对象的信息
-histo[:live]     ：打印Java堆的直⽅图。如果指定了live⼦选项，则仅统计活动对象
-dump:dump_options：生成java堆的dump文件。其中，dump_options的取值为：
              live：指定时，仅Dump活动对象；如果未指定，则转储堆中的所有对象
          format=b：以hprof格式Dump堆
     file=filename：将堆Dump到filename

eg:
jmap -dump:live,format=b,file=mydump.hproft 11666：转储java的堆dump文件为mydump.hprof


```

##### jstack

Stack Trace for Java，实验性工具，⽤于打印当前虚拟机的线程快照（线程快照也叫Thread Dump或者javacore⽂件，包含展示每个线程正在做什么、执行到了哪里等信息），常用于定位线程出现长时间卡顿的原因，比如死锁、死循环等。

- **生成线程dump的4种方式**：
  - **jstack**：jstack -l -e 11666：打印11666进程的所有线程以及持有锁的额外信息。
  - **jcmd**：jcmd 11666 Thread.print -l：打印11666进程所有线程以及线程持有锁的额外信息。
  - **jhsdb jstack**：jhsdb jstack --locks --mixed -pid 11666：打印11666进程的栈、本地方法栈以及持有锁的额外信息。
  - **VisualVM**：Threads界面的Thread Dump按钮Dump线程，相当于jstack。

```java
命令格式：jstack [-l][-e] <pid>
  
option参数解释：
-l：显示有关线程持有的锁的额外信息
-e：展示有关线程的额外信息（⽐如分配了多少内存、定义了多少个类等等）

eg：
jstack -l -e 11666：打印11666进程的所有线程以及持有锁的额外信息


```

##### jhat

JVM Heap Analysis Tool，实验性工具，⽤来分析jmap⽣成的堆Dump，能力比较弱，有非常多的替代品（比如VisualVM、Eclipse Memory Analyzer），且在JDK 11已被废弃（可在JDK 8中使用），对于学习不太重要了。

```java
命令格式：jhat [options] heap-dump-file

option参数解释：
-stack false | true   ：开启或关闭跟踪对象分配调⽤栈，默认true
-refs false | true    ：开启或关闭对对象引⽤的跟踪，默认true
-port port-number     ：指定jhat HTTP Server的端⼝，默认7000
-exclude exclude-file ：指定⼀个⽂件，该⽂件列出了应从可达对象查询中排除的数据成员
-baseline exclude-file：指定基线堆Dump⽂件。两个堆Dunmp中，对于⽐较两个不同的堆转储很有⽤
-debug intSets        ：指定该⼯具的debug级别。设置为0，则不会有debug输出。数值越⾼，⽇志越详细
-version              ：显示版本


```

##### jcmd

JVM Command，⽤于将诊断命令请求发送到正在运⾏的Java虚拟机，从JDK 7开始提供。

```java
命令格式：jcmd <pid | main class> <command ...|PerfCounter.print|-f file>

命令参数解释：
pid              ：接收诊断命令请求的进程ID
main class      :：接收诊断命令请求的main类的所有进程
command          ：command必须是⼀个有效的jcmd命令
PerfCounter.print：打印指定Java进程上可⽤的性能计数器
-f filename      ：从指定⽂件中读取命令并执⾏
-l               ：查看所有的JVM进程。jcmd不使⽤参数与jcmd -l效果相同

eg：
jcmd 11666 GC.heap_dump -all mydump.hprof：⽣成Java堆Dump⽂件（HPROF格式）
jcmd 11666 GC.run						 ：调⽤一次java.lang.System.gc()
jcmd 11666 Thread.print -l		         ：打印11666进程所有线程以及线程持有锁的额外信息


```

##### jhsdb

Java Hotspot Debugger，Hotspot进程调试器，可⽤于从崩溃的JVM附加到Java进程或核⼼转储，从JDK 9开始引入，JDK 9前使用sa-jdi.jar（jhsdb的原型）也是可以的。

```java
1）jhsdb clhsdb --pid 11666：进入11666进程的jhsdb的交互界面
eg：（交互界面下）
	flags          ：展示所有以-XX开头的JVM参数的值
	g1regiondetails：查看G1每个Region的起始指针、结束指针、是哪一个分代的信息

2）jhsdb hsdb --pid 11666：进入11666进程的图形化界面

3）jhsdb jinfo --flags --pid 11666：打印11666进程的VM标志

4）jhsdb jmap --binaryheap --dumpfile mydump.hprof --pid 11666：生成11666进程的堆dump文件

5）jhsdb jstack --locks --mixed -pid 11666：打印11666进程的栈、本地方法栈以及持有锁的额外信息

6）jhsdb jsnap --all -pid 11666：打印11666进程所有性能计数器的信息=jcmd的PerfCounter.print


```

#### JDK内置 - 可视化工具

##### jhsdb

jhsdb hsdb --pid 11666：进入11666进程的图形化界面，其菜单功能包括：

- Inspect Thread：这个线程的诊断信息，包含对象头和指向对象元数据的指针（Java类型的名字、继承关系、实现接⼝关系，字段信息、⽅法信息、运⾏时常量池的指针、内嵌的虚⽅法表（vtable）以及接⼝⽅法表（itable）等）。
- Stack Memory：这个线程栈的内存数据信息。
  - 第⼀列：内存地址（虚拟地址，⾮物理内存地址）。
  - 第⼆列：该地址上存储的数据，以字宽为单位。
  - 第三列是：对数据的注释，竖线表示范围，横线或斜线连接范围与注释⽂字。
- Show Java stack trace：这个线程的线程栈信息。
- Show Thread Information：这个线程的其他信息。
- Find Crashes：可找出这个线程崩溃的原因。
- Windows Console：可输⼊诊断命令，也就是jhsdb clhsdb命令交互页面。

![1626576342750](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1626576342750.png)

##### jconsole

- Java Monitoring and Management Console，是⼀款基于JMX（Java Manage-ment Extensions）的可视化监控、管理⼯具，主要是通过JMX的MBean（Managed Bean）对系统进⾏信息收集和参数动态调整。
  - JMX是⼀种开放性的技术，它既可以⽤在虚拟机本身的管理上，也可以⽤于运⾏在虚拟机之上的软件中。⽬前很多软件都⽀持基于JMX进⾏管理与监控。
- 执行jconsole命令打开界面，然后输入线程号即可。

![1626576867182](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1626576867182.png)

##### VisualVM

- 也叫JVisualVM，是⼀个All-in-One Java Troubleshooting Tool，即多合一的故障排查工具，从JDK 6开始提供，是⽬前最强⼤的监控及故障处理程序之⼀。
- JDK 8输入jvisualvm启动即可，JDK 9输入独自安装，其界面菜单功能包括：
  - Overview：展示应⽤的概要信息，相当于可视化的jps、jinfo。
  - Monitor：展示一些监控信息，包括CPU、内存、类、线程等曲线图，Perform GC按钮通知JVM执⾏垃圾回收，Heap Dump按钮Dump堆，相当于jmap dump命令。
  - Threads：展示查看线程状态，以及Thread Dump按钮Dump线程，相当于jstack。
  - Sampler：抽样器，可⽤于实时性能分析，支持CPU抽样以及内存抽样。
  - Profiler：性能分析，提供了程序运⾏期⽅法级的处理器执⾏时间分析及内存分析。
    - 执⾏该性能分析，会对程序运⾏性能有⽐较⼤的影响，⼀般不建议在⽣产环境使⽤这项功能，建议使用JMC来代替。
    - 开启类共享（⼀种共享类，从⽽提升加载速度、节省内存的技术）可能会导致执⾏Profiler的应⽤崩
      溃，建议在执⾏Profiler的应⽤上添加-Xshare:off，关闭掉类共享。
  - 分析堆dump文件：File -> Load -> 选择hprof -> 打开 -> 分析。
  - 其他插件：VisualVM还支持安装插件来扩展功能，比如Visual CC来实时分析垃圾回收的情况。

![1626577315983](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1626577315983.png)

##### JDK Mission Control

- 也叫Java Mission Control，简称JMC，是一款监控、定义线上问题以及性能调优的神器。
  - 它是⼀款商业授权⼯具（例如在JDK 8中），需要商业授权才能在⽣产环境中使⽤，现已开源，在JDK 11（哪怕是OpenJDK）中，任何⼈都可以使⽤JFR + JMC（需遵循 UPL协议 ）。
- JMC的两大功能：
  - 作为JMX控制台，监控虚拟机MBean提供的数据。
  - 可持续收集数据的JFR，并可作为JFR的可视化分析⼯具。
    - JFR：Java Flight Recorder，是⼀种⽤于收集有关运⾏中的Java应⽤的诊断信息和性能数据的⼯具。它⼏乎没有性能开销，因此，即使在负载很⼤的⽣产环境中也可以使⽤。
    - 主要用于性能分析、性能分析、⽀持与调试的场景。
- MBean服务器菜单功能介绍：
  - 概览：各种概要信息。
  - MBean浏览器：展示应⽤被JMX管理的Bean。
  - 触发器：配置触发规则，当规则满⾜时，就触发某个操作（在操作⼀栏配置）。
  - 系统：查看系统相关信息。
  - 内存：查看内存相关信息。
  - 线程：查看线程相关信息。
  - 诊断命令：可视化使⽤诊断命令，相当于可视化的jcmd。
- 飞行记录性菜单功能介绍：
  - 如果应用JDK版本 < JDK11，则启动项目时需要添加-XX:+UnlockCommercialFeatures -XX:+FlightRecorder。
  - ⾃动分析结果：JMC⾃动给出的优化提议。
  - Java应⽤程序：展示应⽤的各种执⾏情况。
  - JVM内部：展示JVM层⾯的执⾏情况。
  - 环境：展示操作系统层⾯的执⾏情况。
  - 事件：展示录制期间发⽣的事件。
- JMC优点：
  - JFR在⽣产环境中对吞吐量的影响⼀般不会⾼于1%。
  - JFR监控过程是可动态的，⽆需重启。
  - JFR监控过程对应⽤完全透明，⽆需修改应⽤的代码，也⽆需安装额外的插件或代理。
  - JFR提供的数据质量⾮常⾼，对监控、排查的参考价值更⼤。
- JMC缺点：
  - JFR并不完全向后兼容。⽐如，在JDK 11⾥⾯⽣成的JFR⽂件，⽤早期的JMC（例如JMC 5.5）⽆法打开。
  - JMC 7.0.1⽆法分析堆dump⽂件（hprof格式），但 官⽅Wiki 宣称⽀持分析堆dump⽂件。

![1626578206459](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1626578206459.png)

#### 第三方工具

##### Memory Analyzer Tool

- Memory Analyzer Tool，简称MAT，可以作为独⽴软件，也可作为Eclipse插件存在，是⼀个快
  速且功能丰富的Java堆内存分析器，可帮助您查找内存泄漏并减少内存消耗。

- MAT主要功能：

  - 找出内存泄漏的原因。
  - 找出重复引⽤的类和jar。
  - 分析集合的使⽤。
  - 分析类加载器。

- 相关概念：

  - **浅堆**：一个对象E自身所消耗的内存，根据堆转储格式，对象⼤⼩可能会被调整（例如，对⻬为8bit），从⽽更好地模拟VM的实际消耗量。⼀般来说，对象的浅堆是对象在堆中的⼤⼩，⽽同⼀对象的保留⼤⼩是在垃圾回收对象时将释放的堆内存量。
  - **X的保留集**：Retained set，当E被垃圾回收时，由GC删除的对象集E和G。同理，如果E没有被回收，那么该集合中的对象E和G都会“保留下来”。
  - **X的保留堆**：Retained heap，指的是对象E的保留集E和G的内存⼤⼩，即由于它的存活导致多⼤的内存没有被回收。
  - **前导对象集的保留集**：前导对象E不可达时，被释放的那些对象E和G，所以这里前导对象集E的保留集为E和G。

  ![1626581295844](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1626581295844.png)

  - **支配树**：MAT提供了对象图的⽀配树，通过将对象参考图转换为⽀配树，可以轻松地识别最⼤的保留内存块以及对象之间的依赖关系。⽀配树是在对象图的基础上建⽴的，在⽀配树中，每个节点都是其⼦节点的直接⽀配者。因此，基于⽀配树可以轻松看出对象之间的依赖关系。其具有以下属性：
    - 对象从属于X的⼦树（例如对象被X⽀配）就是X的Retained set。
      - **X⽀配Y**：如果对象图中从起始（或Root）节点到Y的每条路径都必须经过X，那么就说对象X⽀配对象Y。
      - **直接⽀配者**：某个对象路径最短的⽀配者。
      - **间接支配者**：一个对象X支配了该对象Y，但又不是Y的直接支配者，则称X为Y的间接支配者。
    - 如果X是Y的直接⽀配节点，那么⽀配X的节点也可以⽀配Y。
    - ⽀配树中的边并不直接对应于对象图中的对象引⽤。

  ![1626582280791](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1626582280791.png)

- MAT菜单功能介绍：

  - inspector：透视图，⽤于展示⼀个对象的详细信息，例如内存地址、加载器名称、包名、对象名称、对象所属的类的⽗类、对象所属的类的加载器对象、该对象的堆内存⼤⼩和保留⼤⼩，gc root信息。下半部分展示类的静态属性和值、对象的实例属性和值、对象所属的类的继承结构。
  - Heap Dump History：列出最近分析过的⽂件。
  - 功能选择栏：从左到右依次是：概览、类直⽅图、⽀配树、OQL查询、线程视图、报告相关、详细功能。其中概览就是上图的这个⻚⾯，其他则提供了⼀些更细致的分析能⼒。总的来说，功能上和VisualVM⼤同⼩异，但分析得更加细致。
  - 饼图：展示retained size对象占⽤⽐例。
  - Actions：常⽤的内存分析动作。
    - Histogram：列出内存中的对象，对象的个数及其⼤⼩。点击后⽣成的报表：
      - Class Name ： 类名称，java类名。
      - Objects ： 类的对象的数量，这个对象被创建了多少个。
      - Shallow Heap ：⼀个对象内存的消耗⼤⼩，不包含对其他对象的引⽤。
      - Retained Heap ：是shallow Heap的总和，也就是该对象被GC之后所能回收到内存的总和。
    - Dominator Tree：列出最⼤的那些对象，以及他们为什么存活。
    - Top Consumers：打印最昂贵的对象，以内和包分组。
    - Duplicate Classes：检测被多个classloader加载的类。
  - Reports：报表功能，包括：
    - Leak Suspects：⾃动分析内存泄漏的原因，并能直接定位到Class，找到可能导致内存泄露的代码⾏数。
    - Top Components：列出占⽤超过1%的组件的报告信息。
  - Step by Step：
    - Top Components：分析从属于指定包或者class loader的对象。

![1626582745483](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1626582745483.png)

##### JITWatch

- JITWatch是JIT编译器的⽇志分析器与可视化⼯具，可⽤来检查内联决策、热点⽅法、字节码以及汇编的各种细节，经常和HSDIS配合使⽤，实际中用的也不是特别多。
  - HSDIS是⼀个HotSpot虚拟机即时编译代码的反汇编插件，它包含在HotSpot虚拟机的源码当中，在OpenJDK的⽹站也可以找到单独的源码下载，但并没有提供编译后的程序。
- 安装HSDIS后，启动应用，添加以下参数，用于收集反汇编日志，执行完后将会⽣成⼀个  /Users/itmuch.com/logfile.log ⽂件，⾥⾯包括了各种类编辑以及汇编信息。
  - UnlockDiagnosticVMOptions：开启诊断信息。
  - PrintAssembly：输出反汇编内容。
  - Xcomp：以编译模式启动，这样，⽆执⾏⾜够次数来预热即可触发即时编译。
  - LogCompilation：打印编译相关信息。
  - LogFile：指定⽇志⽂件。
  - TraceClassLoading：是否跟踪类的加载。

```java
java -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -Xcomp -XX:+LogCompilation -XX:LogFile=/Users/itmuch.com
/logfile.log -XX:+TraceClassLoading -jar xxx.jar


```

- 最后使用JITWatch可视化阅读⽇志，使用以下命令启动JITWatch，选择反汇编日志，点击start即可可视化地分析了。

```java
mvn clean compile exec:java


```

![1626583188575](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1626583188575.png)

### 3.3. JVM参数选项？

笔记时间：2021-07-18。

#### 标准选项

- 用于**执行常见操作**（比如检查JRE版本、设置类路径、启动详细输出等），各种厂牌的虚拟机都会支持。
- **格式不统一**，以java -help的结果为准。
- **常见的标准选项有**：

| JVM参数                          | 作用                                                         |
| -------------------------------- | ------------------------------------------------------------ |
| -class-path \| -classpath \|- cp | 指定JVM类搜索路径，多个路径之间以分号隔开。如果指定了-classpath，则JVM就忽略系统变量CLASSPATH中指定的路径。如果-classpath和CLASSPATH都没有指定，则JVM会从当前路径寻找class |
| -server                          | 以server模式启动JVM，与client模式恰好相反。适合生产环境，适用于服务器。64位的JVM自动以server模式启动 |
| -client                          | 以client模式启动JVM，这种方式启动速度快，但运行时性能和内存管理效率不高，适合客户端程序或者开发调试。64位的JVM不支持client模式 |
| -Dproperty=value                 | 设置系统属性值。其中， property是属性名称，value是属性值，如果value有空格，则需要使用双引号，比如-Dfoo=“foo bar” |
| -javaagent：jarpath[=options]    | 加载指定的Java编程语言代理                                   |
| -verbose：class                  | 显示类加载相关的信息，当报找不到类或者类冲突时，可用此参数来诊断 |
| -verbose：gc                     | 显示垃圾收集事件的相关信息                                   |
| -verbose：jni                    | 显示本机方法和其他Java本机接口（JNI）的相关信息              |
| -version                         | 展示JDK版本                                                  |

#### 附加选项

- JDK 11文档中称为**额外参数**，JDK 8文档中称为**非标准参数**，是**Hotspot虚拟机的通用选项**，其他厂牌的JVM不一定会支持，并且未来可能会发生变化。
- 附加选项都以**-X开头**，具体以java -x的结果为准。
- **常见的附加选项有**：

| JVM参数                  | 默认值                                                       | 作用                                                         |
| ------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| -Xcomp                   | 默认情况下，client模式下会解释执行10000次（< JDK 11），server模式下会解释执行10000次，并收集信息，此后才可能编译运行。 | 在第一次调用时强制编译方法。指定该选项将禁用解释方法调用。此外，还可使用-XX：CompileThreshold选项更改在编译之前解释执行方法的调用次数 |
| -Xint                    | -                                                            | 以解释模式运行                                               |
| -Xmixed                  | -                                                            | 热点方法以编译模式运行，其他方法以解释模式运行               |
| -Xloggc：option          | -                                                            | 将GC事件的相关信息记录到文件中                               |
| -Xnoclassgc              | -                                                            | 禁用类的垃圾收集。使用该参数可节省一些GC时间，缩短应用程序运行期间的停顿。但一旦使用该参数，那么应用程序中的类对象就会始终被视为活动对象，从而导致这块内存被永久占用。如果使用不当，将会导致内存溢出 |
| -Xshare：mode            | auto：尽可能使用CDS，是32位的Hotspot JVM的默认值；on：开启CDS。如果CDS无法被开启，将会打印错误信息；off：不适用CDS | 设置类数据共享模式（class data sharing，即CDS）。注意，此选项只应用于测试目的，并且可能由于操作系统使用地址空间布局随机化而导致间歇性故障，不应在生产环境中使用 |
| -XshowSettings：category | all：默认值，展示所有设置；locale：展示语言环境相关的设置；properties：展示系统属性相关的设置；vm：展示JVM的设置；system：展示Linux主机系统或者容器的配置 | 展示设置                                                     |
| -Xmn                     | -                                                            | 设置年轻代的初始值以及最大值，以字节为单位，也可在size后追加字母k或者K表示千字节，m或者M表示兆字节，g或者G表示千兆字节，例如-Xmn256m。此外，还可用-XX：NewSize设置年轻代初始大小，-XX：MaxNewSize设置年轻代最大大小 |
| -Xms                     | -                                                            | 设置堆内存的初始大小，以字节为单位。此值必须是1024的倍数且大于1MB。如果未设置此选项，则将堆内存初始大小设置为老年代和年轻代分配的大小之和。设置格式同-Xmn，例如-Xms6144K |
| -Xmx                     | -                                                            | 设置堆内存的最大大小，以字节为单位。此值必须是1024的倍数且大于2MB。等效于-XX：MaxHeapSize |
| -Xss                     | 默认值取决于平台，64位Linux：1024KB；64位 MacOS：1024KB；64位Oracle Solaris：1024KB；Windows：默认值取决于虚拟内存 | 设置线程栈大小，以字节为单位                                 |

#### 高级选项

- 高级选项是**为开发人员提供的选项**，用于调整Java **HotSpot虚拟机**操作的特定区域（这些区域通常具有特定的系统要求，并且可能需要对系统配置参数的特权访问），其他厂牌的JVM不一定会支持，并且未来可能会发生变化。
- 高级选项都以**-XX开头**，可以使用以下方法查看所支持的选项：

```java
1）解锁参数并打印：java -XX:+UnlockExperimentalVMOptions -XX:+UnlockDiagnosticVMOptions -XX:+PrintFlagsInitial

2）jhsdb clhsdb --pid 11666，进入交互页面后使用flags查看


```

- **使用格式**：
  - **boolean类型**：格式为-XX：（+/-），+表示将选项设置为true，-表示将选项设置为false。
  - **非boolean类型**：格式为-XX：选项=值。
- **常见的高级选项有**：

##### 常用高级运行时选项

用于控制HotSpot VM的运行时的各种行为。

| JVM参数                               | 默认值或者取值方式 | 作用                                                         |
| ------------------------------------- | ------------------ | ------------------------------------------------------------ |
| -XX：ActiveProcessorCount=n           | -                  | JVM使用多少个CPU核心，去计算用于执行垃圾收集或者ForkJoinPool线程池的大小 |
| -XX：InitiatingHeapOccupancyPercent=n | 45                 | 老年代大小到达该阈值，会触发G1 Mixed GC                      |
| -XX：LargePageSizeInBytes=n           | -                  | 设置用于Java堆的大页面尺寸，以字节为单位，其数值必须是2的幂次，也可在size后追加字母k或者K表示千字节，m或者M表示兆字节，g或者G表示千兆字节 |
| -XX：MaxDirectMemorySize=n            | -                  | 设置java.nio包的直接缓存区分配的最大总大小，以字节为单位，也可在size后追加字母k或者K表示千字节，m或者M表示兆字节，g或者G表示千兆字节 |
| -XX：MaxGCPauseMillis=n               | 200ms              | 期望的最大停顿时间                                           |
| -XX：OnError=string                   | -                  | 发生错误的时候做某事，string是一个或者多个命令，多个命令使用分号分隔，如果字符串包含空格，则必须将其用引号引起来。比如“gcore %p；dbx - %p”，表示当发生错误时，使用gcore命令创建核心dump文件 |
| -XX：OnOutOfMemoryError=string        | -                  | 当发生OOM异常时做模式，配置格式同-XX：OnError                |
| -XX：ParallelGCThreads=n              | -                  | 设置GC并行阶段的线程数                                       |
| -XX：+PrintCommandLineFlags           | 关闭               | 打印命令行标记                                               |
| -XX：ThreadStackSize=size             | -                  | 设置线程栈的大小，和-Xss等价                                 |
| -XX：-UseBiasedLocking                | -                  | 禁用偏向锁                                                   |
| -XX：-UseCompressedOops               | 启用               | 禁用压缩指针。此选项仅适用于64位JVM，当Java堆大小小于32GB时，将使用压缩指针。启用此选项后，对象引用将表示为32位偏移量，而非64位指针，这通常会在运行Java堆大小小于32GB的应用程序时提高性能。当Java堆大小大于32GB时，可使用-XX：ObjectAlignmentInBytes选项 |
| -XX：GCLogFileSize=n                  | 512KB              | 处理大型日志文件                                             |
| -XX：+UseLargePages                   | 关闭               | 启用大页面内存的使用                                         |
| -XX： VMOptionsFile=filename          | -                  | 允许用户在文件中指定VM选项。比如java -XX：VMOptionsFile=/var/my_vm_options_HelloWorld |
|                                       |                    |                                                              |
| 元空间参数                            |                    |                                                              |
| -XX：MetaspaceSize                    | 20.8MB             | 元空间的初始值，元空间占用达到该值就会触发垃圾回收，进行类的卸载，同时收集器会自动调整该值。如果能够释放空间，则会自动降低该值（减少空间浪费）；如果释放空间很少，则在不超过-XX：MaxMetaspaceSize的情况下，适当提高该值（保证有足够空间） |
| -XX：MaxMetaspaceSize                 | 受限于本地内存大小 | 元空间大小的最大值                                           |
| -XX：MinMetaspaceFreeRatio            | 40%                | 垃圾收集后，计算当前元空间的空闲百分比，如果小于该值，则增加元空间的大小（保证有足够空间） |
| -XX：MaxMetaspaceFreeRatio            | 70%                | 垃圾收集后，计算当前元空间的空闲百分比，如果大于该值，则减少元空间的大小（减少空间浪费） |
| -XX：MinMetaspaceExpansion            | 332.8KB            | 元空间增长时的最小幅度                                       |
| -XX：MaxMetaspaceExpansion            | 5.2MB              | 元空间增长时的最大幅度                                       |
|                                       |                    |                                                              |
| 直接内存参数                          |                    |                                                              |
| -XX：MaxDirectMemorySize              | -                  | 设置最大直接内存大小，对Unsafe不起作用，但对ByteBuffer有效   |
|                                       |                    |                                                              |
| TLAB参数（不建议修改）                |                    |                                                              |
| -XX：+UseTLAB                         | 开启               | 是否启用线程私有分配缓存区（Thread-Local Allocation Buffer） |
| -XX：MinTLABSize                      | 2048B              | 最小TLAB大小，单位字节                                       |
| -XX：+ResizeTLAB                      | 是                 | 是否动态调整TLAB的大小                                       |
| -XX：TLABRefillWasteFraction          | 64                 | 由于TLAB空间比较小，因此很容易装满。比如TLAB 100KB，已使用80KB，当需要再分配一个30KB的对象时，就无法分配到这个TLAB了。这时虚拟机会有两种选择，第一，废弃当前TLAB，这样就会浪费20KB的空间；第二，保留当前的TLAB并将这30KB的对象直接分配在堆上，这样将来有小于20KB的对象时，仍可以使用这块空间。实际上，JVM内部维护了一个叫做refill_waste的值，当请求对象大于refill_waste时，会在堆中分配；若小于该值，则会废弃当前TLAB，新建TLAB分配对象。可以用TLABRefillWasteFraction来调整该阈值，表示TLAB中允许产生这种浪费的比例，默认为64，即允许使用1/64的TLAB空间作为refill_waste。默认情况下，TLAB和refill_waste都会在运行时不断地调整，使系统的运行状态达到最优。如果想要禁用自动调整TLAB的大小，可以使用-XX：-ResizeTLAB禁用ResizeTLAB，并使用-XX：TLABSize手工指定一个TLAB的大小 |
| -XX：+TLABStats                       | 是                 | 是否提供详细的TLAB的统计信息                                 |
| -XX：TLABSize                         | 0                  | 设置TLAB的初始大小，如果设置为0，JVM会自动设置TLAB的初始大小 |
| -XX：TLABWasteTargetPercent           | 1                  | 允许TLAB占用Eden空间的百分比                                 |

##### 常用高级JIT编译器选项

用于控制HotSpot VM如果执行的JIT编译。

| JVM参数                                       | 默认值                                                   | 作用                                                         |
| --------------------------------------------- | -------------------------------------------------------- | ------------------------------------------------------------ |
| -XX：+BackgroundCompilation                   | 开启                                                     | 启用JIT后台编译                                              |
| -XX：CompileCommand=command，method[，option] | -                                                        | 在指定方法上执行指定command。command可选项为：break：在调试JVM时设置一个断点，以便在指定方法编译开始时停止； compileonly：排除所有未指定的所有方法；dontinline：防止内联指定方法；exclude：排除指定的方法；help：打印-XX： CompileCommand选项的帮助信息；inline：尝试内联指定的方法；log：排除指定方法以外的所有方法的编译日志记录（用-XX：+Log Compilation打印编译日志），默认情况下将对所有编译方法执行日志记录；option：将JIT编译选项传递给指定的方法，以代替最后一个参数（option）。编译选项设置在方法名称之后，且可指定多个编译选项，以逗号或者空格分隔；print：在编译指定的方法后打印生成的汇编代码；quiet：不打印编译命令，默认情况下，将显示使用-XX：CompileCommand选项指定的命令 |
| -XX：+DoEscapeAnalysis                        | 开启                                                     | 启用逃逸分析                                                 |
| -XX：+Inline                                  | 开启                                                     | 启用方法内敛                                                 |
| -XX：InlineSmallCode=n                        | 1000B                                                    | 指定内联的以编译的方法的最大代码大小，以字节为单位           |
| -XX：+LogCompliation                          | 关闭                                                     | 将编译活动记录到当前工作目录的hotspot.log文件中，也可用+XX：LogFile选项来指定其他日志文件路径和名称。该选项必须与-XX：+ UnlockDiagnosticVMOptions配合使用 |
| -XX：MaxInlineSize=n                          | -                                                        | 设置要内联的方法的最大字节码大小，以字节为单位               |
| -XX：+PrintAssembly                           | 关闭                                                     | 打印字节码和本地方法的汇编代码，需要HSDIS的支持。该选项必须与-XX：+ UnlockDiagnosticVMOptions配合使用 |
| -XX：+PrintCompaction                         | 关闭                                                     | 打印哪些方法被内联。该选项必须与-XX：+ UnlockDiagnosticVMOptions配合使用 |
|                                               |                                                          |                                                              |
| CodeCache参数                                 |                                                          |                                                              |
| -XX：ReservedCodeCacheSize=n                  | 不同版本不同，JDK 8 + 64位以及JDK 11 + 64位都是240MB     | 设置 JIT编译的代码的最大代码缓存大小，以字节为单位，最大不超过2GB，否则会产生错误。该配置不应小于-XX： InitialCodeCacheSize的值，以java -XX：PrintFlagsFianl \| grep ReservedCodeCacheSize的结果为准 |
| -XX：InitialCodeCacheSize=n                   | 不同的操作系统，以及不同的编译器的值也会不同，一般为48MB | 设置代码缓存区的初始大小，以java -XX：PrintFlagsFianl \| grep InitialCodeCacheSize的结果为准 |
| -XX：-PrintCodeCache                          | 关闭                                                     | 在JVM停止时打印代码缓存的使用情况                            |
| -XX：-PrintCodeCacheOnCompilation             | 关闭                                                     | 每当方法被编译后，就打印一下代码缓存区的使用情况             |
| -XX：+UseCodeCacheFlushing                    | 打开                                                     | 代码缓存区即将耗尽时，尝试回收一些早期编译但又很久没有被调用的方法 |
| -XX：-SegementedCodeCache                     | 关闭，表示使用整体的代码缓存区                           | 是否使用分段的代码缓存区                                     |

##### 常用高级可服务性选项

用于控制系统信息收集与调试支持。

| JVM参数                                  | 默认值                                | 作用                                                         |
| ---------------------------------------- | ------------------------------------- | ------------------------------------------------------------ |
| -XX：HeapDumpPath=path                   | -                                     | 指定堆Dump的文件路径，经常和-XX：+HeapDumpOnOutOf MemoryError选项配合使用 |
| -XX：LogFile=path                        | 在当前工作目录中创建，名为hotspot.log | 指定日志文件的路径，经常和-XX：+LogCompilation配合使用       |
| -XX：+Unlock ExperimentalVMOptions       | 关闭                                  | 用于解锁JVM实验性参数                                        |
| -XX：+UnlockDiagnosticVMOptions          | 关闭                                  | 用于解锁JVM诊断性参数                                        |
|                                          |                                       |                                                              |
| JDK 8日志参数                            |                                       |                                                              |
| -XX：+PrintFlagsInitial                  | 关闭                                  | 打印支持的高级选项，并展示默认值                             |
| -XX：+PrintGC                            | 关闭                                  | 输出GC日志                                                   |
| -XX：+PrintGCDetails                     | 关闭                                  | 打印GC详情                                                   |
| -XX：+PrintGCCause                       | 打开                                  | 是否在GC日志中打印造成GC的原因                               |
| -XX：+PrintGCID                          | 关闭                                  | 打印垃圾GC的唯一标识                                         |
| -XX：+PrintGCDateStamps                  | 关闭                                  | 以日期的格式输出GC的时间戳，如2013-05-04T21：53：59.234+0800 |
| -XX：+PrintGCTimeStamps                  | 关闭                                  | 以基准时间的格式，打印GC时间戳                               |
| -XX：+PrintHeapAtGC                      | 关闭                                  | 在GC前后打印堆信息                                           |
| -XX：+PrintHeapAtGCExtended              | 关闭                                  | 在开启PrintHeapAtGC的前提下，额外打印更多堆的相关信息        |
| -XX：+PrintGCApplicationStoppedTime      | 关闭                                  | 打印垃圾回收期间程序暂定的时间                               |
| -XX：+PrintGCApplicationConcurrentTime   | 关闭                                  | 打印每次垃圾回收前，程序未中断的执行时间，可与PrintGCApplicationStoppedTime配合使用 |
| -XX：+PrintClassHistogramAfterFullGC     | 关闭                                  | Full GC之后打印堆的直方图                                    |
| -XX：+PrintClassHistogramBeforeFullGC    | 关闭                                  | Full GC之前打印堆的直方图                                    |
| -XX：+PrintReferenceGC                   | 关闭                                  | 打印处理引用对象的时间消耗，需开启PrintGCDetails才有效       |
| -XX：+PrintTLAB                          | 关闭                                  | 查看TLAB空间的使用情况                                       |
| -XX：-UseGCLogFileRotation               | 关闭                                  | 轮换文件，日志文件达到一定大小后，就创建一个新的日志文件。需指定-Xloggc：时才有效 |
| -XX：GCLogFileSize                       | 8KB                                   | 设置单个日志文件的大小，需开启UseGCLogFileRotation才有效     |
| -XX：NumberOfGCLogFiles                  | 0，表示保留所有日志                   | 日志轮换时，保留几个日志文件                                 |
| -Xloggc：path                            | -                                     | 指定GC日志文件路径                                           |
| -XX：+PrintAdaptiveSizePolicy            | 关闭                                  | 某些GC收集器有自适应策略，自适应调整策略会动态调整Eden、Survivor、老年代的大小。使用该标记，可打印自适应调节策略的相关信息 |
| -XX：+PrintTenuringDistribution          | 关闭                                  | 查看每次Minor GC后新的存活周期的阈值                         |
| -XX：G1PrintRegionLivenessInfo           | -                                     | 标记阶段结束后打印所有Region的存活情况，需开启-XX：+UnlockDiagnosticVMOptions后才能使用 |
| -XX：+G1PrintHeapRegions                 | -                                     | 打印堆的区域上的分配和释放的信息，需开启-XX：+UnlockDiagnosticVMOptions后才能使用 |
| -XX：+PrintStringDeduplicationStatistics | -                                     | JDK 8u20开始，使用G1垃圾收集器，可支持-XX：+UseStringDeduplication开启字符串去重。可用-XX：+PrintStringDeduplicationStatistics打印字符串去重的统计信息 |
|                                          |                                       |                                                              |
| JDK 11统一日志管理（只剩下两个）         |                                       |                                                              |
| -XX：+PrintGC                            | 关闭                                  | 输出GC日志                                                   |
| -XX：+PrintGCDetails                     | 关闭                                  | 打印GC详情                                                   |

##### 常用高级垃圾收集选项

用于控制HotSpot VM如何执行垃圾收集

| 收集器                | 参数以及默认值                             | 备注                                                         |
| --------------------- | ------------------------------------------ | ------------------------------------------------------------ |
| Serial                | -XX：+UseSerialGC                          | 虚拟机在Client模式下的默认值，开启后，使用Serial + Serial Old的组合 |
| ParNew                | -XX：+UseParNewGC                          | 开启后，使用ParNew + Serial Old的组合                        |
|                       | -XX：ParallelGCThreads=n                   | 设置垃圾收集器在并行阶段使用的垃圾收集线程数，当逻辑处理器小于8时，n的值与逻辑处理器数量相同；如果逻辑处理器数量大于8时，则n的值大约为逻辑处理器数量的5/8，大多数情况下是这样，除了较大的SPARC系统，其中n的值约为逻辑处理器的5/16 |
| Parallel Scavenge     | -XX：+UseParallelGC                        | 虚拟机在Server模式下的默认值，开启后，使用Parallel Scavenge + Serial Old的组合 |
|                       | -XX：MaxGCPauseMillis=n                    | 收集器尽可能保证单次内存回收停顿的时间不超过这个值，但是并不保证不超过该值，只是尽可能 |
|                       | -XX：GCTimeRatio=n                         | 设置吞吐量的大小，取值范围为0~100，假设GCTimeRatio的值为n，那么系统将花费不超过1 / （1 + n）的时间用于垃圾收集 |
|                       | -XX：+UseAdaptiveSizePolicy                | 开启后，无需人工指定新生代的大小（-Xmn）、Eden和Survivor的比例（-XX：SurvivorRatio）以及晋升老年代对象的年龄（-XX：PretenureSizeThreshold）等参数，收集器会根据当前系统的运行情况自动调整 |
| Serial Old            | 无                                         | Serial Old是Serial的老年代版本，主要用于Client模式下的老年代收集，同时也是CMS在发生Concurrent Mode Failure时的后备方案 |
| Parallel Old          | -XX：+UseParallelOldGC                     | 开启后，使用Parallel Scavenge + Parallel Old的组合。Parallel Old是Parallel Scavenge的老年代版本，在注重吞吐量和CPU资源敏感的场合，可以优先考虑这个组合 |
| CMS                   | -XX：+UseConcMarkSweepGC                   | 开启后，使用ParNew + CMS的组合，Serial Old收集器将作为CMS收集器出现Concurrent Mode Failure失败后的后备收集器使用 |
|                       | -XX：CMSInitiatingOccupancyFraction=68     | CMS收集器在老年代空间被使用多少后触发垃圾收集，默认68%       |
|                       | -XX：+UseCMSCompactAtFullCollection        | 在完成垃圾收集后是否要进行一次内存碎片整理，默认开启         |
|                       | -XX：CMSFullGCsBeforeCompaction=0          | 在进行若干次Full GC后就进行一次内存碎片整理，默认为0         |
|                       | -XX：+UseCMSInitiatingOccupancyOnly        | 允许使用占用值作为启动CMS收集器的唯一标准，一般和CMSFullGCsBeforeCompaction配合使用。如果开启，那么当CMSFullGCsBeforeCompaction达到阈值就开始GC，如果关闭，那么JVM仅在第一次使用CMSFullGCsBeforeCompaction的值，后续则自动调整，默认关闭 |
|                       | -XX：+CMSParallelRemarkEnabled             | 重新标记阶段会并行执行，使用此参数可降低标记停顿，默认打开（仅适用于CMS + ParNew的GC） |
|                       | -XX：+CMSScavengeBeforeRemark              | 开启或关闭在CMS重新标记阶段之前的清除Young GC的尝试。新生代里一部分对象会作为GC Roots，让CMS在重新标记之前，做一次Young GC，而YGC能够回收掉新生代里大多数对象，这样就可以减少GC Roots的开销。因此，打开此开关，可在一定程度上降低CMS重新标记阶段的扫描时间，当然，开启此开关后，Young GC也会消耗一些时间。PS：开启此开关并不保证在标记阶段前一定会进行清除操作，生产环境建议开启，默认关闭 |
| CMS-Precleaning       | -XX：+CMSPrecleaningEnabled                | 是否启用并发预清理，默认开启                                 |
| CMS-AbortablePreclean | -XX：CMSScheduleRemarkEdenSizeThreshold=2M | 如果Eden区的内存使用超过该值，才可能进入并发可中止的预清理阶段 |
| CMS-AbortablePreclean | -XX：+CMSMaxAbortablePrecleanTime=5000     | 并发可终止的预清理阶段持续的最大时间                         |
| CMS                   | -XX：+CMSClassUnloadingEnabled             | 使用CMS时，是否启用类卸载，默认开启                          |
|                       | -XX：+ExplicitGCInvokesConcurrent          | 显示调用System.gc（）会触发Full GC，会有Stop The World，开启此参数后，可让System.gc（）触发的垃圾回收变成一次普通的CMS GC |
| G1                    | -XX：+UseG1GC                              | 使用G1收集器                                                 |
|                       | -XX：G1HeapRegionSize=n                    | 设置每个 Region的大小，该值必须为2的幂次，范围为1M到32M，如果不指定G1会根据堆的大小自动决定 |
|                       | -XX：MaxGCPauseMillis=200                  | 设置最大停顿时间，默认值为200毫秒                            |
|                       | -XX：G1NewSizePercent=5                    | 设置年轻代占整个堆的最小百分比，默认值为5，这是个实验参数，需要-XX：+UnlockExperimentalVMOptions解锁实验参数后，才能使用该参数 |
|                       | -XX：G1MaxNewSizePercent=60                | 设置年轻代占整个堆的最大百分比，默认值为60，这是个实验参数，需要-XX：+UnlockExperimentalVMOptions解锁实验参数后，才能使用该参数 |
|                       | -XX：ParallelGCThreads=n                   | 设置垃圾收集器在并行阶段使用的垃圾收集线程数，当逻辑处理器小于8时，n的值与逻辑处理器数量相同；如果逻辑处理器数量大于8时，则n的值大约为逻辑处理器数量的5/8，大多数情况下是这样，除了较大的SPARC系统，其中n的值约为逻辑处理器的5/16 |
|                       | -XX：ConcGCThreads=n                       | 设置垃圾收集器并发阶段使用的线程数量，设置n大约为ParallelGCThreads的1/4 |
|                       | -XX：InitiatingHeapOccupancyPercent=45     | 老年代大小达到该阈值，则会触发Mixed GC，默认值为45           |
|                       | -XX：G1MixedGCLiveThresholdPercent=85      | Region中的对象，活跃度低于该阈值，才可能被包含在Mixed GC收集周期中，默认值为85，这是个实验参数，需要-XX：+UnlockExperimentalVMOptions解锁实验参数后，才能使用该参数 |
|                       | -XX：G1HeapWastePercent=5                  | 设置浪费的堆内存百分比，当可回收百分比小于浪费百分比时，JVM就不会启动Mixed GC，从而避免昂贵的GC开销。此参数相当于用来设置允许垃圾对象占用内存的最大百分比。 |
|                       | -XX：G1MixedGCCountTarget=8                | 设置在标记周期完成之后，最多执行多少个Mixed GC，默认值为8，启动多个Mixed GC可以缩短老年代的收集时间 |
|                       | -XX：G1OldCSetRegionThresholdPercent=10    | 设置在一次Mixed GC中被收集的老年代的比例上限，默认值为Java堆的10%，这是个实验参数，需要-XX：+UnlockExperimentalVMOptions解锁实验参数后，才能使用该参数 |
|                       | -XX：G1ReservePercent=10                   | 设置预留空闲内存百分比，虚拟机会保证Java堆有这么多空间可用，从而防止对象晋升时无空间可用而失败，默认值为Java堆的10% |
|                       | -XX：G1PrintHeapRegions                    | 输出Region被分配和回收的信息，默认为false                    |
|                       | -XX：G1PrintRegionLivenessInfo             | 在清理阶段的并发标记环节，输出堆中的所有Regions的活跃度信息，默认为fasle |
| Shenandoah            | -XX：+UseShenandoahGC                      | 使用Shenandoah收集器，这是个实验参数，需要-XX：+UnlockExperimentalVMOptions解锁实验参数后，才能使用该参数 |
| ZGC                   | -XX：+UseZGC                               | 使用ZGC收集器，这是个实验参数，需要-XX：+UnlockExperimentalVMOptions解锁实验参数后，才能使用该参数 |
| Epsilon               | -XX：+UseEpsilonGC                         | 使用Epsilon收集器，这是个实验参数，需要-XX：+UnlockExperimentalVMOptions解锁实验参数后，才能使用该参数 |

### 3.4. JVM线上故障排查？

#### 如何打印JVM日志？

- JDK 8垃圾收集日志打印参数：

打印GC明细、日期、系统相对时间戳、GC的原因、GC日志存储的位置。

```java
-Xms50m -Xmx50m -XX:+PrintGCDetails -XX:+PrintGCDateStamps -XX:+PrintGCTimeStamps -XX:+PrintGCCause -Xloggc:/Users/itmuch.com/gclog.log
```

- JDK 11垃圾收集日志打印参数：

打印GC详情、GC日志存储的位置，使用-Xlog进行统一日志管理。

```java
-Xms50m -Xmx50m -Xlog:gc*=trace:file=/Users/itmuch.com/xloggc.log
```

- JDK 8运行时日志打印参数：

跟踪类加载的情况，以及偏向锁相关的日志。

```java
-XX:+TraceClassLoading -XX:+TraceBiasedLocking
```

- JDK 11运行时日志打印参数：

跟踪类加载的情况，以及偏向锁相关的日志，使用-Xlog进行统一日志管理。

```java
-Xlog:class+load=debug,biasedlocking=debug:file=/Users/itmuch.com/trace.log

```

#### 如果分析GC日志？

- **自动分析GC日志工具**：

  - **GCEasy（在线）**：<https://www.gceasy.io/>。

  ![1626740104774](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1626740104774.png)

  - **GC Viewer（老牌）**：<https://github.com/chewiebug/GCViewer>。

  ![1626740032908](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1626740032908.png)

  - **GCPlot（很久没维护了）**：<https://github.com/GCPlot/gcplot>。

- **手工分析，格式如下**：

##### Serial GC日志

除CMS、G1 GC日志与Serial GC（Serial + Serial Old）日志不太一样外，其他的格式都是类似的。

###### JDK 8 Serial GC日志

```java
# Serial GC收集器日志分析: -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -XX:+UseSerialGC -Xmx50m -Xloggc:./gc_analysis.log

# JDK相关信息
Java HotSpot(TM) 64-Bit Server VM (25.91-b14) for windows-amd64 JRE (1.8.0_91-b14), built on Apr  1 2016 00:58:32 by "java_re" with MS VC++ 10.0 (VS2010)

# 内存相关信息
Memory: 4k page, physical 8266332k(2973848k free), swap 16532664k(9866032k free)

# 展示当前应用使用的JVM参数
CommandLine flags:
    -XX:-BytecodeVerificationLocal
    -XX:-BytecodeVerificationRemote
    -XX:InitialHeapSize=52428800
    -XX:+ManagementServer
    -XX:MaxHeapSize=52428800
    -XX:+PrintGC
    -XX:+PrintGCDateStamps
    -XX:+PrintGCDetails
    -XX:+PrintGCTimeStamps
    -XX:TieredStopAtLevel=1
    -XX:+UseCompressedClassPointers
    -XX:+UseCompressedOops
    -XX:-UseLargePagesIndividualAllocation
    -XX:+UseSerialGC

# 年轻代GC日志: 当前时间戳(PrintGCDateStamps):
    2021-04-15T20:36:08.848+0800:
# 相对时间戳(PrintGCTimeStamps):
    3.708:
# 造成GC的原因(PrintGCCause):...:
    [GC (Allocation Failure) 2021-04-15T20:36:08.849+0800: 3.709:
# 展示DefaultNew的回收前后的内存以及年轻代总内存大小(Serial DefNew)
    [DefNew: 13696K->1663K(15360K),
# GC (Allocation Failure) 到目前总共花费的时间
    0.0099516 secs]
# 展示回收前后整个堆内存以及堆内存总大小
    13696K->2410K(49536K),
# GC (Allocation Failure) 到目前总共花费的时间
    0.0111863 secs]
# 用户、系统、实际耗时
    [Times: user=0.00 sys=0.00, real=0.01 secs]

# FullGC日志: 当前时间戳(PrintGCDateStamps):
    2021-04-15T20:36:20.608+0800:
# 相对时间戳(PrintGCTimeStamps):
    15.466:
# 造成GC的原因(PrintGCCause):...:
    [Full GC (Metadata GC Threshold) 2021-04-15T20:36:20.608+0800: 15.466:
# 老年代回收之前和回收之后的内存大小以及老年代总内存大小
    [Tenured: 5749K->6890K(34176K),
# Full GC (Metadata GC Threshold) 到目前总共花费的时间
    0.0256217 secs]
# 展示回收前后整个堆内存以及堆内存总大小
    13665K->6890K(49536K),
# 元空间回收之前和回收之后的内存大小以及元空间总内存大小
    [Metaspace: 20533K->20533K(1067008K)],
# Full GC (Metadata GC Threshold) 到目前总共花费的时间
    0.0257088 secs]
# 用户、系统、实际耗时
    [Times: user=0.01 sys=0.00, real=0.02 secs]

```

###### JDK 11 Serial GC日志

```java
# JDK11 Serial GC收集器日志分析:

[0.104s][info][gc] Using Serial
# 内存概览: 堆内存地址、堆内存总大小、、压缩指针模式
[0.105s][info][gc,heap,coops] Heap address: 0x00000000fe200000, size: 30 MB, Compressed Oops mode: 32-bit
# 年轻代GC, 第1次回收为GC(0)
[1.846s][info][gc,start     ] GC(0) Pause Young (Allocation Failure)
# 年轻代回收前后的内存以及总内存大小
[1.862s][info][gc,heap      ] GC(0) DefNew: 8192K->1024K(9216K)
# 老年代回收前后的内存以及总内存大小
[1.862s][info][gc,heap      ] GC(0) Tenured: 0K->4482K(20480K)
# 元空间回收前后的内存以及总内存大小
[1.862s][info][gc,metaspace ] GC(0) Metaspace: 6131K->6131K(1056768K)
# 整个堆回收前后的内存以及总内存大小
[1.862s][info][gc           ] GC(0) Pause Young (Allocation Failure) 8M->5M(29M) 16.267ms
# 用户、系统、实际耗时
[1.862s][info][gc,cpu       ] GC(0) User=0.00s Sys=0.00s Real=0.02s
[4.813s][info][gc,start     ] GC(1) Pause Young (Allocation Failure)
[4.824s][info][gc,heap      ] GC(1) DefNew: 9216K->1024K(9216K)
[4.824s][info][gc,heap      ] GC(1) Tenured: 4482K->6236K(20480K)
[4.824s][info][gc,metaspace ] GC(1) Metaspace: 11473K->11473K(1060864K)
[4.824s][info][gc           ] GC(1) Pause Young (Allocation Failure) 13M->7M(29M) 11.722ms

```

##### CMS GC日志

使用ParNew + CMS的组合，Serial Old作为后备。

```java
# CMS GC收集器日志分析: -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -XX:+UseConcMarkSweepGC -Xmx50m -Xloggc:./GC_CMS.log
# 结论: => 日志格式大体上与GC_Serial.log一致, 但增加了一些CMS的步骤描述

Java HotSpot(TM) 64-Bit Server VM (25.91-b14) for windows-amd64 JRE (1.8.0_91-b14), built on Apr  1 2016 00:58:32 by "java_re" with MS VC++ 10.0 (VS2010)
Memory: 4k page, physical 8266332k(3336640k free), swap 16532664k(9654484k free)
CommandLine flags: -XX:-BytecodeVerificationLocal -XX:-BytecodeVerificationRemote -XX:InitialHeapSize=52428800 -XX:+ManagementServer -XX:MaxHeapSize=52428800 -XX:MaxNewSize=17477632 -XX:MaxTenuringThreshold=6 -XX:OldPLABSize=16 -XX:+PrintGC -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:TieredStopAtLevel=1 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseConcMarkSweepGC -XX:-UseLargePagesIndividualAllocation -XX:+UseParNewGC 
2021-04-15T21:04:10.842+0800: 2.650: [GC (Allocation Failure) 2021-04-15T21:04:10.842+0800: 2.650: [ParNew: 13696K->1664K(15360K), 0.0128738 secs] 13696K->2445K(49536K), 0.0131776 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]

# 1、初始标记
2021-04-15T21:04:22.827+0800: 14.635: [GC (CMS Initial Mark) [1 CMS-initial-mark: 7035K(34176K)] 8820K(49536K), 0.0007531 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
# 2、并发标记
2021-04-15T21:04:22.827+0800: 14.636: [CMS-concurrent-mark-start]
2021-04-15T21:04:22.847+0800: 14.655: [CMS-concurrent-mark: 0.019/0.019 secs] [Times: user=0.06 sys=0.03, real=0.02 secs]
# 3、并发预清理 -> (4、并发可中止清理)
2021-04-15T21:04:22.847+0800: 14.655: [CMS-concurrent-preclean-start]
2021-04-15T21:04:22.848+0800: 14.656: [CMS-concurrent-preclean: 0.001/0.001 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
# 5、重新标记
2021-04-15T21:04:22.848+0800: 14.656: [GC (CMS Final Remark) [YG occupancy: 2776 K (15360 K)]2021-04-15T21:04:22.848+0800: 14.656: [Rescan (parallel) , 0.0009519 secs]2021-04-15T21:04:22.849+0800: 14.657: [weak refs processing, 0.0000363 secs]2021-04-15T21:04:22.849+0800: 14.657: [class unloading, 0.0032038 secs]2021-04-15T21:04:22.853+0800: 14.660: [scrub symbol table, 0.0038571 secs]2021-04-15T21:04:22.856+0800: 14.664: [scrub string table, 0.0003238 secs][1 CMS-remark: 7035K(34176K)] 9811K(49536K), 0.0087240 secs] [Times: user=0.00 sys=0.00, real=0.01 secs]
# 6、并发清除
2021-04-15T21:04:22.857+0800: 14.665: [CMS-concurrent-sweep-start]
2021-04-15T21:04:22.860+0800: 14.668: [CMS-concurrent-sweep: 0.003/0.003 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
# 7、并发重置
2021-04-15T21:04:22.860+0800: 14.668: [CMS-concurrent-reset-start]
2021-04-15T21:04:22.860+0800: 14.668: [CMS-concurrent-reset: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]

# 1、初始标记
2021-04-15T21:04:27.076+0800: 18.884: [GC (CMS Initial Mark) [1 CMS-initial-mark: 21029K(34176K)] 22587K(49536K), 0.0011465 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
# 2、并发标记
2021-04-15T21:04:27.077+0800: 18.885: [CMS-concurrent-mark-start]
2021-04-15T21:04:27.113+0800: 18.921: [CMS-concurrent-mark: 0.036/0.036 secs] [Times: user=0.08 sys=0.01, real=0.04 secs]
# 3、并发预清理
2021-04-15T21:04:27.114+0800: 18.922: [CMS-concurrent-preclean-start]
2021-04-15T21:04:27.115+0800: 18.923: [CMS-concurrent-preclean: 0.001/0.001 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]
# 4、并发可中止清理
2021-04-15T21:04:27.115+0800: 18.923: [CMS-concurrent-abortable-preclean-start]
2021-04-15T21:04:27.282+0800: 19.090: [GC (Allocation Failure) 2021-04-15T21:04:27.282+0800: 19.090: [ParNew: 14979K->1443K(15360K), 0.0043541 secs] 36009K->22692K(49536K), 0.0044774 secs] [Times: user=0.06 sys=0.00, real=0.00 secs] 
2021-04-15T21:04:27.418+0800: 19.226: [CMS-concurrent-abortable-preclean: 0.050/0.303 secs] [Times: user=0.47 sys=0.00, real=0.30 secs]
# 5、重新标记
2021-04-15T21:04:27.418+0800: 19.226: [GC (CMS Final Remark) [YG occupancy: 8840 K (15360 K)]2021-04-15T21:04:27.418+0800: 19.226: [Rescan (parallel) , 0.0028890 secs]2021-04-15T21:04:27.421+0800: 19.229: [weak refs processing, 0.0000623 secs]2021-04-15T21:04:27.421+0800: 19.229: [class unloading, 0.0035473 secs]2021-04-15T21:04:27.425+0800: 19.233: [scrub symbol table, 0.0088034 secs]2021-04-15T21:04:27.434+0800: 19.242: [scrub string table, 0.0005316 secs][1 CMS-remark: 21248K(34176K)] 30088K(49536K), 0.0162688 secs] [Times: user=0.01 sys=0.00, real=0.02 secs]
# 6、并发清除
2021-04-15T21:04:27.435+0800: 19.243: [CMS-concurrent-sweep-start]
2021-04-15T21:04:27.447+0800: 19.255: [CMS-concurrent-sweep: 0.012/0.012 secs] [Times: user=0.03 sys=0.00, real=0.01 secs]
# 7、并发重置
2021-04-15T21:04:27.447+0800: 19.255: [CMS-concurrent-reset-start]
2021-04-15T21:04:27.447+0800: 19.255: [CMS-concurrent-reset: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]


```

##### G1 GC日志

与Serial GC、CMS GC格式差异非常大。

```java
# G1 GC收集器日志分析: -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -XX:+UseG1GC -Xmx50m -Xloggc:./GC_G1.log

Java HotSpot(TM) 64-Bit Server VM (25.91-b14) for windows-amd64 JRE (1.8.0_91-b14), built on Apr  1 2016 00:58:32 by "java_re" with MS VC++ 10.0 (VS2010)
Memory: 4k page, physical 8266332k(3458332k free), swap 16532664k(9495268k free)
CommandLine flags: -XX:-BytecodeVerificationLocal -XX:-BytecodeVerificationRemote -XX:InitialHeapSize=52428800 -XX:+ManagementServer -XX:MaxHeapSize=52428800 -XX:+PrintGC -XX:+PrintGCDateStamps -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:TieredStopAtLevel=1 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseG1GC -XX:-UseLargePagesIndividualAllocation

# 年轻代G1 GC: 下面的缩进表示日志的子任务
2021-04-15T21:12:09.426+0800: 2.494: [GC pause (G1 Evacuation Pause) (young), 0.0052693 secs]
   # 并发任务解释
   [Parallel Time: 4.1 ms, GC Workers: 4]
      # GC统计
      [GC Worker Start (ms): Min: 2493.6, Avg: 2493.6, Max: 2493.6, Diff: 0.0]
      # GC扫描对象统计
      [Ext Root Scanning (ms): Min: 0.0, Avg: 0.7, Max: 1.1, Diff: 1.1, Sum: 2.7]
      # Update Remembered Sets(指保存到堆中的区域跟踪引用 -> 保存到Update Buffers更新缓存中)
      [Update RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]
      # Update Buffers数量统计
         [Processed Buffers: Min: 0, Avg: 0.0, Max: 0, Diff: 0, Sum: 0]
      # Remembered Sets扫描统计
      [Scan RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]
      # Code Root扫描统计
      [Code Root Scanning (ms): Min: 0.0, Avg: 0.1, Max: 0.2, Diff: 0.2, Sum: 0.3]
      # 拷贝存活对象统计
      [Object Copy (ms): Min: 0.0, Avg: 2.2, Max: 3.1, Diff: 3.1, Sum: 8.6]
      # 中断统计
      [Termination (ms): Min: 0.0, Avg: 0.2, Max: 0.2, Diff: 0.2, Sum: 0.6]
         # 尝试中断统计
         [Termination Attempts: Min: 1, Avg: 1.3, Max: 2, Diff: 1, Sum: 5]
      # GC线程其他工作统计
      [GC Worker Other (ms): Min: 0.0, Avg: 1.0, Max: 4.0, Diff: 3.9, Sum: 4.1]
      # GC线程总工作统计
      [GC Worker Total (ms): Min: 4.0, Avg: 4.1, Max: 4.1, Diff: 0.1, Sum: 16.3]
      # GC线程结束时间
      [GC Worker End (ms): Min: 2497.6, Avg: 2497.7, Max: 2497.7, Diff: 0.1]
   # 串行任务, 修复Code Root耗时统计
   [Code Root Fixup: 0.1 ms]
   # 串行任务, 清除Code Root耗时统计
   [Code Root Purge: 0.0 ms]
   # 清除Card Table中的Dirty Card耗时统计
   [Clear CT: 0.0 ms]
   # 其他任务
   [Other: 1.0 ms]
      # Collection Set选择区域耗时统计
      [Choose CSet: 0.0 ms]
      # 对象引用处理耗时统计
      [Ref Proc: 0.8 ms]
      # 引用队列ReferenceQueue耗时统计
      [Ref Enq: 0.0 ms]
      [Redirty Cards: 0.0 ms]
      # 处理超大对象耗时统计
      [Humongous Register: 0.0 ms]
      [Humongous Reclaim: 0.0 ms]
      # 释放Collection Set耗时统计
      [Free CSet: 0.0 ms]
      # 各区域内存变化统计
   [Eden: 14.0M(14.0M)->0.0B(18.0M) Survivors: 0.0B->2048.0K Heap: 14.0M(50.0M)->2555.5K(50.0M)]
 # 用户、系统、实际耗时
 [Times: user=0.00 sys=0.00, real=0.01 secs]

# 最重要, 体现了G1 GC的过程
# 并发回收日志: 1、初始标记(stop the world)
2021-04-15T21:12:11.327+0800: 4.394: [GC pause (Metadata GC Threshold) (young) (initial-mark), 0.0047654 secs]
   [Parallel Time: 4.3 ms, GC Workers: 4]
      [GC Worker Start (ms): Min: 4394.3, Avg: 4394.3, Max: 4394.3, Diff: 0.0]
      [Ext Root Scanning (ms): Min: 0.9, Avg: 1.0, Max: 1.1, Diff: 0.2, Sum: 4.1]
      [Update RS (ms): Min: 0.6, Avg: 0.7, Max: 0.8, Diff: 0.2, Sum: 2.7]
         [Processed Buffers: Min: 2, Avg: 3.8, Max: 7, Diff: 5, Sum: 15]
      [Scan RS (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]
      [Code Root Scanning (ms): Min: 0.0, Avg: 0.0, Max: 0.1, Diff: 0.1, Sum: 0.1]
      [Object Copy (ms): Min: 2.4, Avg: 2.5, Max: 2.5, Diff: 0.1, Sum: 9.9]
      [Termination (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]
         [Termination Attempts: Min: 1, Avg: 1.0, Max: 1, Diff: 0, Sum: 4]
      [GC Worker Other (ms): Min: 0.0, Avg: 0.0, Max: 0.0, Diff: 0.0, Sum: 0.0]
      [GC Worker Total (ms): Min: 4.2, Avg: 4.2, Max: 4.2, Diff: 0.0, Sum: 16.8]
      [GC Worker End (ms): Min: 4398.5, Avg: 4398.5, Max: 4398.5, Diff: 0.0]
   [Code Root Fixup: 0.0 ms]
   [Code Root Purge: 0.0 ms]
   [Clear CT: 0.1 ms]
   [Other: 0.4 ms]
      [Choose CSet: 0.0 ms]
      [Ref Proc: 0.2 ms]
      [Ref Enq: 0.0 ms]
      [Redirty Cards: 0.1 ms]
      [Humongous Register: 0.0 ms]
      [Humongous Reclaim: 0.0 ms]
      [Free CSet: 0.0 ms]
   [Eden: 5120.0K(26.0M)->0.0B(26.0M) Survivors: 4096.0K->4096.0K Heap: 14.9M(50.0M)->11.3M(50.0M)]
 [Times: user=0.06 sys=0.00, real=0.01 secs]
# 开始扫描初始标记阶段Survivor区的Root Region
2021-04-15T21:12:11.332+0800: 4.399: [GC concurrent-root-region-scan-start]
2021-04-15T21:12:11.338+0800: 4.405: [GC concurrent-root-region-scan-end, 0.0055232 secs]
# 2、并发标记
2021-04-15T21:12:11.338+0800: 4.405: [GC concurrent-mark-start]
2021-04-15T21:12:11.352+0800: 4.419: [GC concurrent-mark-end, 0.0143048 secs]
# 3、最终标记(stop the world)
2021-04-15T21:12:11.355+0800: 4.422: [GC remark 2021-04-15T21:12:11.355+0800: 4.422: [Finalize Marking, 0.0001519 secs] 2021-04-15T21:12:11.355+0800: 4.422: [GC ref-proc, 0.0006391 secs] 2021-04-15T21:12:11.356+0800: 4.423: [Unloading, 0.0037653 secs], 0.0048311 secs]
 [Times: user=0.00 sys=0.00, real=0.00 secs]
# 4、筛选回收(stop the world)
2021-04-15T21:12:11.360+0800: 4.427: [GC cleanup 12M->12M(50M), 0.0005645 secs]
 [Times: user=0.00 sys=0.02, real=0.00 secs] 
```

#### 如何定位CPU过高的地方？

- **定位问题代码的方法**：
  - 可以使用JMC MBean服务器实时查看：但需要应用开启JMX连接。
  - **也可以使用top + jstack配合查看**：

1. top查看当前CPU占用率最高的进程，拿到占用率最高的进程号36032：

   ```java
   top
   ```

2. top -Hp查看该进程线程的运行信息，拿到占用率最高的线程号36044：

   ```java
   top -Hp 36032
   ```

3. printf得到该线程号36044的16进制数8ccc，用于搜索dump文件：

   ```java
   printf %x 36044
   ```

4. jstack dump出进程36032所有的线程栈，得到文件1.txt：

   ```java
   jstack -l 36032 > 1.txt
   ```

5. cat搜索线程栈文件1.txt，找到16进制为8ccc（即线程号为36044），并往后再搜索30行的内容：

   ```java
   cat 1.txt | grep -A 30 8ccc
   ```

6. 定位该线程中的出问题代码，并分析原因：原来是有个for循环，导致CPU过高。

```java
@Override
public void run() {
    while (true) {
        double a = Math.random() * Math.random();
        System.out.println(a);
    }
}
```

- **CPU过高的场景与解决方案**？
  - **无限while循环**：
    - 尽量避免无限循环。
    - 也可以让循环执行得慢点，比如sleep（）或者yeild（）。
  - **频繁GC**：
    - 尽量降低GC频率。
  - **频繁创建新的对象**：
    - 合理使用单例，避免频繁创建对象。
  - **频繁的线程上下文切换**：
    - 降低切换的频率，不过需要结合业务进行业务改造，而改造的难度取决于业务的复杂度。
  - 序列化和反序列化：
    - 原因：大多都是由于使用了不合理的类库导致的，比如XStream反序列化大对象，改用ObjectInputStream来解决问题。
    - 解决方案：使用合理的API来实现，选择好用的序列化与反序列化的类库。
  - 正则表达式：
    - 原因：由于正则表达式使用NFA自动机的引擎，在进行字符串匹配时会发生回溯，一旦发生回溯可能会导致CPU过高的问题。
    - 解决方案：改写正则表达式，降低回溯的发生。

#### 如何解决内存溢出问题？

##### 堆内存溢出

- **相关概念**：**堆**：Java Heap，线程共享，在JVM启动时创建，是Java虚拟机中内存最大的一块，**专门用来保存对象，几乎所有对象以及数组的内存都在堆上分配**。
- **定位问题代码的方法**：

1. 指定OOM溢出后转储堆Dump：

   真实环境下，堆内存溢出很可能会导致进程直接挂掉，根本不会打印堆栈日志，所以需要JVM发生异常时自动转储出堆Dump文件，以便出现问题后能够进行分析。

   ```java
   --XX:+HeapDumpOnOutOfMemoryError
   
   
   ```

2. 在项目根目录，找到堆Dump文件，使用MAT打开堆Dump文件：

   ![1626605721295](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1626605721295.png)

3. 点击Leak Suspects，分析内存泄露：

   ![1626605971298](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1626605971298.png)

4. 查看问题对象Object[]的details，分析with incoming references，即问题对象被引用的情况：

   此外，如果Leak Suspects有堆栈信息，也可以从堆栈信息中分析问题所在。

   ![1626606234660](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1626606234660.png)

5. 原来是因为无限循环插入了一堆随机String对象：

   ```java
   public class HeapOOMTest {
       private List<String> oomList = new ArrayList<>();
   
       public static void main(String[] args) {
           HeapOOMTest oomTest = new HeapOOMTest();
           while (true) {
               oomTest.oomList.add(UUID.randomUUID().toString());
           }
       }
   }
   
   ```

- **堆内存溢出的场景**？
  - **内存泄露**：
    - 可以借助MAT或者VisualVM，去查看泄露对象到对象的引用链，分析这个泄露的对象是通过哪个路径跟哪个对象关联，从而导致没有被回收掉。最后找到内存泄露对象的创建位置，优化相关的代码。
  - **存在生命周期或者数据结构不合理的对象**：
    - 更换不合理对象的生命周期或者数据结构。
  - **机器的堆内存大小设置得过小**：
    - 根据实际情况适当增大-Xms、-Xmn的值。

##### 栈内存溢出

- **相关概念**：在Hotspot虚拟机中，**栈内存是不允许扩展的**，且不区分虚拟机栈和本地方法栈，统一使用-Xss设置栈的大小，但同样会抛StackOverflowError异常，以及OutOfMemoryError异常。在有些VM中是有区分开的，比如使用-Xss设置虚拟机栈大小，-Xoss设置本地方法栈大小。
- **定位的方法**：栈溢出后，抛出的错误会导致进程的挂掉，还是可以在日志中打印出堆栈日志，这时分析日志文件即可定位到问题代码了。
- **栈内存溢出的场景**？
  - **递归调用深度过大**：
    - 原因：每递归调用一次，就会创建一个栈帧压入栈中，在栈容量有限的情况下，当容纳不了足够多的栈帧时，则会抛出StackOverflowError异常。
    - 解决方法：优化问题代码。
  - **方法内创建过多的局部变量**：
    - 原因：局部变量存放在局部变量表中，当栈中容纳不了这么多变量时也会抛出StackOverflowError异常。
    - 解决方法：优化问题代码。
  - **创建了过多的线程**：
    - 原因：栈是线程独享的，每个线程会创建自己的栈，当创建新线程的时候没有足够的内存去创建对应的栈，则会抛出**OutOfMemoryError**异常。
    - 解决方法：优化问题代码。
- **如何保证创建足够多的线程**？
  - **减少-Xss配置**：由于栈是线程独享的，每个线程会创建自己的栈，对于相同的内存总量，减少每个栈的大小，就可以创建更多的栈，在OOM之前就可以创建更多的线程了。
  - **增大栈能分配的内存**：尽量减少除了栈以外的内存占用，增大栈内存占用。其中公式为：
    - 栈内存 = 机器总内存 - 操作系统内存 - 堆内存 - 方法区内存 - 程序计数器内存 - 直接内存。 
  - **尽量杀死其他应用程序**：这样可以为目标应用腾出更多的内存。
  - **增大操作系统对线程数量的限制**：
    - sysctl -w kernel.threads-max：增大Linux系统支持的最大线程数（表示物理内存决定的理论系统进程数上限，一般会很大）。
    - sysctl -w kernel.pid_max：增大Linux系统限制某用户下最多可以运行多少进程或线程数。
    - sysctl -w vm.max_map_count：增大限制一个进程可以拥有的VMA(虚拟内存区域)的数量。
      - 虚拟内存区域是一个连续的虚拟地址空间区域。在进程的生命周期中，每当程序尝试在内存中映射文件，链接到共享内存段，或者分配堆空间的时候，这些区域将被创建。
    - ulimit -u：增大用户最多可启动的进程数目。

##### 方法区溢出

- **相关概念**：

  - Methed Area，别命Non-Heap（非堆），线程共享，是JVM规范中定义的一个逻辑概念，用于存储已被虚拟机加载的**类信息、常量、静态变量和即时编译后的代码**等数据，具体放在哪里，不同的实现可能会放在不同的地方。
  - 在JDK8以后，元空间替代了永久代，使得方法区与堆存在交集，静态变量和字符串常量池存放在堆中，类信息和运行时常量池放在元空间中，而静态常量池是class文件里的常量池，未加载前并不占用内存。

- **定位的方法**：方法区溢出后，抛出的错误会导致进程的挂掉，还是可以在日志中打印出堆栈日志，这时分析日志文件即可定位到问题代码了。

- **方法区内存溢出分类**：

  不同的JDK版本，方法区存放的结构不同，所以相同的代码导致的内存溢出抛出的异常信息也可能不同。

  - **永久代溢出 & 堆内存溢出**：
    - 对于小于JDK 7的版本，采用的是**永久代**存储符号引用、字符串以及类的静态变量，所以小于JDK 7的版本，在遇到字符串过多的情况下，是否溢出取决于**永久代**的大小。
    - 由于JDK 7把符号引用（native heap）、字符串常量池以及类的静态变量移动到了**堆**中，所以大于等于JDK 7的版本，在遇到字符串过多的情况下，是否溢出取决于**堆的大小**。
  - **永久代溢出 & 元空间溢出**：
    - 对于小于JDK 8的版本，采用的是**永久代**存储类信息，所以小于JDK 8的版本，在遇到类加载过多的情况下，是否溢出取决于**永久代**的大小。
    - 由于JDK 8中使用了**元空间**替代永久代，采用运行时常量池存储已加载的类的元数据信息，所以大于等于JDK 8的版本，在遇到类加载过多的情况下，是否溢出取决于**元空间**的大小，而元空间是放在**本地内存**上的，只要**机器内存**足够大，理论上是很难发生溢出的。

- **方法区内存溢出的场景**？

  - **常量池对象太大**：
    - **原因**：比如字符串过多。
    - **解决方案**：根据JDK版本，为（字符串）常量池预留足够的空间。
      - < JDK 7：增大PermSize、MaxPermSize。
      - 》= JDK7：增大-Xms、-Xmx。
  - **加载的类过多**：
    - **原因**：
      - **动态代理的操作库生成了大量的动态类**：比如CXF、XSource、CGLIB等动态代理的框架，因为增强的类越多，就需要更多的空间来存储类的定义信息。
      - **JSP过多**：因为JSP是在第一次被访问的时候，才会被编译成Java类，在极端场景下，访问过多的JSP页面，可能会打满方法区导致内存溢出。
      - 脚本语言动态类加载：比如Grovy脚本出现的动态类加载导致的元空间溢出的问题。
    - **解决方案**：
      - < JDK 8：增大PermSize、MaxPermSize。
      - 》= JDK 8：可以留空元空间相关的配置（本地内存实现，不配置时JVM会动态去分配），或者设置合理的元空间大小。

##### 直接内存溢出

- **相关概念**：
  - **直接内存**：DirectBuffer，是一块由操作系统直接管理的内存，也叫**堆外内存**，并不是JVM运行时数据区的一部分，也不是JVM规范中定义的内存区域，但这部分内存会被频繁使用，而且也可能会导致OOM错误的出现。
- **定位的方法**：直接溢出后，抛出的错误会导致进程的挂掉，还是可以在日志中打印出堆栈日志，这时分析日志文件即可定位到问题代码了。
  - java.lang.OutOfMemoryError：Unsafe导致直接内存溢出报错没有小尾巴。
  - java.lang.OutOfMemoryError: Direct buffer memory：ByteBuffer直接内存溢出报错是有小尾巴的。
  - **（经验之谈）如果堆Dump文件看不出问题或者太小，可考虑是直接内存溢出的问题**。
- **直接内存溢出的场景**？
  - **内存泄露多导致的内存溢出**：
    - **原因**：分配对象到直接内存后，不使用时不释放内存，然后继续分配对象，时间久了就会出现溢出问题。
    - **解决方案**：设置最大直接内存大小-XX：MaxDirectMemorySize，**对Unsafe不起作用**，但对ByteBuffer有效（会先设置long maxMemory = VM.maxDirectMemory（））。

##### 代码缓存区溢出

- **概念**：CodeCache，代码缓存区，是非堆区域，缓存的是JIT编译器编译后的代码（即机器码），以及部分JNI的机器码，不过JIT编译生成的机器码占主要部分。
  - 解释执行可以节省内存，不存放到CodeCache，立即执行。
  - 编译执行后的代码会存放在CodeCache里，虽然CodeCache在即将耗尽时会尝试回收，但满了后却会让JIT停止工作，此后已编译过的代码会继续以编译模式执行，还没有编译过的代码将会退化成以解释执行模式执行，从而出现系统运行变慢、响应时间增大的现象。
- **定位的方法**：
  - 使用jconsole连接进程观察CodeCache。
  - 日志打印出VM warning：CodeCache is full. Compiler has been disabled信息。
  - 项目平常性能OK，但突然出现性能下降，业务又没有问题时，可排查是否由代码缓存区溢出所导致。
- **代码缓存区溢出的场景**：
  - **单体项目过于庞大但CodeCache又设置得过小**。
    - **解决方案**：
      - 可以对照jconsole设置合理的-XX：ReservedCodeCacheSize（代码缓存区的最大大小）。
      - 而对于微服务等代码量不多的小应用来说，240MB默认的CodeCache一般都是够用的了。

#### 项目越跑越慢如何定位与解决？

可能的场景有：

- **Stop The World时间过长、GC频繁**：

  - **定位方法**：检查GC日志。
  - 解决方案？：增加-XX：ParallelGCThreads并行收集的线程数、根据实际情况更换垃圾收集器。

- **项目依赖的资源导致变慢**：

  - **定位方法**：检查数据库、网络等资源是否被其他程序占用了很多。
  - 解决方案？：释放调用问题的资源。

- **CodeCache满了**：会导致JIT从编译执行退化成了解释执行。

  - **定位方法**：使用jconsole检查CodeCache大小。

- **线程争抢过于激烈**：会导致目标线程抢不到CPU片。

  - **定位方法**：使用VisualVM检查目标进程中的线程运行情况、分析ThreadDump（比如可以使用FastThread、PerfMa进行可视化分析）。
    - 结果发现：在循环中创建了一堆线程池，且使用完了又没关闭掉，导致线程池争抢激烈，消耗CPU资源严重。
    - 解决方案：使用完线程池后，在finally代码块把线程池关闭掉；同时根据业务规则命名线程（new ThreadFactoryBuilder().setNameFormat("my-thread-pool-%d")），方便以后定位问题。

- 服务器问题（了解就好）：操作系统问题、其他进程争抢资源。

  如果一个实例发生了问题，根据情况选择，要不要着急去重启。如果出现的CPU、内存飙高或者日志里出现了OOM异常**第一步是隔离**，第二步是**保留现场**，第三步才是**问题排查**。

  - **隔离**：就是把你机器从请求列表里摘除，比如把nginx相关的权重设成零。

  - **保留现场**：

    1. **系统当前网络连接**：使用 ss 命令而不是netstat的原因是：netstat 在网络连接非常多的情况下，执行非常缓慢。后续的处理，可通过查看各种网络连接状态的梳理，排查 TIME_WAIT或者CLOSE_WAIT，或者其他连接过高的问题，非常有用。

       ```shell
       ss -antp > $DUMP_DIR/ss.dump 2>&1
       ```

    2. **网络状态统计**：

       ```shell
       # 它能够按照各个协议进行统计输出，对把握当时整个网络状态，有非常大的作用。
       netstat -s > $DUMP_DIR/netstat-s.dump 2>&1
       
       # 在一些速度非常高的模块上，比如 Redis、Kafka，就经常发生跑满网卡的情况。表现形式就是网络通信非常缓慢。
       sar -n DEV 1 2 > $DUMP_DIR/sar-traffic.dump 2>&1
       ```

    3. **进程资源**：通过查看进程，能看到打开了哪些文件，可以以进程的维度来查看整个资源的使用情况，包括每条网络连接、每个打开的文件句柄。同时，也可以很容易的看到连接到了哪些服务器、使用了哪些资源。这个命令在资源非常多的情况下，输出稍慢，请耐心等待。

       ```shell
       lsof -p $PID > $DUMP_DIR/lsof-$PID.dump
       ```

    4. **CPU 资源**：主要用于输出当前系统的 CPU 和负载，便于事后排查。

       ```shell
       mpstat > $DUMP_DIR/mpstat.dump 2>&1
       vmstat 1 3 > $DUMP_DIR/vmstat.dump 2>&1
       sar -p ALL  > $DUMP_DIR/sar-cpu.dump  2>&1
       uptime > $DUMP_DIR/uptime.dump 2>&1
       ```

    5. **I/O 资源**：一般，以计算为主的服务节点，I/O 资源会比较正常，但有时也会发生问题，比如**日志输出过多，或者磁盘问题**等。此命令可以输出每块磁盘的基本性能信息，用来排查 I/O 问题。在第 8 课时介绍的 GC 日志分磁盘问题，就可以使用这个命令去发现。

       ```shell
       iostat -x > $DUMP_DIR/iostat.dump 2>&1
       ```

    6. **内存问题**：free 命令能够大体展现操作系统的内存概况，这是故障排查中一个非常重要的点，比如 SWAP 影响了 GC，SLAB 区挤占了 JVM 的内存。

       ```shell
       free -h > $DUMP_DIR/free.dump 2>&1
       ```

    7. **其他全局**：dmesg 是许多静悄悄死掉的服务留下的最后一点线索。当然，ps 作为执行频率最高的一个命令，由于内核的配置参数，会对系统和 JVM 产生影响，所以我们也输出了一份。

       ```shell
       ps -ef > $DUMP_DIR/ps.dump 2>&1
       dmesg > $DUMP_DIR/dmesg.dump 2>&1
       sysctl -a > $DUMP_DIR/sysctl.dump 2>&1
       ```

    8. **进程快照**：此命令将输出 Java 的基本进程信息，包括**环境变量和参数配置**，可以查看是否因为一些错误的配置造成了 JVM 问题。

       ```shell
       ${JDK_BIN}jinfo $PID > $DUMP_DIR/jinfo.dump 2>&1
       ```

    9. **dump堆信息**：jstat 将输出当前的 gc 信息。一般，基本能大体看出一个端倪，如果不能，可将借助 jmap 来进行分析。

       ```shell
       ${JDK_BIN}jstat -gcutil $PID > $DUMP_DIR/jstat-gcutil.dump 2>&1
       ${JDK_BIN}jstat -gccapacity $PID > $DUMP_DIR/jstat-gccapacity.dump 2>&1
       ```

    10. **堆信息**：jmap 将会得到当前 Java 进程的 dump 信息。如上所示，其实最有用的就是第 4 个命令，但是前面三个能够让你初步对系统概况进行大体判断。因为，第 4 个命令产生的文件，一般都非常的大。而且，需要下载下来，导入 MAT 这样的工具进行深入分析，才能获取结果。这是分析内存泄漏一个必经的过程。

        ```shell
        ${JDK_BIN}jmap $PID > $DUMP_DIR/jmap.dump 2>&1
        ${JDK_BIN}jmap -heap $PID > $DUMP_DIR/jmap-heap.dump 2>&1
        ${JDK_BIN}jmap -histo $PID > $DUMP_DIR/jmap-histo.dump 2>&1
        ${JDK_BIN}jmap -dump:format=b,file=$DUMP_DIR/heap.bin $PID > /dev/null  2>&1
        ```

    11. **JVM 执行栈**：

        ```shell
        # jstack 将会获取当时的执行栈。一般会多次取值，我们这里取一次即可。这些信息非常有用，能够还原 Java 进程中的线程情况。
        ${JDK_BIN}jstack $PID > $DUMP_DIR/jstack.dump 2>&1
        
        # 为了能够得到更加精细的信息，我们使用 top 命令，来获取进程中所有线程的 CPU 信息，这样，就可以看到资源到底耗费在什么地方了。
        top -Hp $PID -b -n 1 -c >  $DUMP_DIR/top-$PID.dump 2>&1
        ```

    12. **高级替补**：

        ```shell
        # 有时候，jstack 并不能够运行，有很多原因，比如 Java 进程几乎不响应了等之类的情况。我们会尝试向进程发送 kill -3 信号，这个信号将会打印 jstack 的 trace 信息到日志文件中，是 jstack 的一个替补方案。
        kill -3 $PID
        
        # 对于 jmap 无法执行的问题，也有替补，那就是 GDB 组件中的 gcore，将会生成一个 core 文件。我们可以使用如下的命令去生成 dump：
        gcore -o $DUMP_DIR/core $PID
        ${JDK_BIN}jhsdb jmap --exe ${JDK}java  --core $DUMP_DIR/core --binaryheap
        ```

    13. **内存泄漏的现象**：稍微提一下 jmap 命令，它在 9 版本里被干掉了，取而代之的是 jhsdb，你可以像下面的命令一样使用。一般内存溢出，表现形式就是 Old 区的占用持续上升，即使经过了多轮 GC 也没有明显改善。比如ThreadLocal里面的GC Roots，内存泄漏的根本就是，这些对象并没有切断和 GC Roots 的关系，可通过一些工具，能够看到它们的联系。

        ```shell
        jhsdb jmap  --heap --pid  37340
        jhsdb jmap  --pid  37288
        jhsdb jmap  --histo --pid  37340
        jhsdb jmap  --binaryheap --pid  37340
        ```

