### 十三、背背佳

#### 1.1. TCP 和 UDP 的差别？

- **TCP**，传输控制协议，是一种**面向连接的、面向字节流的、可靠的全双工传输层通信协议**，由于其首部最大长度能够达到 60 字节，所以传输效率较 UDP 的低，常用的通信协议有 HTTP、TELNET、SMTP 和 FTP 等。
- **UDP**，用户数据报协议，是一种**无连接的、面向数据报的、不可靠的传输层协议**，为应用程序提供了一种无需建立连接，就可以发送封装好了的 IP 数据包 的方法，由于其首部最大长度只有 8 个字节，所以传输效率较 TCP 的高，常用的通信协议有 DNS、RIP、DHCP 等。

#### 1.2. TCP 是如何保证可靠性传输的？

1. **确认应答和超时重传机制**：发送方发完数据后，需要等待接收方的确认应答，如果没有在规定时间内，得到该应答，那么就会重传对应报文段。

2. **检验和**：

   1. 发送方发送前，会先进行 TCP伪首部 + TCP 首部 + TCP 数据部分的二进制反码求和运算，取反后再设置到首部中的检验和字段。
   2. 接收方收到后，也会进行 TCP 伪首部 + TCP 首部 + TCP 数据部分的二进制反码求和运算，由于此时首部中的检验和字段不为空，如果求出的结果不全为 1，那么说明报文段出现了问题，则直接将其丢弃，让发送方重新发送该报文段。

3. **滑动窗口**：

   1. 发送方的发送窗口后沿，代表已发送且已被确认的数据，此时发送窗口前移，而发送窗口内的数据代表已发送且未被确认的数据，此时发送窗口保持不变。
   2. 接口方的接收窗口后沿，代表已接收的数据，此时接收窗口前移，而接收窗口内的数据代表未接收的数据，此时接收窗口保持不变。

4. **流量控制**：发送方的发送窗口不能大于接收方返回的最大接收窗口值。

5. **拥塞控制**：

   ![1645235241181](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1645235241181.png)

   1. 分为慢开始、拥塞避免、快重传和快恢复，其具体原理为，发送方有一个慢开始门限和一个拥塞窗口参数：
   2. 如果慢开始门限小于拥塞窗口，则使用慢开始算法，此时拥塞窗口大小呈指数式增长。
   3. 如果拥塞窗口大小增长达到了慢开始门限，则使用拥塞避免算法，此时拥塞窗口大小呈线性增长。
   4. 如果遇到网络超时，则设置慢开始门限为原来的 1/2，并且设置拥塞窗口大小为 1，重新执行慢开始算法。
   5. 如果没有遇到网络超时，但连续收到接收方的同一个报文段的 3 个未确认的 ACK，则认为该报文确实发生了丢失，则进行重传，并设置慢开始门限为原来的 1/2，并且设置拥塞窗口大小等于慢开始门限，重新执行拥塞避免算法。

#### 1.3. 什么是 TCP 三次握手？

![1645244135614](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1645244135614.png)

1. 服务端创建 TCP 进程控制块，进入 LISTEN 监听状态，等待客户端连接。
2. 客户端创建 TCP 进程控制块，准备发起 TCP 连接。
3. 第一次握手，客户端发起 SYN=1，SYN 同步号=x 的连接请求报文段给服务端，随后进入 SYN-SENT 同步发送状态。
4. 第二次握手，服务端收到客户端的连接请求报文段后，响应 ACK=1，ACK 确认号= x+1，同时携带服务端的连接请求报文段 SYN=1，SYN 同步号=y 的确认报文段给客户端，随后进入 SYN-RECV 同步接收状态。
5. 第三次握手，客户端收到服务端的确认报文段后，响应 ACK=1，ACK  确认号= y+1 的确认报文段给服务端，随后进入 ESTABLISHED 连接已完成状态，此时客户端到服务端方向的 TCP 连接已建立。
6. 服务端收到客户端的确认报文段后，也进入 ESTABLISHED 连接已完成状态，此时服务端到客户端方向的 TCP 连接也已建立，也就是一个全双工的 TCP 通信通道已完成建立。

#### 1.4. 为什么 TCP 需要三次握手？

1. 这是因为如果使用 TCP 两次握手，那么只能保证客户端到服务端方向的连接完成建立，而服务端方向到客户端方向的连接没能未完成建立。
2. 而如果使用 TCP 三次握手，那么就能保证一个全双工的 TCP 通信通道完成建立，使得发收双发同时具备发送和接收数据的能力。
3. 同时，对于已失效的报文段突然又传回给服务端的情况，即第一次握手是无效的，服务端返回的第二次握手也是无效的，客户端在收到这种无效的第二次握手后，就不会再发起第三次握手了，也就避免了多余连接的建立， 避免了资源的浪费。

#### 1.5. 什么是 TCP 四次挥手？

![1645244152507](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1645244152507.png)

1. 客户端停止发送数据，准比关闭 TCP 连接。
2. 第一次挥手，客户端发起 FIN=1，FIN 终止号=u 的连接释放报文段给服务端，随后进入 FIN-WAIT1 终止等待1状态。
3. 第二次挥手，服务端收到客户端的连接释放请求后，则通知上层应用程序做好连接释放的准备，然后响应客户端 ACK=1，ACK 确认号=u+1，序列号=v 的确认报文段，随后进入 CLOSE-WAIT 关闭等待状态，而客户端在收到服务端的确认报文段后，会进入 FIN-WAIT2 终止等待2 状态，此时，客户端到服务端方向的 TCP 连接已经被释放。
4. 第三次挥手，由于服务端上层应用程序准备释放需要一定的时间开销，所以服务端还需要发起一个 ACK=1，ACK 确认号=u+1，FIN=1，FIN 终止号=w 的连接释放报文段给客户端，随后进入 LAST-ACK 最终确认状态。
5. 第四次挥手，客户端收到服务端的连接释放报文段后，则响应 ACK=1，ACK 确认号=w+1，序列号=u+1 的确认报文段给服务端，随后进入 TIME-WAIT 时间等待状态，服务端收到客户端的确认报文段后，则进入 CLOSE 关闭状态，但此时服务端到客户端方向的 TCP 连接仍未被释放，因为客户端还需要再等待 2 倍的 MSL 最大报文段寿命后，才能进入 CLOSE 状态，最终关闭该方向的 TCP 连接，完成一次 TCP 连接的释放过程。

#### 1.6. 为什么 TCP 需要四次挥手？

这是因为，前两次的挥手用于保证释放客户端到服务端方向的 TCP 连接，而后两次的挥手，用于保证释放服务端的客户端方向的 TCP 连接，所以需要四次挥手。

#### 1.7. 为什么最后客户端还需要等待 2 倍的 MSL？

1. 这是为了保证客户端能够接收到服务端 ACK+FIN 的连接释放请求报文，以及服务端能够收到客户端的确认报文，保证了服务端到客户端方向的 TCP 连接能够完成关闭。
2. 同时，对于已失效的报文段又重新回到了服务端的情况，即第一次握手是无效的，服务端返回的第二次握手也是无效的，客户单在收到这种无效的第二次握手时，就不会再发起第三次握手了，也就避免了多余连接的建立，避免了资源的浪费。

