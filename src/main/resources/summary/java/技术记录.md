# 十二、个人笔记

### 1.1. 简历准备

#### 1）共同特点提取

- 个人信息：姓名、年龄、工作年限、联系电话、邮箱地址（姓名+出生年+163）。
- 教育背景：大学（带上省211）、就读年份、专业、学士（全日制）

- 个人技能：
  - 分类：总结项、精通项、熟练项、掌握项。
  - 维度：框架、中间件、原理、语言、数据库、缓存、消息队列。
- 工作经历：公司、公司介绍、岗位、年份、工作描述（突出项目亮点，直指某个项目）。
  - 附加项：A 绩效、S 绩效、优秀新员工奖、应届生分享、技术指导新人。
- 项目经历：项目名、时间（倒叙）、团队规模、角色、技术栈、项目介绍（技术向）、负责内容（概括）、项目亮点、压测指标（前后对比）、项目奖/总结

#### 2）简历信息收集

- 个人信息：

  | 姓名     | 姚超松                |
  | -------- | --------------------- |
  | 年龄     | 25                    |
  | 工作年限 | 3                     |
  | 联系电话 | 18320608847           |
  | 邮箱地址 | yaochaosong96@163.com |

- 教育背景：

  | 大学     | 广东工业大学（省 211） |
  | -------- | ---------------------- |
  | 就读年份 | 2015.09~2019.06        |
  | 专业     | 电子信息工程           |
  | 统招本科 | 全日制                 |

- 个人技能：

  1. 优势：多年 Java 后端开发经验，具备分布式、高并发等开发能力，有全栈开发经验。
  2. 语言：深入理解并阅读过 Java 集合、AQS 框架源码，包括 List、Map、Set、Queue、Lock、FutureTask、Executor 等接口实现，熟悉 Vue、JQuery。
  3. JVM：深入理解 HotSpot 虚拟机，包括类加载、双亲委派、垃圾回收、编译器优化、性能调优等原理。
  4. 数据结构：掌握数组, 链表、二叉树、堆、栈、队列、哈希表、红黑树、跳跃表、图、前缀树、并查集等常用数据结构。
  5. 设计模式：掌握单例、工厂、建造者、代理、责任链、装饰者、观察者、MVC、模板方法、策略、命令、适配器等常用模式。
  6. 框架：深入理解并阅读过 Spring、Spring MVC、Spring Boot、Spring Cloud、Dubbo、MyBatis、Tomcat 源码，熟悉Netty 原理。
  7. 数据库：深入理解 MySQL，包括锁、事务、MVCC、索引、SQL Explain 与调优、主从复制、分库分表等原理，熟悉 Oracle、MongoDB。
  8. 缓存：深入理解 Redis，包括 int、embstr、raw、dict、linkedlist、ziplist、inset、skiplist 数据结构、布隆过滤器、事务、key 过期策略、分布式锁、RDB、AOF、数据分区、集群架构等原理，熟悉 Guava Cache。
  9. 消息队列：深入理解 RabbitMQ、Kafka、RocketMQ，包括生产端可靠性投递、消费端幂等性消费、高可用架构等原理。
  10. 其他：掌握 Linux、Nginx、LVS、HAProxy、Keepalived、Docker、Kubernetes 常见命令，熟悉 ES、ELK。

  | 维度           | 关键词                                                       |
  | -------------- | ------------------------------------------------------------ |
  | 总结项         | JAVA、JVM、集合、JUC、数据结构、设计模式、MySQL、Redis、RabbitMQ、Kafka、Dubbo、SpringCloud、Spring |
  | 语言           | JAVA、JVM、集合、JUC、Jquery、WX5、VUE                       |
  | 数据结构       | 数组、链表、二叉树、滑动窗口、单调栈、前缀树、并查集、堆、图、红黑树、哈希表、跳跃表、队列 |
  | 设计模式       | 单例、工厂、建造者、策略、命令、代理、责任链、模板方法、MVC、适配器、装饰者、观察者 |
  | 框架           | Spring、SpringCloud、Mybatis、Netty、Dubbo、Spring MVC、Spring Boot |
  | 数据库         | MySQL、Oracle、MongoDB、Redis、Zookeeper、FastDFS            |
  | 消息队列       | RabbitMQ、Kafka、RocketMQ                                    |
  | 其他（可不写） | Linux、Tomcat、Nginx、ES、ELK、Sharding JDBC、MyCAT、LVS、HaProxy、Keepalived、Docker、Kubernetes、Cloud Foundry、Mesos、Marathon |

- 工作经历：
  - 年份：2019 年 06 月 - 至今。
  - 公司：美的集团 - 美云智数。
  - 公司介绍：源自美的 IT，旨在为中大型企业提供全价值链数字化解决方案和云服务，拉通消费端、营销端、产品端、制造端和供应端，赋予企业互联网化、智能化、移动化。
  - 岗位：后端开发中级工程师。
  - 部门：供应链部门。
  - 工作荣誉：2019 年度绩效 A，2019 年获得优秀新人奖、2020 年半年度绩效 S。
  - 工作描述：负责项目架构搭建与优化、项目技术攻坚、前后端核心开发、参与主要模块的设计及编码工作。
  - 工作亮点：2500+ 并发接口实现；优化生产线接口耗时从 5 s 降到 200 ms ；Sass 产品微服务落地；EsJob + Kafka +责任链，实现定时任务高可靠。 
- 项目经历：
  - 美的集团 GSRMC：
    - 时间：2021 年 10 月 - 至今。
    - 团队规模：项目人数 116，36 人 前/后端开发。
    - 角色：Java、Vue 开发，模块负责人。
    - 技术栈：Vue + SpringCloud + Redis + Kafka + Mybatis + Sharding JDBC + MySQL + MongoDB。
    - 项目介绍（技术向）：基于 Oracle EBS SRM，通过 MySQL 分库分表进行数据迁移，SpringCloud 微服务改造，以美的云为基础，构建了全球化供应商关系管理云，承担集团供应链战略规划及供应商全价值链协同管理等作用。
    - 负责内容：负责高质量的模块设计与全栈开发，包括需求分析、接口设计、组件封装、架构优化等工作。
    - 项目亮点：
      1. 通过封装 Around 切面注解，复用接口日志收集行为，解耦业务代码，通过 Kafka 实现注解异步收集，对比 MongoDB 日志同步插入，平均减少时间开销约 10.63%，通过 MD5 验签 + AES 解密，增加接口安全性，通过多线程查询 + Future 异步监听，平均提升物料采购分类查询速度约 22.95%，通过 Guava Cache 缓存事业部与库存组织，平均提升接口响应速度约 18.23%，Jmeter 压测耗时 200 ms 内最大支持 2500+ 并发。
      2. 通过模型抽象，实现基于 Guava Cache / Redis / MySQL 后端分页的通用穿梭框组件，约节省 60% 小类、大类、省份等穿梭框组件的开发时间。
      3. 通过分析供应商画像需求，绘制业务时序图，抽象基于缓存线程池的异步式任务，以及可初始化上下文的同步式任务模型，以工厂 + 建造者 + 责任链模式构造执行链， 结合使用 EsJob + Kafka + MongoDB 中间件，解决任务单点定时、分布式高性能消费，易于定位异常及迅速恢复的问题。
    - 数据规模：目前，GSRMC 覆盖全集团供应链业务，累加用户数 3 w+，同时使用人数 300+，物料采购分类数 1.61 kw+，物料研发分类数 2.15 kw+，物料数 3.28 kw+，采购接收数 3.08E+。
  - 美云智数 Sass 产品：
    - 时间：2021 年 1 月 - 至今。
    - 团队规模：项目人数 33，15 人 前/后端开发。
    - 角色：Java 研发，微服务重构负责人。
    - 技术栈：Vue + SpringBoot / SpringCloud + Redis + ESB / Kafka + Mybatis Plus + MySQL。
    - 项目介绍（技术向）：公司基于美的业务自研 Sass 产品，包括身份云 SSO，寻源云供需匹配，品质云产业链质量验证，进销存云仓储可视化，SRM 云供方生命周期管理等，以提供一站式智能制造数字化解决方案。
    - 负责内容：负责进销存云销售出库、数据中台与中科院对接模块的设计和研发，以及品质云微服务重构等工作。
    - 项目亮点：
      1. 通过使用 Druid 监控，找出问题 SQL 并进行调优，并增加 Redis 缓存，优化接口延时从 5 s 降到 200 ms，以解决条码出库 5 扫 / 1s，且要求立即定位异常的高效率扫码问题。
      2. 通过分布式锁，实现寻源、进销存、品质单点定时，通过使用 Netty 通信聚合订单信息到中台，中台提供 MD5 验签 +TCP 传输的接口对接中科院。
      3. 通过落地 SpringCloud，拆分品质云单体为 BASE、ESB、OEM、APP 等多个微服务，降低 OEM 下线扫码所在服务器的平均负载约 33%，有效避免生产车间停线事件的发生。
    - 压测指标：目前，品质云累计下线条码数量 1.02 kw+，供方 517 家，不停机产线数量 8 条，进销存云累计出库单量 840.58 w+，供方 216 家。
  - 比亚迪 SRM 服务采购订单化：
    - 时间：2021 年 6 月 - 2021 年 10 月。
    - 团队规模：项目人数 18，9 人 前/后端开发。
    - 角色：Java、Wex5 开发，模块负责人。
    - 技术栈：Wex5 + Dubbo + SpringMVC + Redis + RabbitMQ + Mybatis + Oracle。
    - 项目介绍（技术向）：支援比亚迪 SRM 项目，开发服务类与资产类采购管理的线上化平台，通过与供应商之间的订单、交付、验收、结算、付款等协同，实现合规、透明、可追溯，进度可视化。
    - 负责内容：负责组件封装、交付单全栈开发、对接云平台主数据，以及云平台测试环境服务器部署等工作。
    - 项目亮点： 
      1. 通过 WebUploader + FastDFS + Redis Zlist，实现大文件分片上传，以满足广告类交付单上传 2G+ 大视频文件的要求。
      2. 通过线程池 + RabbitMQ + 定时任务，封装通用异步邮件工具类，实现邮件服务器统一发送。
      3. 通过线程池 + CountDownLatch 并发查询云平台 PO 数据，提高约 79.32% 接口响应速度，避免了接口超时，通过索引优化 SRM PR / PO 关系表，将定时任务工作时间从 30 min+ 缩短至 5 min 13 s-。
      4. 通过部署 Tomcat Manager + ELK，提高测试环境打包和排查问题的效率，通过 Thread Dump + MAT 分析并解决发包导致的 CPU 100% 问题。
    - 项目总结：目前，云平台累计订单更新数 6.39 E+，采购订单数量 4.02 kw+，SRM PR / PO 关系数 1.95 kw+。
  - 卡特彼勒 SCC：
    - 时间：2019 年 10 月 - 2020 年 12 月。
    - 团队规模：项目人数 9，5 人 前/后端开发。
    - 角色：Java、Wex5 开发，模块负责人。
    - 技术栈：Wex5 + Dubbo + SpringMVC + Redis + RabbitMQ + Mybatis + MySQL。
    - 项目介绍（技术向）：为卡特彼勒搭建一套高效的采购业务管理系统，使采购环节更加规范、透明、高效、可追溯，提高采购作业效率，降低采购成本，控制采购风险，有效防呆纠错并预警和管控，加强采购业务流程的关联性并形成闭环管理。
    - 负责内容：负责二级模型，日本询报价、成本分析、价格调整等模块全栈开发等工作。
    - 项目亮点： 
      1. 通过 POI 识别抬头标志，区分中国/日本地区的模板，按规则读取询报价数据，校验、计算、处理后批量插入，设计容器异常类，允许导入期间收集完所有异常信息才返回，提升用户操作体验。
      2. 通过使用 ThreadLocal，存放本地线程的局部变量，优化价格调整方法中代码参数过多的现象。
      3. 通过计算线性方程参数，使用 Excharts 展示多项式折线图，展示成本分析模型。
    - 结论：因迭代效率高、BUG 率低，获得客户的一致认可，在 2020 年获得公司年度优秀标杆项目奖。

#### 3）压测指标

##### 美的集团 GSRMC

###### PLM 配套接口

1. 异步收集日志测试：

   - 测试 1 次请求：Kafka（124.78 ms ）对比同步插入（142.67 ms），平均减少时间开销 12.54%。
   - 测试 10 次请求：Kafka（1140.63 ms ）对比同步插入（1271.22 ms），平均减少时间开销 10.27%。
   - 测试 100 次请求：Kafka（10256 ms ）对比同步插入（111036.33 ms），平均减少时间开销 9.08%。
   - 求平均值： （12.54 + 10.27 + 9.08） / 3 约等于 10.63。

   | 测试内容                       | 测试环境        | 测试数量（条数） | 测试1（ms）           | 测试2（ms）           | 测试3（ms）           | 平均（ms） |
   | ------------------------------ | --------------- | ---------------- | --------------------- | --------------------- | --------------------- | ---------- |
   | MongoDB 日志同步插入           | 本地（2 C 1 G） | 1 / 1 / 1        | 147 / 155 / 140       | 153 / 136 / 156       | 138 / 122 / 137       | 142.67     |
   |                                |                 | 10 / 10 / 10     | 1105 / 1158 / 1225    | 1968 / 1280 / 1183    | 1319 / 1110 / 1093    | 1271.22    |
   |                                |                 | 100 / 100 / 100  | 10933 / 10922 / 11211 | 11106 / 10725 / 10834 | 11300 / 11678 / 10618 | 111036.33  |
   | Kafka 异步日志收集（无 Feign） | 本地（2 C 1 G） | 1 / 1 / 1        | 146 / 139 / 140       | 125 / 103 / 130       | 122 / 113 / 105       | 124.78     |
   |                                |                 | 10 / 10 / 10     | 1024 / 1081 / 974     | 1753 / 1244 / 1170    | 1246 / 1032 / 1354    | 1140.63    |
   |                                |                 | 100 / 100 / 100  | 10501 / 10343 / 10249 | 9821 / 10890 / 11571  | 9689 / 9648 / 9592    | 10256      |
   | Kafka 异步日志收集             | 本地（2 C 1 G） | 1 / 1 / 1        | 158 / 148 / 175       | 119 / 153 / 166       | 147 / 118 / 239       | 148        |
   |                                |                 | 10 / 10 / 10     | 1825 / 1303 / 1462    | 1607 / 1440 / 1548    | 2632 / 1882 / 1543    | 1576.25    |
   |                                |                 | 100 / 100 / 100  | 12099 / 11895/ 12220  | 11380 / 12222 / 12395 | 11926 / 12107 / 13414 | 12184.22   |
   | Kafka 异步日志收集             | SIT（2 C 16 G） | 1 / 1 / 1        | 65 / 55 / 62          | 79 / 63 / 54          | 72 / 57 / 55          | 62.44      |
   |                                |                 | 10 / 10 / 10     | 826 / 666 / 652       | 744 / 752 / 662       | 619 / 687 / 696       | 700.44     |
   |                                |                 | 100 / 100 / 100  | 6802 / 6666 / 7120    | 7228 / 7207 / 7575    | 7915 / 7850 / 7004    | 7263       |

   ```java
       @Autowired
       private RestTemplate restTemplate;
   
       /**
        * 【内部压测接口】- GSRMC-GPLM-015 - PLM拉通分类关系数据 => PLM 获取SRM 品类对应配套信息
        *
        * @return
        */
       @RequestMapping(value = "/batchTest", method = RequestMethod.GET)
       public ResponseData batchTest(@RequestBody PlmItemCatesSubBo params) throws Exception {
           // PLM拉通分类关系数据 BO
           PlmItemCatesSubBo plmItemCatesBo = new PlmItemCatesSubBo();
           plmItemCatesBo.setItemCode("10500909000012");
           plmItemCatesBo.setOrganizationCode("9MA");
           plmItemCatesBo.setKeycId(123L);
           plmItemCatesBo.setFeatureName("123");
           plmItemCatesBo.setFeatureValue("123");
   
           // 设置PLM送货单申请配套接口请求参数
           Map<String, String> urlParams = new HashMap<>();
           urlParams.put("dataSource", "PLM");
   
           // AES加密, 然后生成MD5消息摘要
           try {
               urlParams.put("value", URLEncoder.encode(AESUtil.encrypt(JSONObject.toJSONString(plmItemCatesBo), "hC2iK1aG1bE2kN1b"), "UTF-8"));
               urlParams.put("sign", MD5Util.MD5(urlParams.get("value") + "aC6fP3hD0fE1jC2b"));
           } catch (Exception e) {
               e.printStackTrace();
           }
   
           long size = params.getKeycId();
           StopWatch stopWatch = new StopWatch(String.format("%d / %d / %d", size, size, size));
   
           // 预热
           batchTestByParams(size, urlParams);
   
           // 开始第一次
           stopWatch.start(String.format("第一次 %d", size));
           batchTestByParams(size, urlParams);
           stopWatch.stop();
   
           // 开始第二次
           stopWatch.start(String.format("第二次 %d", size));
           batchTestByParams(size, urlParams);
           stopWatch.stop();
   
           // 开始第三次
           stopWatch.start(String.format("第三次 %d", size));
           batchTestByParams(size, urlParams);
           stopWatch.stop();
   
           System.err.println(stopWatch.prettyPrint());
           return null;
       }
   
       private void batchTestByParams(long size, Map<String, String> urlParams) throws Exception {
           for (int i = 0; i < size; i++) {
               // 请求PLM送货单申请配套接口
               restTemplate.getForObject("http://localhost:61000/srmbase/feignPermit/itemCateSub/queryItemCatesSubSupportInfos?value={value}&sign={sign}&dataSource={dataSource}", ResponseData.class, urlParams);
           }
       }
   ```

2. Future 监听测试：

   - 测试 1 次请求：Future 异步（2370 ms ）对比Future.get() 同步（2865.44 ms），提升物料采购分类获取获取速度 17.29%。
   - 测试 10 次请求：Future 异步（20528.57 ms ）对比Future.get() 同步（28756.33 ms），提升物料采购分类获取获取速度 28.61%。
   - 求平均值： （17.29 + 28.61） / 2 约等于 22.95。

   | 测试内容          | 测试环境        | 测试数量（条数） | 测试1（ms）           | 测试2（ms）           | 测试3（ms）           | 平均（ms） |
   | ----------------- | --------------- | ---------------- | --------------------- | --------------------- | --------------------- | ---------- |
   | Future.get() 同步 | 本地（2 C 1 G） | 1 / 1 / 1        | 2708 / 2834 / 3134    | 2639 / 2783 / 3219    | 2638 / 3147 / 2687    | 2865.44    |
   |                   |                 | 10 / 10 / 10     | 29135 / 29057 / 31914 | 30187 / 27240 / 27189 | 30775 / 25951 / 27359 | 28756.33   |
   | Future 异步       | 本地（2 C 1 G） | 1 / 1 / 1        | 2883 / 2688 / 2482    | 2100 / 2035 / 2465    | 2490 / 2533 / 2167    | 2370       |
   |                   |                 | 10 / 10 / 10     | 21074 / 20497 / 18818 | 21301 / 19805 / 20110 | 26422 / 22095 / 24773 | 20528.57   |

   ```java
   // 查询其他库存组织采购分类分表
   List<Future<List>> futuresList = new ArrayList<>(otherOrgCodeSet.size());
   for (String otherOrgCode : otherOrgCodeSet) {
       Future<List> listFuture = SwitchDatasourceQueryUtil.executeBaseShardingNodeQuery(List.class, args -> queryItemCateList(itemCode, otherOrgCode), null);
       futuresList.add(listFuture);
   }
   for (Future<List> listFuture : futuresList) {
       List<ItemCatesSub> otherItemCatesSubList = listFuture.get();
       if(!CollectionUtils.isEmpty(otherItemCatesSubList)) {
           itemCatesSubList.addAll(otherItemCatesSubList);
       }
   }
   ```

3. 缓存库存组织测试：

   - 测试 1 次请求：缓存库存组织（2370 ms ）对比不缓存库存组织（3110.89 ms），提升物料采购分类获取获取速度 23.82%。
   - 测试 10 次请求：缓存库存组织（20528.57 ms ）对比不缓存库存组织（21668.78 ms），提升物料采购分类获取获取速度 5.26%。
   - 求平均值： （17.29 + 28.61） / 2 约等于 14.54。
   - 由于使用的是本地缓存，所以缓存库存组织的少了网络 IO 时间，假设为 100 ms，那么 10 次请求的速度提升比为 `(2270 - 3110.89) / 3110.89 = 9.42`，1 次请求的速度提升比为 `(2270 - 3110.89) / 3110.89 = 27.03`，所以平均值  = （9.42 + 27.03） / 2 = 18.23。

   | 测试内容       | 测试环境        | 测试数量（条数） | 测试1（ms）           | 测试2（ms）           | 测试3（ms）           | 平均（ms） |
   | -------------- | --------------- | ---------------- | --------------------- | --------------------- | --------------------- | ---------- |
   | 不缓存库存组织 | 本地（2 C 1 G） | 1 / 1 / 1        | 2877 / 2596 / 2932    | 2775 / 2678 / 2598    | 3294 / 4893 / 3355    | 3110.89    |
   |                |                 | 10 / 10 / 10     | 21745 / 16239 / 20258 | 25343 / 20654 / 21256 | 23576 / 24712 / 21236 | 21668.78   |
   | 缓存库存组织   | 本地（2 C 1 G） | 1 / 1 / 1        | 2883 / 2688 / 2482    | 2100 / 2035 / 2465    | 2490 / 2533 / 2167    | 2370       |
   |                |                 | 10 / 10 / 10     | 21074 / 20497 / 18818 | 21301 / 19805 / 20110 | 26422 / 22095 / 24773 | 20528.57   |

   Jmeter 压测：

   - 由于接口先去拿 AES_KEY 和 MD5_KEY，加密，再去解密，测试为 17 QPS，去除加解密后，测试为 25 QPS，性能提升 47.06%。
   - 因此，如果加 Redis + 去除解密的话，那么生产上的最大并发 = 1733 * 1.4706% 约等于 2548.65 QPS。

   | 测试内容       | 测试环境                    | 平均（200 ms 内） |
   | -------------- | --------------------------- | ----------------- |
   | 验签，解密     | 本地（2C 1 G）              | 17                |
   | 不验签，不解密 | 本地（2C 1 G）              | 25                |
   | 不加 Redis     | SIT（2 C 16 G）             | 60                |
   | 不加 Redis     | PRD（8 C 16 G）             | 693               |
   | 加 Redis       | SIT（2 C 16 G）             | 150               |
   | 加 Redis       | PRD（8 C 16 G）（计算出来） | 1733              |


```sql
DROP PROCEDURE IF EXISTS proc_initData;
DELIMITER $
CREATE PROCEDURE proc_initData()
  BEGIN
    DECLARE i INT DEFAULT 1;
    WHILE i<=10000 DO
      INSERT INTO srm_pos.srm_pos_vendor_award (BU_CODE, BU_NAME, VENDOR_CODE, VENDOR_NAME, AWARD_NAME, APPROVAL_ID, APPROVAL_CODE, APPROVAL_STATUS, START_DATE, END_DATE, CREATED_BY, CREATION_DATE, LAST_UPDATED_BY, LAST_UPDATE_DATE, CREATED_FULL_NAME, LAST_UPDATED_FULL_NAME, DELETE_FLAG, VERSION, ATTRIBUTE1, ATTRIBUTE2, ATTRIBUTE3, ATTRIBUTE4, ATTRIBUTE5, ATTRIBUTE6, ATTRIBUTE7, ATTRIBUTE8, ATTRIBUTE9, ATTRIBUTE10, ATTRIBUTE11, ATTRIBUTE12, ATTRIBUTE13, ATTRIBUTE14, ATTRIBUTE15) VALUES ('100909', 'OU_100909_家用事业部', 'A0000943', '广东赛普电器制造有限公司-材料', '虎虎奖', null, null, 'APPROVED', '2022-02-14', '2022-02-14', 'chenrc', '2022-02-14 00:00:00', 'chenrc', '2022-02-14 00:00:00', '陈2075', '陈2075', 0, 0, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
      SET i = i+1;
    END WHILE;
  END $
CALL proc_initData();
```

###### 订单统计

目前，GSRMC 覆盖全集团供应链业务，累加用户数 3 w+ / 同时使用人数 300+ / 物料采购分类数 1.61 kw+物料研发分类数 2.15 kw+ / 物料数 3.28 kw+ / 采购接收数 3.08E+。

| 分表                   | 表含义               | 总记录数   |
| ---------------------- | -------------------- | ---------- |
| srm_sys_item_cates_sub | 物料采购分类关系表   | 1613.38 w+ |
| srm_sys_dev_cate       | 采购分类研发分类关系 | 132.13 w+  |
| srm_sys_item_keycs     | 物料研发分类关系表   | 2153.11w+  |
| srm_sys_items_submeter | 物料表               | 3280.19 w+ |
| srm_po_line_locations  | 一揽子价格表         | 1.0220 E+  |
| srm_po_receive_det     | 采购接收表           | 3.0813 E+  |

```java
SELECT *
FROM information_schema.tables
WHERE table_schema = 'srm_price' AND table_name LIKE 'srm_po_receive_det%'
```

##### 美云智数 Sass 产品

###### Druid SQL 调优

| 测试内容                                 | 测试环境              | 测试1       | 测试2（ms） | 测试3       | 平均        | 提效   |
| ---------------------------------------- | --------------------- | ----------- | ----------- | ----------- | ----------- | ------ |
| psi_base_barcode 前（314.67w+）          | SIT MySQL（4 C 16 G） | 3 s 947 ms  | 3 s 973 ms  | 4 s 64 ms   | 3994.67 ms  |        |
| psi_base_barcode 后（314.67w+）          | SIT MySQL（4 C 16 G） | 108 ms      | 91 ms       | 83 ms       | 94 ms       | 97.65% |
| psi_base_packing_relation 前（315.28w+） | SIT MySQL（4 C 16 G） | 2 s 560 ms  | 2 s 852 ms  | 2 s 564 ms  | 2658.67 ms  |        |
| psi_base_packing_relation 后（315.28w+） | SIT MySQL（4 C 16 G） | 86 ms       | 78 ms       | 89 ms       | 84.33 ms    | 96.83% |
| psi_sales_stock_out 前（840.58w+）       | SIT MySQL（4 C 16 G） | 11 s 648 ms | 11 s 465 ms | 11 s 565 ms | 11559.33 ms |        |
| psi_sales_stock_out 后（840.58w+）       | SIT MySQL（4 C 16 G） | 106 ms      | 95 ms       | 97 ms       | 99.33 ms    | 99.14% |

```sql
-- 销售出库扫码索引优化：
-- 1）彩箱条码信息表
-- a. 已是主键，加索引没提升
ALTER TABLE psi_base_barcode ADD INDEX psi_base_barcode_n3(OEM_REPORT_ID);
-- b. 已是主键，加索引没提升
ALTER TABLE psi_base_barcode ADD INDEX psi_base_barcode_n1(OEM_REPORT_NO);
-- c. 联合主键，加索引有提升：300w数据提升
ALTER TABLE psi_base_barcode ADD INDEX psi_base_barcode_n2(CUS_COMPANY_CODE, PRODUCT_CODE);

-- 地台板绑定优化：
-- => 正常建板场景
-- 1、判断条码箱包关系：增加索引【CARTON_BARCODE】有提升
SELECT RELATION_ID, LAST_UPDATED_BY, CREATED_BY_IP, LAST_UPDATED_BY_IP, LAST_UPDATE_DATE, CREATION_DATE, VERSION, ORG_ID, DELETE_FLAG, CREATED_BY, COLOR_BOX_AMOUNT, CARTON_BARCODE, BARCODE
FROM psi_base_packing_relation
WHERE (CARTON_BARCODE = '331100007920401110191W');
-- 2、判断条码是否为1包1条码：增加索引【BARCODE】有提升
SELECT RELATION_ID, LAST_UPDATED_BY, CREATED_BY_IP, LAST_UPDATED_BY_IP, LAST_UPDATE_DATE, CREATION_DATE, VERSION, ORG_ID, DELETE_FLAG, CREATED_BY, COLOR_BOX_AMOUNT, CARTON_BARCODE, BARCODE
FROM psi_base_packing_relation
WHERE (BARCODE = '331100007920401110191W' AND COLOR_BOX_AMOUNT = 1);

-- 4、判断条码是否已出库：增加【CARTON_BARCODE】和【BARCODE】索引有提升
SELECT COUNT(1)
FROM psi_sales_stock_out
WHERE (CARTON_BARCODE = '331100007920401110191W' OR BARCODE = '331100007920401110191W');

-- Add Index： explain => index_merge，Using union(psi_sales_stock_out_n1,psi_sales_stock_out_n2); Using where
ALTER TABLE psi_sales_stock_out ADD INDEX psi_sales_stock_out_n1(CARTON_BARCODE);
ALTER TABLE psi_sales_stock_out ADD INDEX psi_sales_stock_out_n2(BARCODE);

-- 6、实时查询MES产品表中的规格值
SELECT ID, CARTON_WEIGHT, PRODUCT_MODEL, PALLET_WIDTH, PRODUCTIVITY_HOUR, MEMO, CARTON_MAX_VOLUME, PAKING_BOX_MAX_VOLUME, KEYPARTS_ITEMS, USER_CREATED, PRODUCT_ATTR, UOM, IS_OVERSEA, PRICE, DATETIME_CREATED, STATE, INV_ORG_ID, FLOOR_MAX_VOLUME, PRODUCT_TYPE, DOWNLOAD_DEAL_BATCH, CARTON_SIZE, DATETIME_MODIFIED, PRODUCT_DESC, PALLET_LENGTH, INSPECT_CT, PALLET_MAX_VOLUME, USER_MODIFIED, PN, SKU_CODE, STATUS
FROM mespro.FND_PRODUCT_INFO
WHERE (INV_ORG_ID LIKE '%585' AND PN = '21061011000755');

-- 优化 (INV_ORG_ID LIKE '%585' AND PN = '21061011000755') => (INV_ORG_ID = '585' AND PN = '21061011000755')
```

###### 订单统计

目前，品质云下线条码数量 1.02 kw+，供方 517 家，不停机产线数量 8 条，进销存云出库单量 840.58 w+，供方 216 家。

```sql
select *
from information_schema.TABLES
```

| 系统     | 表                                | 表含义 | 总记录数  |
| -------- | --------------------------------- | ------ | --------- |
| 品质     | oem_external_mes_colorcode        |        | 722.26w+  |
|          | qc_oem_order2_line_ex21913        |        | 535.25w+  |
|          | qc_oem_order_line21913            |        | 488.08w+  |
|          | qc_oem_order_line                 |        | 177.54w+  |
|          | qc_oqc_item_standard_value        |        | 429.96w+  |
|          | qc_oqc_item_standard_value211027  |        | 386.46w+  |
|          | qc_oqc_item_standard_value211123  |        | 328.27w+  |
|          | qc_oqc_item_standard_value21118   |        | 294.68w+  |
|          | qc_oem_standard_line              |        | 307.83w+  |
|          | qc_oqc_test_standard              |        | 152.22w+  |
|          | qc_oem_items                      |        | 309.75w+  |
|          | qc_oqc_batch_test_item            |        | 259.33w+  |
|          | oem_external_mes_bigcode          |        | 125.11w+  |
| 进销存   | psi_gsc_inventory_push_items      |        | 1711.59w+ |
|          | psi_base_packing_relation_history |        | 616.55w+  |
|          | psi_base_barcode_history          |        | 257.36w+  |
|          | psi_sales_stock_out               |        | 840.58w+  |
|          | psi_base_barcode                  |        | 314.67w+  |
|          | psi_base_packing_relation         |        | 315.28w+  |
|          | psi_prd_pallet_box_relation       |        | 250.03w+  |
| 数据中台 | cloud_gsrm_asl * 3                |        | 38.61w+   |
|          | cloud_gsrm_item * 3               |        | 31.63w+   |
|          | mcc_company_info                  |        | 1321      |
|          | mcc_deliver_receive_sum           |        | 2.24w+    |
|          | mcc_order_quotation_sum           |        | 342       |

##### 比亚迪 SRM 服务采购订单化

###### 云平台并发查询

通过线程池 + CountDownLatch 并发查询云平台 PO 数据，提高 79.32% 接口响应速度，避免了接口超时。

| 测试内容             | 测试环境         | 测试1（ms） | 测试2（ms） | 测试3（ms） | 平均（ms） |
| -------------------- | ---------------- | ----------- | ----------- | ----------- | ---------- |
| 同步查询（10000 条） | 本地（8 C 16 G） | 5 min 07 s  | 4 min 58 s  | 5 min 33 s  | 312.67 s   |
| 并发查询（10000 条） | 本地（8 C 16 G） | 1 min 13 s  | 59 s        | 1 min 02 s  | 64.67      |

###### 订单统计

目前，云平台累计订单更新数量 6.39 E+，采购订单数量 4.02 kw+，SRM PR / PO 数量 1.95 kw+。

| 系统   | 表            | 表名                | 总记录数   |
| ------ | ------------- | ------------------- | ---------- |
| 云平台 | SAP_CDHDR     | PO 单增量表         | 6.39 E+    |
|        | SAP_EKPO      | PO 行表             | 4019.80 w+ |
|        | SAP_ZMMSSBM03 | PO 描述表           | 1544.27 w+ |
|        | SAP_EKKO      | PO 币种表           | 1147.68 w+ |
|        | SAP_ZEKKO     | PO 寻源表           | 965.70 w+  |
|        | SAP_ZTSY002   | PO 创建详情         | 7.23 w+    |
| SRM    | PR / PO       | 采购需求 / 采购订单 | 1948.13 w+ |

### 1.2. 项目准备

| 系统       | 接口描述清单         | 关键词                                                       |
| ---------- | -------------------- | ------------------------------------------------------------ |
| GSRMC      | PLM 配套接口         | Around 切面注解、Kafka + MongoDB 、MD5  + AES、多线程 + Future、Guava Cache、Jmeter |
|            | 穿梭框组件           | 接口、抽象类、模型抽象、Guava Cache、Redis、MySQL            |
|            | 供应商画像同步       | 缓存线程池、工厂 + 建造者 + 责任链、EsJob + Kafka + MongoDB  |
| Sass 产品  | 条目销售出库         | Druid 监控、SQL 调优、Redis                                  |
|            | 中科院接口           | 分布式锁、Netty、MD5 + HTTP                                  |
|            | 微服务拆分           | SpringCloud                                                  |
| 比亚迪 SRM | 大文件分片上传       | WebUploader + FastDFS + Redis Zlist                          |
|            | 邮件发送组件         | 线程池 + RabbitMQ + 定时任务                                 |
|            | 定时任务获取 PO      | 线程池 + CountDownLatch、索引优化                            |
|            | 测试环境打包平台优化 | Tomcat Manager + ELK、Thread Dump + MAT、CPU 100%            |
| 卡特 SCC   | 模板导入完善         | POI、容器异常类                                              |
|            | 代码优化             | ThreadLocal                                                  |
|            | 成本分析模型         | Excharts、多项式折现图                                       |

STAR 法则，是情境（Situation）、任务（Task）、行动（Action）、结果（Result）四项的缩写，是一种讲述自己故事的方式，或者说，是一个清晰、条理的作文模板，合理熟练运用该法则，可以轻松的描述事情的逻辑方式，表现出分析与问题的逻辑性、条理性和逻辑性。

1. Situation：情境，本次事件是在什么情况下发生的。
2. Task：任务，在本次事件中，主要负责什么任务。
3. Action：行动，在本次事件中，针对这些情况的分析，采用了什么样的行动。
4. Result：结果，本次事件最后的结果是怎么样的，以及学到了什么。

| 举例 | 内容（大一辩论比赛获得冠军）                                 |
| ---- | ------------------------------------------------------------ |
| S    | 系里一共有 5 支队伍，实例...，我们小组...                    |
| T    | 熟悉辩论流程，掌握辩论技巧，获得系冠军                       |
| A    | 自己主动整理资料，组织小组学习流程，编制训练题，小组训练，根据每个人的特点，分配任务（要尽量详细，包括当中遇到的困难是什么，怎么解决的） |
| R    | 获得系辩论赛冠军                                             |

#### PLM 配套接口

##### S | Situation

供应链体系管理专员反馈，他们在 PLM 建送样申请单时，由于物料配套没有**自动匹配**，导致经常选错配套人员，然后就要撤回、修改、重新提交，影响业务流程效率。

##### T | Task

所以他们希望在 PLM 上，根据物料就可以**自动匹配** SRM 品类分工中的**配套专员信息**，方便他们走业务流程。

##### A | Action

###### 1）需求分析 | 获取配套信息

接到这个需求，首先要看下 SRM 要怎么获取配套专员信息的：

- **表结构**：srm_sys_cate_purviews，生产表大小  33.29 w+。

  ![1644893203876](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1644893203876.png)

- **查询条件**：

  ```java
  /** 根据参数获取有效【资源配套专员】品类分工 */
  private List<CatepurviewsVo> getCatepurviewVoListByBu(final String organizationCode, final Set<String> categoryCode3Set) throws Exception {
      log.info("根据参数获取有效【资源配套专员】品类分工: organizationCode={}, categoryCode3Set={}", organizationCode, JSONObject.toJSON(categoryCode3Set));
  
      Map<String, Object> params = new HashMap<>();
      params.put("deleteFlag", "N");
      params.put("position", CategoryPositionEnum.RESOURCE_MATCH_COMMISSIONER.getValue());// 资源配套专员
      params.put("organizationCode", organizationCode);// 库存组织编码
      params.put("categoryCode3List", categoryCode3Set);// 采购分类编码列表
  
      // 通过条件返回品类分工数据
      return catePurviewsService.queryCateByConList(params);
  }
  ```

- **结论**：

  - 因此，获取配套专员需要参数：采购分类编码（即品类编码）、库存组织编码（集团 -> 事业部 -> 业务实体 -> 库存组织）、资源配套专员岗位的字典编码。

  - 由第 1 步可以看到，库存组织编码、采购分类编码需要 PLM 传入，资源配套专员岗位的字典编码写死就好，而由于体系要求的是物料编码，那么采购分类编码就需要继续处理得出了，这样，PLM 接口的入参就初步定了，为：

    ```java
    {
        "itemCode": "16063500A17764",
        "organizationCode": "M40",
    }
    ```

###### 2）需求分析 | 获取采购分类流程

然后按照 SRM 的业务流程，想要根据物料编码来获取对应的采购分类编码，需要走以下流程：

![1644903196224](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1644903196224.png)

###### 3）需求分析 | 查找当前库存组织的采购分类

先根据物料编码 itemCode + 库存组织 orgCode，查询物料采购分类关系表：

- **表结构**：srm_sys_item_cates_sub_${organizationCode}，生产表大小 1613.38w+。

  ![1644894066149](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1644894066149.png)

- **查询条件**：

  ```java
  /** 根据物料编码+库存组织查询采购分类 */
  private List<ItemCatesSub> queryItemCateList(final String itemCode, final String organizationCode){
      log.info("根据物料编码+库存组织查询采购分类: itemCode={}, organizationCode={}", itemCode, organizationCode);
      Map<String, Object> params = new HashMap<>();
      params.put("deleteFlag", DeleteFlagEnum.NO.getValue());
      params.put("organizationCode", organizationCode);
      params.put("itemCode", itemCode);
      return itemCatesMapper.queryShardingItemCatesSubs(params);
  }
  ```

###### 4）需求分析 | 查找所有库存组织的采购分类

如果根据当前 orgCode 没有查到对应的采购分类，那么就查找**所有库存组织**（优化点：Guava Cache）的采购分类（优化点： 并发查询）。

- **查询条件**：srm_sys_item_cates_sub_${organizationCode}，生产表大小 1613.38w+。

  ```java
  // 如果按上述步骤获取不到，按物料编码，查询其他组织物料采购分类分表
  // 查询所有库存组织
  List<OrganizationVo> organizationVoList = SwitchDatasourceQueryUtil.executeBaseShardingNodeQuery(List.class, args -> baseCommonQuery.queryAllOrgList(), null).get();
  Assert.notEmpty(organizationVoList, "找不到任何有效的库存组织!");
  
  // 获取其他库存组织编码
  Set<String> otherOrgCodeSet = organizationVoList.stream()
      .filter(f -> StringUtils.isNotBlank(f.getInvCode()) && !organizationCode.equals(f.getInvCode()))
      .map(OrganizationVo::getInvCode).collect(Collectors.toSet());
  
  // 查询其他库存组织采购分类分表
  for (String otherOrgCode : otherOrgCodeSet) {
      List<ItemCatesSub> otherItemCatesSubList = SwitchDatasourceQueryUtil.executeBaseShardingNodeQuery(List.class, args -> queryItemCateList(itemCode, otherOrgCode), null).get();
      if(!CollectionUtils.isEmpty(otherItemCatesSubList)) {
          itemCatesSubList.addAll(otherItemCatesSubList);
      }
  }
  ```

###### 5）需求分析 - 查找 P 编码的采购分类

如果根据其他库存组织，都找不到对应的采购分类，那么就根据 itemCode 查找 p 编码，然后根据 p 编码查找对应的采购分类：

- **表结构**：srm_sys_items_submeter_{org_code}，生产表大小 3280.19 w+。

![1644895702505](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1644895702505.png)

- **查询条件**：

  ```java
  /** 根据条件查询 ItemsSubmeters_${organizationCode} 分表 */
  private List<ItemsSubmeterDto> queryItemsSubmeters(final String itemCode, final String organizationCode) {
      log.info("根据条件查询 ItemsSubmeters_${organizationCode} 分表: itemCode={}, organizationCode={}", itemCode, organizationCode);
      Map<String, Object> params = new HashMap<>();
      params.put("deleteFlag", 0);
      params.put("organizationCode", organizationCode);// 库存组织编码
      params.put("itemcode", itemCode);// 物料编码
      return itemsService.queryShardingItemsSubmeters(params);
  }
  ```

###### 6）需求分析 | 查找研发分类中的采购分类

根据事业部编码（优化点：Guava Cache） + 研发分类采购特征 + 研发分类特征值，查找研发分类中的采购分类：

- **表结构**：srm_sys_dev_cate，生产表大小，132.13 w+。

  ![1644894552951](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1644894552951.png)

- **查询条件**：

  ```java
  /** 按事业部+研发分类(+采购特征+特征值)，匹配研采关系中的采购分类ID列表 */
  private Set<String> getDevCategoryCodeConcatSet(final String buCode, final Long keycId,
                                                  final String featureName, final String featureValue) throws Exception {
      log.info("按事业部+研发分类+采购特征+特征值，匹配研采关系中的采购分类ID列表, buCode={}, keycId={}, featureName={}, featureValue={}", buCode, keycId, featureName, featureValue);
  
      // 特征名称 + 特征值同时存在时, 则按事业部+研发分类+采购特征+特征值查询
      List<DevCateDto> devCateDtoList = null;
      if(StringUtils.isNotBlank(featureName) && StringUtils.isNotBlank(featureValue)) {
          Map<String, Object> featureParams = new HashMap<>();
          featureParams.put("status", "Y");
          featureParams.put("buCode", buCode);// 事业部编码
          featureParams.put("keycId", keycId);// 研发分类ID
          featureParams.put("featureName", featureName);// 特征名称
          featureParams.put("featureValue", featureValue);// 特征值
          devCateDtoList = devCateService.queryDevCateListNew(featureParams);
      }
  
      // 如果按事业部+研发分类+采购特征+特征值查询为空, 则再按事业部+研发分类查询
      if(org.springframework.util.CollectionUtils.isEmpty(devCateDtoList)) {
          Map<String, Object> nonFeatureParams = new HashMap<>();
          nonFeatureParams.put("status", "Y");
          nonFeatureParams.put("buCode", buCode);// 事业部编码
          nonFeatureParams.put("keycId", keycId);// 研发分类ID
          devCateDtoList = devCateService.queryDevCateListNew(nonFeatureParams);
      }
  
      // 如果还是为空, 则直接返回
      if(org.springframework.util.CollectionUtils.isEmpty(devCateDtoList)) {
          return new HashSet<>();
      }
  
      // 获取采购分类编码列表
      return devCateDtoList.stream().map(DevCateDto::getCategoryCode).collect(Collectors.toSet());
  }
  ```

######  7）需求分析 | 合并采购分类

合并并且去重采购分类编码后，根据采购分类编码集合，执行 **1）需求分析 - 获取配套信息** ，然后过滤掉无效的、已离职的员工信息，并把最终结果返回即可。

```java
categoryCodeSet.addAll(itemCatesSubList.stream().map(ItemCatesSub::getCategoryCode).collect(Collectors.toSet()));
```

###### 8）代码优化 |  Around 切面注解 + Kafka + MongoDB 

- **@LogInfo 使用方式与数据结构**：

```java
@LogInfo(serviceName = "queryItemCatesSubSupportInfos", dbFlag = LogAop.Yes)

@Documented
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface LogInfo {
    /**
     * 接口名称
     */
    String serviceName();

    String type() default "";

    /**
     * 是否记录到mongodb
     * @return
     */
    String dbFlag() default "N";
}
```

- **切面实现**：

```java
@Aspect
@Component
public class LogAop {

    Logger logger= LoggerFactory.getLogger(LogAop.class);

    public final static String Yes="Y";
    public final static String No="N";
    public final static String SUCCESS="SUCCESS";
    public final static String ERROR="ERROR";

    @Around(value = "@annotation(LogInfo)")
    public Object logInfo(ProceedingJoinPoint pjp) throws Throwable{
        // 获取注解信息
        MethodSignature signature = (MethodSignature) pjp.getSignature();
        LogInfo annotation = signature.getMethod().getAnnotation(LogInfo.class);
        
        // 方法执行前, 设置请求参数
        Object obj ;
        LogInfoDto logInfoDto = new LogInfoDto();
        Object[] args = pjp.getArgs();
        if(!ObjectUtils.isEmpty(args)){
            String paramJson = JSONUtil.toJsonPrettyStr(args);
            logInfoDto.setArgs(paramJson);
        }
        
        // 方法执行前, 设置开始时间
        logInfoDto.setOperBeginDate(DateUtil.dateToStr(new Date(),DateUtil.DATE_TIME_FORMAT_DEFAULT));
        
        // 方法执行前, 设置服务名称
        String dbFlag="";// 标识是否记录mongodb,默认记录
        if(null != annotation){
            logInfoDto.setServiceName(annotation.serviceName());
            dbFlag=annotation.dbFlag();
        }
		
        try {
            // 方法执行前, 设置类名、请求对象请求的url和ip地址
            logInfoDto.setClassName(pjp.getTarget().getClass().getName());
            ServletRequestAttributes servletRequestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
            if(null!=servletRequestAttributes){
                HttpServletRequest httpServletRequest = servletRequestAttributes.getRequest();
logInfoDto.setRequestUrl(httpServletRequest.getRequestURL().toString());
                logInfoDto.setIpAddress(httpServletRequest.getLocalAddr());
            }
			
            // 方法执行前, 创建开始时间
            Long begin=System.currentTimeMillis();
            logger.info("serviceName:{}---begin",annotation.serviceName());
            
            // 执行具体的业务方法
            obj = pjp.proceed();
            
            // 方法执行后， 获取结束时间、计算总耗时、设置耗时
            Long end=System.currentTimeMillis();
            Long cost=end-begin;
            logInfoDto.setCost(cost.toString()+"ms");
            logInfoDto.setStatus(SUCCESS);
            logger.info("serviceName:{}---end，cost:{}ms",annotation.serviceName(),cost);
        } 
        catch (Exception e) {
            // 执行业务代码发生异常，则记录异常状态和异常堆栈信息
            logInfoDto.setErrorInfo(ExceptionUtils.getFullStackTrace(e));
            logInfoDto.setStatus(ERROR);
            throw e;
        }finally {
            try {
                logInfoDto.setOperEndDate(DateUtil.dateToStr(new Date(),DateUtil.DATE_TIME_FORMAT_DEFAULT));
                // 记录标识为Y, 或者接口异常，则记录mongodb
                if(Yes.equals(dbFlag) || ERROR.equals(logInfoDto.getStatus())){
                    String logFeignClientName = logInfoDto.getClassName().substring(0, logInfoDto.getClassName().indexOf("modules")) + "feign.client.log.LogInfoFeign";
                    LogFeignClient logFeignClient= SpringBeanUtil.getBean(logFeignClientName);
                    
                    // 调用MQ服务，发送 logInfoDto 到 Kafka
                    Map<String,Object> respon=logFeignClient.saveLoginfo(logInfoDto);
                }
            } catch (Exception e) {
                logger.error(logInfoDto.getServiceName()+"保存日志报错{}",e );
            }
        }
        
        return obj;
    }
}
```

- **发送 logInfoDto 到 Kafka**：topic = commonLogInfo

```java
@Autowired
private KafkaTemplate<String,Object> kafkaTemplate;

@RequestMapping(value ="/saveLoginfo",method = RequestMethod.POST)
public ResponseData saveLoginfo(@RequestBody LogInfoDto logInfoDto) {
    try {
        logger.info("saveLoginfo-request:{}", JSONUtil.toJsonPrettyStr(logInfoDto) );
        kafkaTemplate.send("commonLogInfo", JSONUtil.toJsonPrettyStr(logInfoDto) );
        return ResponseData.success();
    } catch (Exception e) {
        logger.error("saveLoginfo Exception:",e);
        return ResponseData.error();
    }
}
```

- **消费 commonLogInfo**：插入 MongoDB，甚至发送邮件通知。

```java
@Autowired
protected MongoTemplate mongoTemplate;

@KafkaListener(topics = {"commonLogInfo"})
public void listen(ConsumerRecord<?, ?> record) {
    try {
        Optional<?> kafkaMessage = Optional.ofNullable(record.value());
        if (kafkaMessage.isPresent()) {
            Object message = kafkaMessage.get();
            // 插入mongodb
            LogInfoDto logInfoDto = JSON.parseObject(message.toString(), LogInfoDto.class);
            mongoTemplate.insert(logInfoDto);
            
              //检查是否有发送邮件的配置，有且存在异常信息则发邮件
 if(StringUtils.isNotBlank(logInfoDto.getStatus())&&ERROR.equals(logInfoDto.getStatus())){queryAndSendMail(logInfoDto);} 
        }
    } catch (Exception e) {
        logger.error("system Exception:",e);
    }
}
```

###### 9）安全性优化 | MD5  + AES

- **PLM 加密生成摘要过程**：

```java
@RequestMapping(value = "/testQueryItemCatesSubSupportInfos", method = RequestMethod.POST)
public ResponseData testQueryItemCatesSubSupportInfos(@RequestBody PlmItemCatesSubBo plmItemCatesSubBo) throws Exception {
    String dataSource = "PLM";
    GsrmPassKeyDto keyDto = decryptService.queryFirstGsrmPassKeyInfo(dataSource);
    if(keyDto == null) {
        return new ResponseData(400, dataSource + "来源系统秘钥未配置!");
    } else {
        // AES 加密：用于保护原始bo内容
        String value = URLEncoder.encode(AESUtil.encrypt(JSONObject.toJSONString(plmItemCatesSubBo), keyDto.getAesKey()), "UTF-8");
        // MD5 生成摘要：用于验证内容是否被篡改过
        String sign = MD5Util.MD5(value + keyDto.getMdKey());
        return queryItemCatesSubSupportInfos(value, sign, dataSource);
    }
}

public class AESUtil {
    
    static final String KEY_ALGORITHM = "AES";
    static final String CIPHER_ECB_PKCS5 = "AES/ECB/PKCS5Padding";
    
    public static String encrypt(String src, String seed) {
        try {
            byte[] result = encode(src.getBytes("utf-8"), seed.getBytes());
            return bytesToHexString(result);
        } catch (Exception e) {
            logger.error(e.getMessage());
        }
        return null;
    }
    
    private static byte[] encode(byte[] clear, byte[] raw) {
        try {
            SecretKeySpec skeySpec = new SecretKeySpec(raw, KEY_ALGORITHM);
            Cipher cipher = Cipher.getInstance(CIPHER_ECB_PKCS5);
            cipher.init(Cipher.ENCRYPT_MODE, skeySpec);
            byte[] encrypted = cipher.doFinal(clear);
            return encrypted;
        } catch (Exception e) {
            logger.error(e.getMessage());
        }
        return null;
    }
}

public class MD5Util {
    public final static String MD5(String s) {
        char hexDigits[] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
                'A', 'B', 'C', 'D', 'E', 'F' };
        try {
            byte[] btInput = s.getBytes();
            // 获得MD5摘要算法的 MessageDigest 对象
            MessageDigest mdInst = MessageDigest.getInstance("MD5");
            // 使用指定的字节更新摘要
            mdInst.update(btInput);
            // 获得密文
            byte[] md = mdInst.digest();
            // 把密文转换成十六进制的字符串形式
            int j = md.length;
            char str[] = new char[j * 2];
            int k = 0;
            for (int i = 0; i < j; i++) {
                byte byte0 = md[i];
                str[k++] = hexDigits[byte0 >>> 4 & 0xf];
                str[k++] = hexDigits[byte0 & 0xf];
            }
            return new String(str);
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }
}
```

- **SRM 解密验签过程**：

```java
@Override
public Map<String, Object> decrypt(String value, String sign, String dataSource) {

    Map<String,Object> resultMap=new HashMap<>();
    Map<String,Object> param=new HashMap<>();
    param.put("dataSource",dataSource);

    List<GsrmPassKeyDto> keyList= gsrmPassKeyMapper.queryGsrmPassKey(param);
    if(CollectionUtils.isNotEmpty(keyList)){
        String mdKey=keyList.get(0).getMdKey();
        String aesKey=keyList.get(0).getAesKey();
        // 重新生成 MD5 比对传过来的 MD5，如果一样，则验签通过，否则报错！
        if(MD5Util.MD5(value+mdKey).equals(sign)) {
            try{
                // 根据传过来的 AES 加密串，进行 AES 解密，拿到 BO 的 JSON 串
                String passStr=AESUtil.decrypt(value,aesKey);
                log.info("解密成功，密文串：{}",passStr);
                //将json字符串转成map
                Map<String,Object> jsonToMap = JSONObject.parseObject(passStr);
                resultMap.put("resultCode","000000");
                resultMap.putAll(jsonToMap);
            }catch (Exception e){
                resultMap.put("resultCode","ERROR_3C010");
                resultMap.put("resultMessage","数据解密失败");
                log.info("数据解密失败");
            }
        }else{
            resultMap.put("resultCode","ERROR_3C010");
            resultMap.put("resultMessage","数据验签失败");
            log.info("数据验签失败");
        }
    }else{
        resultMap.put("resultCode","ERROR_3C010");
        resultMap.put("resultMessage","数据库秘钥串没有配置。");
        log.info("数据库秘钥串没有配置");
    }
    return resultMap;
}

public class AESUtil {
    
    static final String KEY_ALGORITHM = "AES";
    static final String CIPHER_ECB_PKCS5 = "AES/ECB/PKCS5Padding";
    
    public static String decrypt(String src, String seed) {
        try {
            String result = decode(hexStringToBytes(src), seed.getBytes());
            return result;
        } catch (Exception e) {
            logger.error(e.getMessage());
        }
        return null;
    }
    
    public static String decode(byte[] dataBytes, byte[] raw) {
        try {
            SecretKeySpec skeySpec = new SecretKeySpec(raw, KEY_ALGORITHM);
            Cipher cipher = Cipher.getInstance(CIPHER_ECB_PKCS5);
            cipher.init(Cipher.DECRYPT_MODE, skeySpec);
            byte[] decrypted = cipher.doFinal(dataBytes);
            return new String(decrypted,"utf-8");
        } catch (Exception e) {
            logger.error(e.getMessage());
        }
        return null;
    }
}
```

###### 10）性能优化 | 多线程 + Future、Guava Cache

见《压测指标 - 美的集团 GSRMC - PLM 配套接口》。

##### R | Result

最终提升了体系 PLM 创建送样申请单流程的效率，技术上还实现了：

- 通过封装 Around 切面注解，复用接口日志收集行为，解耦业务代码。
- 通过 Kafka 实现注解异步收集，对比 MongoDB 日志同步插入，平均减少时间开销约 10.63%。
- 通过 MD5 验签 + AES 解密，增加接口安全性。
- 通过多线程查询 + Future 异步监听，平均提升物料采购分类查询速度约 22.95%。
- 通过 Guava Cache 缓存事业部与库存组织，平均提升接口响应速度约 18.23%。
- Jmeter 压测耗时 200 ms 内最大支持 2500+ 并发。

#### 穿梭框组件

##### S | Situation

在现场评审开发组里，由于有个同事的评审计划页面，需要使用一个穿梭框来选择小类，以及我的评审资源页面，也需要使用穿梭框来选择大类和省份，但前端组件库里，却没有这个组件。

##### T | Task

为了坚持不重复造轮子的原则，以及加快项目的迭代进度，我提议研发通用的穿梭框组件来满足目前的要求。

##### A | Action

###### 1）需求分析 | 组件功能分析

可见，穿梭框组件分为 4 大接口：分页查询左边的数据、分页查询右边的数据、删除左边的数据并放置到右边、删除右边的数据并放置回左边。

![1644906128696](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1644906128696.png)

###### 2）建立模型 | 接口抽象

根据以上的 4 大接口，接口存在该 4 大接口，还增加了查询左边全部数据、右边全部数据，使得分页查询就只依赖这两个方法就可以了，当然也可以重新实现分页方法，以及增加了参数校验、限制加入右边数据大小接口，方便以后扩展。

```java
public interface ShuttleBoxService {

    /**
     * 校验必填的穿梭框参数
     *
     * @param config
     */
    default void checkRequiredParams(ShuttleBoxConfig config) {}

    /**
     * 全部查询左边待选择数据
     *
     * @param config
     * @return
     */
    List<Map<String, Object>> getLeftItems(ShuttleBoxConfig config);

    /**
     * 全部查询右边待选择数据
     *
     * @param config
     * @return
     */
    List getRightItems(ShuttleBoxConfig config);

    /**
     * 分页查询左边待选择数据
     *
     * @param config
     * @return
     */
    PageData<Map<String, Object>> getLeftItemsPage(ShuttleBoxConfig config);

    /**
     * 分页查询右边待选择数据
     *
     * @param config
     * @return
     */
    PageData<Map<String, Object>> getRightItemsPage(ShuttleBoxConfig config);

    /**
     * 选择数据到右边
     *
     * @param config
     */
    void addItems2Right(ShuttleBoxConfig config);

    /**
     * 删除数据到左边
     *
     * @param config
     */
    void deleteItems2Left(ShuttleBoxConfig config);

    /**
     * 限制加入右边的数据大小
     *
     * @param dataList
     */
    default void limitRightItemsSize(List<Map<String, Object>> dataList) {}
}
```

###### 3）建立模型 | 抽取 Redis 抽象类

1. 该抽象类基于 Redis 对分页获取左边数据（保持不变，在 MySQL，但要排除右边的数据）、获取右边全部数据（放缓存）、分页获取右边的数据、删除左边的数据并放置到右边（加入缓存）、删除右边的数据（删除缓存）并放置回左边、参数校验 6 个方法进行了实现。
2. 其中分页获取左边数据的方法依赖于，获取左边全部数据的方法，这样，就可以只把左边全部的方法留给对应的小类、大类、省份等某一业务的实现类实现，从而实现了大量的代码复用。
3. 同时，还有一个限制右边数据大小的方法，也留给具体实现类去实现，以满足更多变的业务。

```java
public abstract class AbstractRedisShuttleBoxServiceImpl implements ShuttleBoxService {

    /** 校验必填的穿梭框参数 */
    public void checkRequiredParams(ShuttleBoxConfig config) {
        Assert.hasText(config.getUniqueKey(), "存储唯一标识不能为空");
        Assert.hasText(config.getItemKey(), "数据唯一标识不能为空");
        Assert.notNull(config.getRedisTimeout(), "Redis数据过期时间不能为空");
    }

    @Override
    @SuppressWarnings({ "unchecked", "rawtypes" })
    public List<Map<String, Object>> getRightItems(ShuttleBoxConfig config) {
        checkRequiredParams(config);
        return getDataOrEmptyList(RedisCodeUtil.getDataList(config.getUniqueKey(), 0, -1));
    }

    @Override
    public PageData<Map<String, Object>> getLeftItemsPage(ShuttleBoxConfig config) {
        checkRequiredParams(config);

        // 查询左边所有的数据
        List<Map<String, Object>> leftItems = getLeftItems(config);
        if(CollectionUtils.isEmpty(leftItems)) {
            return new PageData<>(leftItems, config.getPageNum(), config.getPageSize());
        }

        // 查询右边已选择的数据
        List<Map<String, Object>> rightItems = getRightItems(config);
        if(CollectionUtils.isEmpty(rightItems)) {
            return new PageData<>(leftItems, config.getPageNum(), config.getPageSize());
        }

        // 过滤掉右边已选择的数据
        filterOutItems(rightItems, leftItems, config.getItemKey());
        return new PageData<>(leftItems, config.getPageNum(), config.getPageSize());
    }

    @Override
    public PageData<Map<String, Object>> getRightItemsPage(ShuttleBoxConfig config) {
        checkRequiredParams(config);
        return new PageData<>(getRightItems(config), config.getPageNum(), config.getPageSize());
    }

    @Override
    @SuppressWarnings({ "unchecked", "rawtypes" })
    public void addItems2Right(ShuttleBoxConfig config) {
        checkRequiredParams(config);

        // 如果选择了全部, 则全部添加到缓存
        if(ShuttleBoxConstant.IS_ALL_Y.equals(config.getIsAll())) {
            List<Map<String, Object>> leftItems = getLeftItems(config);
            limitRightItemsSize(leftItems);
            setRedisDataList(config, leftItems);
        }
        // 如果不是选择了全部, 则添加追加到已有的List末尾
        else {
            if(!CollectionUtils.isEmpty(config.getAddRightList())) {
                List<Map<String, Object>> allItemList = Lists.newArrayList(getRightItems(config));
                allItemList.addAll(config.getAddRightList());
                limitRightItemsSize(allItemList);
                setRedisDataList(config, allItemList);
            }
        }
    }

    @Override
    @SuppressWarnings({ "unchecked", "rawtypes" })
    public void deleteItems2Left(ShuttleBoxConfig config) {
        checkRequiredParams(config);

        // 如果选择了全部, 则删除缓存中的全部数据
        if(ShuttleBoxConstant.IS_ALL_Y.equals(config.getIsAll())) {
            deleteRedisDataList(config);
        }
        // 如果不是选择了全部, 则根据itemId删除缓存中的数据
        else {
            List<Map<String, Object>> rightItems = getRightItems(config);
            if(CollectionUtils.isEmpty(rightItems)) {
                return;
            }

            // 过滤掉右边已选择的数据
            if(!CollectionUtils.isEmpty(config.getDeleteLeftList())) {
                filterOutItems(config.getDeleteLeftList(), rightItems, config.getItemKey());
                if(!CollectionUtils.isEmpty(rightItems)) {
                    setRedisDataList(config, rightItems);
                } else {
                    deleteRedisDataList(config);
                }
            }
        }
    }

    /** 获取data或者空的结果集 */
    protected List<Map<String, Object>> getDataOrEmptyList(List redisDataList) {
        return CollectionUtils.isEmpty(redisDataList)? new ArrayList<>() : redisDataList;
    }

    /** 根据itemId分组 */
    protected Map<String, Map<String, Object>> getItemIdMap(List<Map<String, Object>> dataList, String itemKey) {
        Map<String, Map<String, Object>> dataMap = new HashMap<>();
        for (Map<String, Object> data : dataList) {
            dataMap.put(MapUtils.getString(data, itemKey), data);
        }
        return dataMap;
    }

    /** 过滤掉右边已选择的数据 */
    protected void filterOutItems(List<Map<String, Object>> sourceList, List<Map<String, Object>> targetList, String itemKey) {
        Map<String, Map<String, Object>> itemIdMap = getItemIdMap(sourceList, itemKey);
        targetList.removeIf(leftItem -> itemIdMap.containsKey(MapUtils.getString(leftItem, itemKey)));
    }

    /** 设置 Redis List 缓存*/
    private void setRedisDataList(ShuttleBoxConfig config, List<Map<String, Object>> allItemList) {
        RedisCodeUtil.setDataList(config.getUniqueKey(), allItemList, config.getRedisTimeout(), TimeUnit.SECONDS);
    }

    /** 删除 Redis List 缓存*/
    private void deleteRedisDataList(ShuttleBoxConfig config) {
        RedisCodeUtil.deleteKeys(config.getUniqueKey());
    }
}
```

###### 4）建立模型 | 抽取 Guava Cache 抽象类

Guava Cache 没作对应的抽象，不过可以参考下下面 Guava Cache 的代码，思路是实现利用 Guava Cache 分页获取左边数据（保持不变，在 MySQL，但要排除右边的数据）、获取右边全部数据（放缓存）、分页获取右边的数据、删除左边的数据并放置到右边（加入缓存）、删除右边的数据（删除缓存，`localCache.invalidate(key);`）并放置回左边，其他和 Redis 的一样。

```java
@Slf4j
@Component
public class Category3CodeNameLocalCache {

    private static final String LOCAL_CACHE_KEY = "CATEGORY3_CODE_NAME_LOCAL_CACHE";

    @Autowired
    private CategoryFeignClient categoryFeignClient;

    /**
     * 获取所有小类编码-名称映射
     *
     * @return
     */
    public Map<String, String> getAllCategory3Info() {
        return getAllCategory3InfoInCache(LOCAL_CACHE_KEY);
    }

    /**
     * 10分钟本地缓存, 缓存所有小类编码-名称映射
     */
    private final LoadingCache<String, Map<String, String>> localCache = CacheBuilder.newBuilder()
            .expireAfterWrite(10, TimeUnit.MINUTES)
            .build(new CacheLoader<String, Map<String, String>>() {
                @Override
                public Map<String, String> load(String localCacheKey) {
                    return getFeignAllCategory3Info(localCacheKey);
                }
            });

    /**
     * 从缓存中获取所有小类编码-名称映射
     */
    private Map<String, String> getAllCategory3InfoInCache(String localCacheKey) {
        try {
            return localCache.get(localCacheKey);
        } catch (Exception e) {
            log.error("查询本地缓存失败: ", e);
            return getFeignAllCategory3Info(localCacheKey);
        }
    }

    /**
     * 查询所有小类编码-名称映射
     */
    @SuppressWarnings({"rawtypes", "unchecked"})
    private Map<String, String> getFeignAllCategory3Info(String localCacheKey) {
        // 构造查询参数
        Map<String, Object> params = new HashMap<>();
        params.put("categoryType", CategoryTypeEnum.SMALL_CATEGORY.getValue());

        // 发起Feign远程调用 => 查询所有小类编码名称
        log.info("查询所有小类编码名称: params={}", JSONObject.toJSONString(params));
        Object responseData = categoryFeignClient.queryCateInfoByCode(params);
        log.info("查询所有小类编码名称: responseData={}", JSONObject.toJSONString(responseData));

        // 获取返回结果
        Map<String, String> category3CodeNameMap = new HashMap<>();
        LinkedHashMap<String, Object> responseLinkedHashMap = (LinkedHashMap<String, Object>) responseData;
        List<LinkedHashMap<String, Object>> category3list = (List<LinkedHashMap<String, Object>>) responseLinkedHashMap.get("data");
        if (!org.springframework.util.CollectionUtils.isEmpty(category3list)) {
            for (LinkedHashMap<String, Object> category3 : category3list) {
                category3CodeNameMap.put(Utils.objToStr(category3.get("categoryCode3")), Utils.objToStr(category3.get("categoryName3")));
            }
        }

        return category3CodeNameMap;
    }
}
```

###### 5）建立模型 | 抽取 MySQL 抽象类

MySQL 没作对应的抽象，不过思路是加多一张表存放右边数据，即分页获取左边数据（保持不变，在 MySQL，但要排除右边的数据）、获取右边全部数据（新表）、分页获取右边的数据、删除左边的数据并放置到右边（加入新表）、删除右边的数据（删除新表对应的数据）并放置回左边，其他和 Redis 的一样。

###### 6）具体实现 | 大类穿梭框

生产上，大类一共 24 条数据，所以放 Redis、Guava Cache 都可以，这里是放在了 Redis 上，不过面试时要讲放在了 Guava Cache，并实现了获取全部左边数据以及分页获取左边数据（基于 MySQL 分页，内存占用小也可以使用抽象类的，默认在内存分页），不过对限制方法做了空的实现。

```java
@Service
@DataSource(nodeName = "srmBase")
public class Category1ShuttleBoxServiceImpl extends AbstractRedisShuttleBoxServiceImpl implements Category1ShuttleBoxService {

    private static final Logger logger = LoggerFactory.getLogger(Category1ShuttleBoxServiceImpl.class);

    @Autowired
    private ItemsService itemsService;

    @Override
    public List<Map<String, Object>> getLeftItems(ShuttleBoxConfig config) {
        logger.info("全部查询左边待选择数据: config={}", JSONObject.toJSONString(config));

        SingleTypeCategoryBO singleTypeCategoryBO = new SingleTypeCategoryBO();
        singleTypeCategoryBO.setCategoryNameConcat(((Category1ShuttleBoxConfig) config).getCategoryNameConcat());

        // 根据物料名称模糊查询大类: CATEGORY_TYPE = 1 & LANGUAGE = 'zh-CN'
        return getDataOrEmptyList(BeanToMapUtil.listConvert(itemsService.queryBigCategorys(singleTypeCategoryBO)));
    }

    @Override
    public PageData<Map<String, Object>> getLeftItemsPage(ShuttleBoxConfig config) {
        logger.info("分页查询左边待选择数据: config={}", JSONObject.toJSONString(config));

        // 全部查询右边待选择数据
        List<Map<String, Object>> rightItems = getRightItems(config);

        // 构造查询条件 => 覆盖抽象父类(内存过滤), 使用MySQL进行过滤
        SingleTypeCategoryBO singleTypeCategoryBO = new SingleTypeCategoryBO();
        singleTypeCategoryBO.setCategoryNameConcat(((Category1ShuttleBoxConfig) config).getCategoryNameConcat());
        singleTypeCategoryBO.setPageNum(config.getPageNum());
        singleTypeCategoryBO.setPageSize(config.getPageSize());

        // 如果右边不为空, 则获取对应的过滤参数
        if(!CollectionUtils.isEmpty(rightItems)) {
            Map<String, Map<String, Object>> itemIdMap = getItemIdMap(rightItems, config.getItemKey());
            singleTypeCategoryBO.setCategoryCodeExcludeList(Lists.newArrayList(itemIdMap.keySet()));
        }

        // MySQL过滤已存在的右边物料编码
        PageInfo<SingleTypeCategoryVO> categoryVOPageInfo = itemsService.queryBigCategorysPage(singleTypeCategoryBO);
        return new PageData<>(
                BeanToMapUtil.listConvert(getDataOrEmptyList(categoryVOPageInfo.getList())),
                categoryVOPageInfo.getPageNum(),
                categoryVOPageInfo.getPageSize(),
                categoryVOPageInfo.getPages(),
                categoryVOPageInfo.getTotal()
        );
    }

    @Override
    public void limitRightItemsSize(List<Map<String, Object>> dataList) {

    }
}
```

###### 7）具体实现 | 省份穿梭框

生产上，省份一共 530 条数据，所以放 Redis 在了 Redis 上并实现了获取全部左边数据以及分页获取左边数据（基于抽象类的，默认在内存分页），不过对限制方法做了空的实现。

```java
@Service
@DataSource(nodeName = "srmBase")
public class ProvinceShuttleBoxServiceImpl extends AbstractRedisShuttleBoxServiceImpl implements ProvinceShuttleBoxService {

    private static final Logger logger = LoggerFactory.getLogger(ProvinceShuttleBoxServiceImpl.class);

    @Autowired
    private DictionaryLineService dictionaryLineService;

    @Override
    public List<Map<String, Object>> getLeftItems(ShuttleBoxConfig config) {
        logger.info("全部查询左边待选择数据: config={}", JSONObject.toJSONString(config));

        try {
            // 根据参数获取字典条目
            return dictionaryLineService.queryDictionaryType(getProvinceParamsMap((ProvinceShuttleBoxConfig) config));
        } catch (Exception e) {
            return new ArrayList<>();
        }
    }

    /** 获取省份穿梭框查询参数 */
    private Map<String, Object> getProvinceParamsMap(ProvinceShuttleBoxConfig config) {
        Map<String, Object> params = new HashMap<>();
        params.put("dictionaryCode", config.getDictionaryCode());
        params.put("entryLanguage", config.getEntryLanguage());
        params.put("entryFlag", config.getEntryFlag());
        params.put("entryName", config.getLabel());
        return params;
    }

    @Override
    public void limitRightItemsSize(List<Map<String, Object>> dataList) {

    }
}
```

###### 8）具体实现 | 前端实现

前端实现分为几步：建立左上角搜索框、左边分页表格、右边分页表格、中间全部添加、中间全部删除按钮，然后调用后端实现分页查询左边、分页查询右边、点击时左边添加到右边、全部添加左边到右边、点击时右边删除到左边的接口、全部删除右边到左边即可。

```vue
<template>
    <div>
        <Row>
            <Form ref="form1" :label-width="120" :model="basicInfo" @submit.native.prevent>
                <Col span="8" style="margin-right: 10px">
                    <FormItem label="大类名称">
                        <Input v-model="categoryNameConcat" @on-enter="queryLeftItemsPage"></Input>
                    </FormItem>
                </Col>
                <Col span="8" style="margin-top: 1px">
                    <Button type="primary" size="small" @click="queryLeftItemsPage">搜索</Button>
                </Col>
            </Form>
        </Row>
        <Row style="display: flex; justify-content: center">
            <Col span="10">
                <Table
                    size="small"
                    height="334"
                    highlight-row
                    border
                    ref="left"
                    :columns="this.left.columns"
                    :data="this.left.data"
                    :loading="this.left.loading"
                    @on-selection-change="handleLeftSelect"
                ></Table>
                <div style="text-align: center; margin-top: 10px" v-if="this.left.total > 0">
                    <Page
                        :total="this.left.total"
                        :page-size="this.left.pageSize"
                        :current="this.left.pageNum"
                        size="small"
                        @on-change="changeLeftPageNum"
                    />
                </div>
            </Col>
            <Col span="3" style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 340px">
                <Button style="margin-bottom: 20px" @click="doHandleLeftSelect([], 'Y')">全部添加</Button>
                <Button
                    @click="
                        () => {
                            this.right.data = [];
                            this.right.total = 0;
                            this.doHandleRightDelete([], 'Y');
                        }
                    "
                >全部删除
                </Button
                >
            </Col>
            <Col span="10">
                <Table
                    size="small"
                    height="334"
                    highlight-row
                    border
                    ref="right"
                    :columns="this.right.columns"
                    :data="this.right.data"
                    :loading="this.right.loading"
                ></Table>
                <div style="text-align: center; margin-top: 10px" v-if="this.right.total > 0">
                    <Page
                        :total="this.right.total"
                        :page-size="this.right.pageSize"
                        :current="this.right.pageNum"
                        size="small"
                        @on-change="changeRightPageNum"
                    />
                </div>
            </Col>
        </Row>
        <Row>
            <Col span="24" style="text-align:right;">
                <Button type="ghost" size="small" class="mg-l-10" @click="cancel">取消</Button>
                <Button type="primary" size="small" class="mg-l-10" @click="confirm">确定</Button>
            </Col>
        </Row>
    </div>
</template>
<script>
    import axios from "axios";
    import mAssemblyTable from "@/components/awesome/page/assembly_table";

    export default {
        name: "reviewCategory1ShuttleBoxModal",
        components: {mAssemblyTable},
        created() {

        },
        mounted() {
            this.queryLeftItemsPage();
            this.queryRightItemsPage();
        },
        computed: {},
        props: [],
        data() {
            return {
                categoryNameConcat: "",
                loading: false,
                basicInfo: {},
                left: {
                    columns: [
                        {
                            title: "选择",
                            type: "selection",
                            align: "center",
                            fixed: "left",
                            width: 60,
                        },
                        {
                            renderHeader: (h, params) => {
                                return h("div", {}, "大类名称" + "(" + this.left.total + ")");
                            },
                            title: "大类名称",
                            key: "categoryNameConcat",
                            align: "center",
                            width: 300,
                        },
                    ],
                    data: [],
                    pageNum: 1,
                    pageSize: 15,
                    total: 0,
                    loading: false,
                },
                right: {
                    columns: [
                        {
                            renderHeader: (h, params) => {
                                return h("div", {}, "已选" + "(" + this.right.total + ")");
                            },
                            title: "已选",
                            key: "categoryNameConcat",
                            width: 300,
                            align: "center",
                        },
                        {
                            title: "操作",
                            align: "center",
                            width: 60,
                            fixed: "right",
                            render: (h, params) => {
                                return (
                                    <a onClick={
                                        () => {
                                            this.right.data.splice(params.index, 1);
                                            this.doHandleRightDelete([params.row], "N").then((res) => {
                                                this.queryRightItemsPage();
                                                this.queryLeftItemsPage();
                                            });
                                        }
                                    }> X </a>
                                )
                            },
                        },
                    ],
                    data: [],
                    pageNum: 1,
                    pageSize: 15,
                    total: 0,
                    loading: false,
                },
            };
        },
        methods: {
            // 分页查询左边待选择数据
            queryLeftItemsPage() {
                let params = {
                    pageNum: this.left.pageNum,
                    pageSize: this.left.pageSize,
                    categoryNameConcat: this.categoryNameConcat || null,// 搜索条件
                };
                this.left.loading = true;
                return axios.post("/srmbase/shuttleBox/category1/getLeftItemsPage", params)
                    .then((res) => {
                        this.left.loading = false;
                        if (res.data.status === 0) {
                            this.left.data = res.data.data.list;
                            this.left.total = res.data.data.total;
                        } else {
                            this.$Modal.error({
                                title: this.$t("srm.common.warn"),
                                content: res.data.msg,
                            });
                        }
                    })
                    .catch((err) => {
                        this.left.loading = false;
                        this.$Modal.error({
                            title: this.$t("srm.common.warn"),
                            content: this.$t("srm.common.error1") + JSON.stringify(err),
                        });
                    });
            },
            // 左边页码切换
            changeLeftPageNum(pageNum) {
                this.left.pageNum = pageNum;
                this.queryLeftItemsPage();
            },
            // 左边选择事件
            handleLeftSelect(list) {
                list.forEach((item) => {
                    this.left.data.forEach((k, i) => {
                        if (item.categoryCodeConcat === k.categoryCodeConcat) {
                            this.left.data.splice(i, 1);
                            return true;
                        }
                    });
                });

                this.right.data.push(...list);
                this.right.total += list.length;
                this.doHandleLeftSelect(list, "N")
                    .then((res) => {
                        this.queryRightItemsPage();
                });
            },
            // 处理左边选择事件
            doHandleLeftSelect(list, isAll) {
                let params = {
                    isAll: isAll,
                };
                if (isAll === "Y") {
                    this.left.loading = true;
                    params.categoryNameConcat = this.categoryNameConcat;
                } else {
                    params.addRightList = list;
                }
                return axios.post("/srmbase/shuttleBox/category1/addItems2Right", params)
                    .then((res) => {
                        this.left.loading = false;
                        if (res.data.status == 0) {
                            this.queryLeftItemsPage();
                            if (isAll === "Y") {
                                this.right.pageNum = 1;
                                this.queryRightItemsPage();
                            }
                            return res;
                        } else {
                            this.$Modal.error({
                                title: this.$t("srm.common.warn"),
                                content: res.data.msg,
                            });
                        }
                    })
                    .catch((err) => {
                        this.left.loading = false;
                        this.$Modal.error({
                            title: this.$t("srm.common.warn"),
                            content: this.$t("srm.common.error1") + err.toString(),
                        });
                    });
            },
            // 分页查询右边待选择数据
            queryRightItemsPage() {
                let params = {
                    pageNum: this.right.pageNum,
                    pageSize: 15,
                };
                this.right.loading = true;
                return axios.post("/srmbase/shuttleBox/category1/getRightItemsPage", params)
                    .then((res) => {
                        this.right.loading = false;
                        if (res.data.status === 0) {
                            this.right.data = res.data.data.list;
                            this.right.total = res.data.data.total;
                            return res;
                        } else {
                            this.$Modal.error({
                                title: this.$t("srm.common.warn"),
                                content: res.data.msg,
                            });
                        }
                    })
                    .catch((err) => {
                        this.right.loading = false;
                        this.$Modal.error({
                            title: this.$t("srm.common.warn"),
                            content: this.$t("srm.common.error1") + JSON.stringify(err),
                        });
                    });
            },
            // 右边页码切换
            changeRightPageNum(pageNum) {
                this.right.pageNum = pageNum;
                this.queryRightItemsPage();
            },
            // 处理右边删除事件
            doHandleRightDelete(list, isAll) {
                let params = {
                    isAll: isAll,
                    deleteLeftList: list,
                };
                return axios.post("/srmbase/shuttleBox/category1/deleteItems2Left", params)
                    .then((res) => {
                        if (res.data.status == 0) {
                            if (isAll === "Y") {
                                this.right.pageNum = 1;
                                this.queryLeftItemsPage();
                            }
                            return res
                        } else {
                            this.$Modal.error({
                                title: this.$t("srm.common.warn"),
                                content: res.data.msg,
                            });
                        }
                    })
                    .catch((err) => {
                        this.block.loading = false;
                        this.$Modal.error({
                            title: this.$t("srm.common.warn"),
                            content: this.$t("srm.common.error1") + err.toString(),
                        });
                    });
            },
            // 取消
            cancel() {
                this.$emit('handleCancel', '');
            },
            // 确定
            confirm() {
                axios.post("/srmbase/shuttleBox/category1/getRightItems", {})
                .then((res) => {
                    if (res.data.status === 0) {
                        this.$emit('handleConfirm', res.data.data);
                    } else {
                        this.$Modal.error({
                            title: this.$t("srm.common.warn"),
                            content: res.data.msg,
                        });
                    }
                })
                .catch((err) => {
                    this.$Modal.error({
                        title: this.$t("srm.common.warn"),
                        content: this.$t("srm.common.error1") + JSON.stringify(err),
                    });
                });
            },
        },
    };
</script>
```

##### R | Result

通过模型抽象，实现基于 Guava Cache / Redis / MySQL 后端分页的通用穿梭框组件，约节省 60% 小类、大类、省份等穿梭框组件的开发时间。

- 60% 是因为：一共分为 5 步，实现左边分页、右边分页、左边添加、右边删除、前端实现 4 步，但基于通用穿梭框开发，可以只实现前端和全部查询左边/分页查询左边即可，省了 3 步，所以为节省了 60%。

#### 供应商画像同步

##### S | Situation

供应商画像，可查询全集团所有材料供应商的画像信息，画像内容为精简和浓缩后的供应商业务数据，包括交易金额、品质、考核、绩效、分级、风险等。

##### T | Task

业务规定 15 天同步一次即可，允许数据延迟，因此需要实现供应商画像定时同步。

##### A | Action

###### 1）需求分析 | 绘制业务时序图

共划分为 13 个定时任务，详情见《GSRM_供应商画像_业务时序图_20211214_V4.pdf》。

![1644908898528](D:\MyData\yaocs2\AppData\Roaming\Typora\typora-user-images\1644908898528.png)

###### 2）模型建立 | 接口抽象

根据要求，为了能够让同一批的每个小任务不会重复执行，即同步成功的不用再同步了，所以设计了一个判断是否同步成功的方法，然后还有一个执行同步任务的方法，用来执行具体逻辑。

```java
public interface ChainTask {

    /**
     * 执行同步任务
     *
     * @param context
     * @return
     */
    boolean execute(ChainTaskContext context);

    /**
     * 判断是否已同步成功
     *
     * @param context
     * @return
     */
    boolean isSynced(ChainTaskContext context);
}
```

###### 3）模型建立 | 定时任务实现抽象

由于想要的是链式执行的效果，所以又抽象了一层抽象类，来存放共有的属性，比如链式任务的索引，用于记录异常是任务执行的序号，下一个链式任务，用于串起链式任务，和上下文，用于减少共有的 I/O 操作，以提升性能，然后把执行方法和判断方法留给子类去实现。

```java
public abstract class AbstractChainTask implements ChainTask {

    /**
     * 执行链任务索引
     */
    private int taskIndex;

    /**
     * 下一个同步任务
     */
    private ChainTask nextTask;

    /**
     * 同步任务执行上下文
     */
    private ChainTaskContext context;

    public int getTaskIndex() {
        return taskIndex;
    }

    public void setTaskIndex(int taskIndex) {
        this.taskIndex = taskIndex;
    }

    public ChainTask getNextTask() {
        return nextTask;
    }

    public void setNextTask(ChainTask nextTask) {
        this.nextTask = nextTask;
    }

    public ChainTaskContext getContext() {
        return context;
    }

    public void setContext(ChainTaskContext context) {
        this.context = context;
    }
}
```

###### 4）模型建立 | 同步式定时任务抽象

1. 同步式定时任务抽象类，实现抽象类，以满足链式执行，实现执行方法，来抽取共有的同步逻辑，即如果判断到该任务已执行了，那么就直接往后执行就可以了，否则先执行当前任务，再执行下一个任务。
2. 不过关键的是，**不要抛出异常**，所以还抽象了一个异常回调的方法，用于给子类去实现对应的异常处理（比如记录日志）。
3. 另外，当前抽象类并不知道子类具体的业务执行，所以还需要抽象一个具体的执行方法，留给具体的子类去做对应的实现。

```java
public abstract class AbstractSyncChainTask extends AbstractChainTask {

    @Override
    public boolean execute(ChainTaskContext context) {
        Assert.notNull(context, "context不能为空!");
        setContext(context);

        // 如果本任务已完成执行, 则继续链式执行
        if (isSynced(context)) {
            return getNextTask() == null || getNextTask().execute(context);
        }

        boolean currentResult;
        try {
            // 如果未完成同步的, 则同步执行当前任务
            currentResult = syncExecute(context);
        } catch (Exception e) {
            // 本任务执行发生异常, 则处理异常 => 不向上抛出!
            boolean exceptionHandleResult = afterException(context, e);

            // 再链式继续执行剩余任务
            if(getNextTask() != null) {
                getNextTask().execute(context);
            }

            // 最后才返回本任务异常处理结果
            return exceptionHandleResult;
        }

        // 本任务执行未发生异常, 则继续链式执行
        return currentResult && (getNextTask() == null || getNextTask().execute(context));
    }

    /**
     * 同步执行任务 抽象方法
     *
     * @param context
     * @return
     */
    protected abstract boolean syncExecute(ChainTaskContext context);

    /**
     * 当前任务执行异常处理 抽象方法
     *
     * @param context
     * @param e
     * @return
     */
    protected abstract boolean afterException(ChainTaskContext context, Exception e);
}
```

###### 5）模型建立 | 异步式定时任务抽象

1. 异步式定时任务抽象类，实现抽象类，以满足链式执行，实现执行方法，来抽取共有的同步逻辑，即如果判断到该任务已执行了，那么就直接往后执行就可以了，否则先把当前任务丢到了线程池中，再执行下一个任务。
2. 其中，由于需要异步执行，所以还需要实现 Callable 接口，以及持有一个线程池引用，以实现线程池复用，然后把实现 Callable 接口的具体逻辑，留给具体的子类去做对应的实现，而不需要像同步那样，再抽象一个具体的执行方法了。
3. 不过关键的是，**不要抛出异常**，所以还抽象了一个异常回调的方法，用于给子类去实现对应的异常处理（比如记录日志）。

```java
public abstract class AbstractAsyncChainTask extends AbstractChainTask implements Callable<Boolean> {

    /**
     * 异步执行线程池
     */
    private ExecutorService executorService;

    public AbstractAsyncChainTask(ExecutorService executorService) {
        this.executorService = executorService;
    }

    @Override
    public boolean execute(ChainTaskContext context) {
        Assert.notNull(context, "context不能为空!");
        setContext(context);

        // 如果本任务已完成执行, 则继续链式执行
        if (isSynced(context)) {
            return getNextTask() == null || getNextTask().execute(context);
        }

        // 如果未完成同步的, 则异步提交当前任务, 再继续链式执行
        Future<Boolean> future = this.executorService.submit(this);
        boolean otherResult = getNextTask() == null || getNextTask().execute(context);

        try {
            // 最后, 同步获取当前任务结果, 如果抛出异常则返回false, 否则返回true
            return future.get() && otherResult;
        } catch (Exception e) {
            // 本任务执行发生异常, 则处理异常 => 不向上抛出!
            return afterException(context, e);
        }
    }

    /**
     * 当前任务执行异常处理 抽象方法 抽象方法
     *
     * @param context
     * @param e
     * @return
     */
    protected abstract boolean afterException(ChainTaskContext context, Exception e);
}
```

###### 6）同步任务实现 | 统计供应商基本信息

内部类实现高内聚，且可以实现 ServiceImpl IOC 填充的 vendorPortraitTaskKanbanService 等动态代理类，从而实现业务逻辑。

```java
@Service
@DataSource(nodeName = "srmPos")
public class VendorPortraitServiceImpl implements VendorPortraitService {
    @Autowired
    private VendorPortraitTaskKanbanService vendorPortraitTaskKanbanService;
    
    /** 统计供应商基本信息 => 同步执行 */
    public class SyncBaseTask extends AbstractSyncChainTask {

        @Override
        public boolean isSynced(ChainTaskContext context) {
            return TaskStatusEnum.DONE.getValue().equals(context.getKanban().getBaseTask());
        }

        @Override
        protected boolean syncExecute(ChainTaskContext context) {
            return vendorPortraitTaskKanbanService.syncVendorBasicInfo(context);
        }

        @Override
        protected boolean afterException(ChainTaskContext context, Exception e) {
            logger.error("统计供应商基本信息异常! taskIndex={}, taskClassName={}, context={}, e={}", this.getTaskIndex(), this.getClass().getName(), JSONObject.toJSON(context), e);
            context.addTaskFailReason("统计供应商基本信息异常", this.getTaskIndex(), this.getClass().getName(), e);
            return false;
        }
    }

    @Override
    public ChainTask getSyncBaseTask() {
        return new SyncBaseTask();
    }
}
```

###### 7）异步任务实现 | 统计合作单位

内部类实现高内聚，且可以实现 ServiceImpl IOC 填充的 vendorPortraitTaskKanbanService 等动态代理类，从而实现业务逻辑。

```java
@Service
@DataSource(nodeName = "srmPos")
public class VendorPortraitServiceImpl implements VendorPortraitService {
    @Autowired
    private VendorPortraitTaskKanbanService vendorPortraitTaskKanbanService;
    
    /** 统计合作单位 => 异步执行 */
    public class AsyncCoUnitTask extends AbstractAsyncChainTask {

        public AsyncCoUnitTask(ExecutorService executorService) {
            super(executorService);
        }

        @Override
        public boolean isSynced(ChainTaskContext context) {
            return TaskStatusEnum.DONE.getValue().equals(context.getKanban().getCoUnitTask());
        }

        @Override
        public Boolean call() throws Exception {
            return vendorPortraitTaskKanbanService.syncCoUnitInfo(getContext());
        }

        @Override
        protected boolean afterException(ChainTaskContext context, Exception e) {
            logger.error("统计合作单位异常! taskIndex={}, taskClassName={}, context={}, e={}", this.getTaskIndex(), this.getClass().getName(), JSONObject.toJSON(context), e);
            context.addTaskFailReason("统计合作单位异常", this.getTaskIndex(), this.getClass().getName(), e);
            return false;
        }
    }

    @Override
    public ChainTask getAsyncCoUnitTask(ExecutorService executorService) {
        return new AsyncCoUnitTask(executorService);
    }
}
```

###### 8）任务构造 | 工厂模式

使用工厂模式，简化同步任务的构造，只需要传入具体的枚举类，工厂就可以生产出对应的实例。

```java
@Slf4j
public class ChainTaskFactory {
    /** 异步执行线程池 => 默认固定线程数: 2021-12-22 只需要统计10个任务 */
    private static final ExecutorService CHAIN_TASK_CACHE_THREAD_POOL = new ThreadPoolExecutor(
            0, Math.min(10, Runtime.getRuntime().availableProcessors()),
            5, TimeUnit.MINUTES,
            new SynchronousQueue<>(),
            new ThreadFactoryBuilder().setNameFormat("chain-task-thread-%d").build(),
            new ThreadPoolExecutor.CallerRunsPolicy()
    );

    /**
     * 根据枚举类, 获取对应的链式同步任务实现
     *
     * @param chainTaskEnum
     * @return
     */
    public static ChainTask getChainTask(ChainTaskEnum chainTaskEnum) {
        switch (chainTaskEnum) {
            // 统计供应商基本信息
            case BASE_TASK:
                return SpringBeanUtil.getBean(VendorPortraitService.class).getSyncBaseTask();

            // 统计图标
            case ICON_TASK:
                return SpringBeanUtil.getBean(VendorPortraitService.class).getAsyncIconTask(CHAIN_TASK_CACHE_THREAD_POOL);

            // 统计合作单位
            case CO_UNIT_TASK:
                return SpringBeanUtil.getBean(VendorPortraitService.class).getAsyncCoUnitTask(CHAIN_TASK_CACHE_THREAD_POOL);

            // 统计美的历程
            case COURSE_TASK:
                return SpringBeanUtil.getBean(VendorPortraitCourseService.class).getAsyncCourseTask(CHAIN_TASK_CACHE_THREAD_POOL);

            // 统计风险雷达
            case RISK_TASK:
                return SpringBeanUtil.getBean(VendorPortraitRiskService.class).getAsyncRiskTask(CHAIN_TASK_CACHE_THREAD_POOL);

            // 统计招投标信息
            case AUCTION_TASK:
                return SpringBeanUtil.getBean(VendorPortraitAuctionService.class).getAsyncAuctionTask(CHAIN_TASK_CACHE_THREAD_POOL);

            // 统计红黄牌
            case BOOKING_TASK:
                throw new UnsupportedOperationException(String.format("直接查表不需要统计! type=%s, name=%s", chainTaskEnum.getType(), chainTaskEnum.getName()));

            // 统计供应商考核
            case ASSE_TASK:
                return SpringBeanUtil.getBean(VendorPortraitAsseService.class).getAsyncAsseTask(CHAIN_TASK_CACHE_THREAD_POOL);

            // 统计绩效评价
            case SCORE_TASK:
                throw new UnsupportedOperationException(String.format("直接查表不需要统计! type=%s, name=%s", chainTaskEnum.getType(), chainTaskEnum.getName()));

            // 统计供应商分级
            case LEVEL_TASK:
                throw new UnsupportedOperationException(String.format("直接查表不需要统计! type=%s, name=%s", chainTaskEnum.getType(), chainTaskEnum.getName()));

            // 统计品类编码数量
            case CATE_TASK:
                return SpringBeanUtil.getBean(VendorPortraitCateService.class).getAsyncCateTask(CHAIN_TASK_CACHE_THREAD_POOL);

            // 统计采购金额
            case DET_TASK:
                throw new UnsupportedOperationException(String.format("直接查表不需要统计! type=%s, name=%s", chainTaskEnum.getType(), chainTaskEnum.getName()));

            // 统计词云
            case WORD_TASK:
                throw new UnsupportedOperationException(String.format("直接查表不需要统计! type=%s, name=%s", chainTaskEnum.getType(), chainTaskEnum.getName()));

            default:
                throw new UnsupportedOperationException(String.format("未定义的链式任务类型! type=%s, name=%s", chainTaskEnum.getType(), chainTaskEnum.getName()));
        }
    }
}
```

###### 9）任务构造 | 建造者模式

使用建造者，来构造执行链，方便后续定时任务的随意搭配。

```java
@Slf4j
public class ChainTaskFactory {
    /**
     * 同步任务执行链建造者
     */
    public static class ChainTaskBuilder {

        /** 执行链任务索引 */
        private AtomicInteger taskIndexCounter = new AtomicInteger(0);
        /** 链式任务头结点 */
        private ChainTask head;
        /** 链式任务尾结点 */
        private ChainTask tail;

        /**
         * 执行链追加同步任务
         *
         * @param next
         * @return
         */
        public ChainTaskBuilder addChainTask(ChainTask next) {
            Assert.isTrue(next instanceof AbstractChainTask, "next必须继承AbstractChainTask!");

            // 设置执行链任务索引
            ((AbstractChainTask) next).setTaskIndex(taskIndexCounter.getAndIncrement());

            // 执行链追加同步任务
            if (this.head == null) {
                this.head = this.tail = next;
            } else {
                ((AbstractChainTask) this.tail).setNextTask(next);
                this.tail = next;
            }

            return this;
        }

        /**
         * 构造并返回同步任务执行链
         *
         * @return
         */
        public ChainTask build() {
            return this.head;
        }
    }
}
```

###### 10）任务构造 | 创建执行链

先把看板塞到上下文中，使用工厂 + 建造者构造执行链，然后传入上下文启动执行链，成功执行后打标记录。

```java
// 构造执行上下文
ChainTaskContext context = new ChainTaskContext(currentKanban);

// 构造同步任务执行链
ChainTask chainTask = new ChainTaskFactory.ChainTaskBuilder()
    // 统计供应商基本信息
    .addChainTask(ChainTaskFactory.getChainTask(ChainTaskEnum.BASE_TASK))
    // 统计图标
    .addChainTask(ChainTaskFactory.getChainTask(ChainTaskEnum.ICON_TASK))
    // 统计合作单位
    .addChainTask(ChainTaskFactory.getChainTask(ChainTaskEnum.CO_UNIT_TASK))
    // 统计美的历程
    .addChainTask(ChainTaskFactory.getChainTask(ChainTaskEnum.COURSE_TASK))
    // 统计风险雷达
    .addChainTask(ChainTaskFactory.getChainTask(ChainTaskEnum.RISK_TASK))
    // 统计招投标信息
    .addChainTask(ChainTaskFactory.getChainTask(ChainTaskEnum.AUCTION_TASK))
    // 统计供应商考核
    .addChainTask(ChainTaskFactory.getChainTask(ChainTaskEnum.ASSE_TASK))
    // 统计品类编码数量
    .addChainTask(ChainTaskFactory.getChainTask(ChainTaskEnum.CATE_TASK))
    .build();

// 链式执行同步任务 => 如果某个小任务已执行过了, 则不会继续执行
if(chainTask.execute(context)) {
    markKanbanIsFullySynced(context);
    manualAck(acknowledgment, "消费供应商画像任务: 链式执行同步任务成功! businessKey=" + taskMsg.getBusinessKey());
    return;// 小任务已全部同步完毕, 无需重新消费
}
```

###### 11）架构设计 | Kafka 投递与消费

使用 Kafka 可以定时任务触发统一发布消息，然后被多台服务器均匀消费、分布式消费，从而保证效率和

- **消息投递**：包括自动投递和手动投递，自动投递的则投递美的集团【批准】状态下所有的【材料】供应商 & 供应商画像中的天眼查供应商，手动投递的根据传入的【材料】【批准】的供应商编码进行投递。

```java
/** 投递供应商画像同步任务 */
private List<String> sendSyncableKanban(List<VendorPortraitTaskKanban> kanbanList, boolean isTest) {
    String jsonData;
    List<String> failBusinessKeyList = new LinkedList<>();
    final String topic = isTest? VendorPortraitConstant.KAFKA_TEST_TOPIC : VendorPortraitConstant.KAFKA_TOPIC;

    for (VendorPortraitTaskKanban kanban : kanbanList) {
        VendorPortraitTaskMsg taskMsg = new VendorPortraitTaskMsg();
        BeanUtils.copyProperties(kanban, taskMsg);
        logger.info("供应商画像投递: taskMsg={}", jsonData = JSONObject.toJSONString(taskMsg));

        // 根据业务唯一ID进行投递
        ListenableFuture<SendResult<String, String>> future = kafkaTemplate.send(topic, jsonData);
        future.addCallback(new ListenableFutureCallback<SendResult<String, String>>() {
            @Override
            public void onSuccess(SendResult<String, String> sendResult) {
                logger.info("供应商画像投递成功! businessKey={}, topic={}, offset={}", kanban.getBusinessKey(), sendResult.getRecordMetadata().topic(), sendResult.getRecordMetadata().offset());

                // 投递成功后, 移除曾经失败的业务唯一ID
                failBusinessKeyList.remove(kanban.getBusinessKey());

                // 更新成功状态
                VendorPortraitTaskKanban updatingKanban = new VendorPortraitTaskKanban();
                updatingKanban.setKanbanId(kanban.getKanbanId());
                updatingKanban.setSendStatus(SendStatusEnum.SUCCESS.getValue());
                ObjectUtil.setForUpdateInfo(updatingKanban);
                vendorPortraitTaskKanbanMapper.updateVendorPortraitTaskKanbanSelectivlyById(updatingKanban);
            }

            @Override
            public void onFailure(Throwable throwable) {
                logger.error(String.format("供应商画像投递失败! businessKey=%s, topic=%s", kanban.getBusinessKey(), topic), throwable);
                failBusinessKeyList.add(kanban.getBusinessKey());
            }
        });

        try {
            future.get(30, TimeUnit.SECONDS);
        } catch (Exception e) {
            logger.error(String.format("等待供应商画像投递结果异常! businessKey=%s, topic=%s", kanban.getBusinessKey(), topic), e);
        }
    }

    return failBusinessKeyList;
}
```

- **分布式消费**：碰到非业务的异常情况，比如参数错误、已经被消费过，则直接 ACK 即可，否则先扣减最大消费次数，然后构造并执行执行链定时任务，如果执行成功才 ACK，否则不进行 ACK，等待下次重新消费，然后把执行链收集上来的错误日志保存到 MongoDB 上。

```java
/**
  * 消费供应商画像任务: 消费失败的会重新消费, 默认最大重试3次，目前是1次
  *
  * @param record
  * @param acknowledgment
  */
@KafkaListener(topics = { VendorPortraitConstant.KAFKA_TOPIC }, groupId = VendorPortraitConstant.KAFKA_GROUP_ID)
public void consumeVendorPortraitTask(ConsumerRecord<String, String> record, Acknowledgment acknowledgment) {
    logger.info("消费供应商画像任务: taskMsg={}", record.value());
    if(StringUtils.isBlank(record.value())) {
        // 非正常情况, 无需重新消费
        manualAck(acknowledgment, "消费供应商画像任务: taskMsg为空!");
        return;
    }

    // record => VendorPortraitTaskKanban
    VendorPortraitTaskMsg taskMsg = JSONObject.parseObject(record.value(), VendorPortraitTaskMsg.class);
    if(StringUtils.isBlank(taskMsg.getBusinessKey())) {
        // 非正常情况, 无需重新消费
        manualAck(acknowledgment, "消费供应商画像任务: businessKey为空!");
        return;
    }

    // 根据业务唯一ID查找供应商画像定时任务看板
    VendorPortraitTaskKanbanDTO kanbanDTO = new VendorPortraitTaskKanbanDTO();
    kanbanDTO.setBusinessKey(taskMsg.getBusinessKey());
    List<VendorPortraitTaskKanban> oneKanbanList = queryKanbansByParams(kanbanDTO);
    if(CollectionUtils.isEmpty(oneKanbanList)) {
        // 非正常情况, 无需重新消费
        manualAck(acknowledgment, "消费供应商画像任务: 找不到任何定时任务看板! businessKey=" + taskMsg.getBusinessKey());
        return;
    }

    // 如果小任务全部都同步完毕, 或者最大重试次数已经用完, 则不再执行; 否则, 链式执行同步任务
    VendorPortraitTaskKanban currentKanban = oneKanbanList.get(0);
    if(ConsumeStatusEnum.FULLY_SYNCED.getValue().equals(currentKanban.getConsumeStatus())) {
        manualAck(acknowledgment, "消费供应商画像任务: 小任务已全部同步完毕, 无需重新消费! businessKey=" + taskMsg.getBusinessKey());
        return;
    }
    if(currentKanban.getConsumeMaxRetries() < 1) {
        manualAck(acknowledgment, "消费供应商画像任务: 最大重试次数已经用完, 不能重新消费! businessKey=" + taskMsg.getBusinessKey());
        return;
    }

    // 供应商画像开始同步, 扣减消费次数
    decreaseConsumeMaxRetries(currentKanban);

    // 构造执行上下文
    ChainTaskContext context = new ChainTaskContext(currentKanban);

    // 构造同步任务执行链
    ChainTask chainTask = new ChainTaskFactory.ChainTaskBuilder()
        // 统计供应商基本信息
        .addChainTask(ChainTaskFactory.getChainTask(ChainTaskEnum.BASE_TASK))
        // 统计图标
        .addChainTask(ChainTaskFactory.getChainTask(ChainTaskEnum.ICON_TASK))
        // 统计合作单位
        .addChainTask(ChainTaskFactory.getChainTask(ChainTaskEnum.CO_UNIT_TASK))
        // 统计美的历程
        .addChainTask(ChainTaskFactory.getChainTask(ChainTaskEnum.COURSE_TASK))
        // 统计风险雷达
        .addChainTask(ChainTaskFactory.getChainTask(ChainTaskEnum.RISK_TASK))
        // 统计招投标信息
        .addChainTask(ChainTaskFactory.getChainTask(ChainTaskEnum.AUCTION_TASK))
        // 统计供应商考核
        .addChainTask(ChainTaskFactory.getChainTask(ChainTaskEnum.ASSE_TASK))
        // 统计品类编码数量
        .addChainTask(ChainTaskFactory.getChainTask(ChainTaskEnum.CATE_TASK))
        .build();

    // 链式执行同步任务 => 如果某个小任务已执行过了, 则不会继续执行
    if(chainTask.execute(context)) {
        markKanbanIsFullySynced(context);
        manualAck(acknowledgment, "消费供应商画像任务: 链式执行同步任务成功! businessKey=" + taskMsg.getBusinessKey());
        return;// 小任务已全部同步完毕, 无需重新消费
    }

    // 保存失败执行结果到MongoDB
    saveFailReasons2Mongo(context);
}

/** 手工ACK */
private void manualAck(Acknowledgment acknowledgment, String msg) {
    logger.info("手工ACK => " + msg);
    acknowledgment.acknowledge();
}

// 如果本次全部执行成功, 则更新本看板消费状态为全部同步完毕
private void markKanbanIsFullySynced(ChainTaskContext context) {
    Assert.notNull(context.getKanban(), "kanban不能为空!");

    VendorPortraitTaskKanban updatingKanban = new VendorPortraitTaskKanban();
    updatingKanban.setKanbanId(context.getKanban().getKanbanId());
    updatingKanban.setConsumeStatus(ConsumeStatusEnum.FULLY_SYNCED.getValue());
    ObjectUtil.setForUpdateInfo(updatingKanban);

    logger.info("供应商画像完全同步成功: updatingKanban={}", JSONObject.toJSONString(updatingKanban));
    vendorPortraitTaskKanbanMapper.updateVendorPortraitTaskKanbanSelectivlyById(updatingKanban);
}

// 供应商画像开始同步, 扣减消费次数
private void decreaseConsumeMaxRetries(VendorPortraitTaskKanban kanban) {
    Assert.notNull(kanban, "kanban不能为空!");

    VendorPortraitTaskKanban updatingKanban = new VendorPortraitTaskKanban();
    updatingKanban.setKanbanId(kanban.getKanbanId());
    updatingKanban.setConsumeMaxRetries(kanban.getConsumeMaxRetries() == null? 0 : kanban.getConsumeMaxRetries() - 1);
    ObjectUtil.setForUpdateInfo(updatingKanban);

    logger.info("供应商画像开始同步, 扣减消费次数: updatingKanban={}", JSONObject.toJSONString(updatingKanban));
    vendorPortraitTaskKanbanMapper.updateVendorPortraitTaskKanbanSelectivlyById(updatingKanban);
}
```

###### 12）架构设计 | MongoDB 保存日志

数据结构见 set 方法对应的参数。

```java
/** 保存失败执行结果到MongoDB */
private void saveFailReasons2Mongo(ChainTaskContext context) {
    VendorPortraitTaskFailLogMongoDTO failLogMongoDTO = new VendorPortraitTaskFailLogMongoDTO();
    failLogMongoDTO.setBusinessKey(context.getKanban().getBusinessKey());
    failLogMongoDTO.setVendorCode(context.getKanban().getVendorCode());
    failLogMongoDTO.setCompanyName(context.getKanban().getCompanyName());
    failLogMongoDTO.setFailReason(JSONObject.toJSONString(context.getTaskIndexFailReasonMap()));
    failLogMongoDTO.setLogTime(SpecialDateUtil.formatYmdHmsDate(new Date()));

    logger.info("保存日志, MongoDB vendorPortraitTaskFailLog, failLogMongoDTO={}", failLogMongoDTO.toString());
    failLogRepository.save(failLogMongoDTO);
}
```

###### 13）架构设计 | EsJob 单点定时

- **POM 依赖**：

```xml
<!--  elastic-job dependency -->
<dependency>
    <groupId>com.dangdang</groupId>
    <artifactId>elastic-job-lite-core</artifactId>
    <version>${elastic-job.version}</version>
</dependency>
<dependency>
    <groupId>com.dangdang</groupId>
    <artifactId>elastic-job-lite-spring</artifactId>
    <version>${elastic-job.version}</version>
</dependency>
```

- **配置文件**：

```properties
zookeeper.address=192.168.1.111:2181,192.168.1.112:2181,192.168.1.113:2181
zookeeper.namespace=elastic-job
zookeeper.connectionTimeout=10000
zookeeper.sessionTimeout=10000
zookeeper.maxRetries=3

simpleJob.cron=0/30 * * * * ?
#simpleJob.cron=00 03 21 * * ?
simpleJob.shardingTotalCount=5
simpleJob.shardingItemParameters=0=beijing,1=shanghai,2=changchun,3=changsha,4=hangzhou
simpleJob.jobParameter=source1=public,source2=private
simpleJob.failover=true
simpleJob.monitorExecution=true
simpleJob.monitorPort=8889
simpleJob.maxTimeDiffSeconds=-1
simpleJob.jobShardingStrategyClass=com.dangdang.ddframe.job.lite.api.strategy.impl.AverageAllocationJobShardingStrategy

dataflowJob.cron=0/10 * * * * ?
dataflowJob.shardingTotalCount=2
dataflowJob.shardingItemParameters=0=Beijing,1=Shanghai
```

- **简单定时任务**：界面配置 Cron 表达式，然后定时生效。

```java
@Component
public class MySimpleJob implements SimpleJob {
	@Override
	public void execute(ShardingContext shardingContext) {

		System.err.println("---------	开始任务 MySimpleJob	---------");

		System.err.println(shardingContext.getJobName());
		System.err.println(shardingContext.getJobParameter());
		System.err.println(shardingContext.getShardingItem());
		System.err.println(shardingContext.getShardingParameter());
		System.err.println(shardingContext.getShardingTotalCount());
		System.err.println("当前线程 : ---------------" + Thread.currentThread().getName());

		System.err.println("----------结束任务------");
	}
}
```

- **流式定时任务**：周期性执行。

```java
public class SpringDataflowJob implements DataflowJob<Foo> {
	
    private static final Logger LOGGER = LoggerFactory.getLogger(SpringDataflowJob.class);
    
    @Override
    public List<Foo> fetchData(final ShardingContext shardingContext) {
    	System.err.println("--------------@@@@@@@@@@ 抓取数据集合...--------------");
    	List<Foo> list = new ArrayList<Foo>();
    	list.add(new Foo("001", "张三"));
    	list.add(new Foo("002", "李四"));
    	return list;
    }
    
    @Override
    public void processData(final ShardingContext shardingContext, final List<Foo> data) {
    	System.err.println("--------------@@@@@@@@@ 处理数据集合...--------------");
    }
}
```

###### 14）架构设计 | 异常恢复

- **表结构**：

  ```sql
  CREATE TABLE `srm_pos_vendor_portrait_task_kanban` (
    `KANBAN_ID` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '主键ID',
    `BUSINESS_KEY` varchar(60) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '业务唯一ID',
    `VENDOR_CODE` varchar(30) COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '供应商编码',
    `COMPANY_NAME` varchar(250) COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT '' COMMENT '公司名称',
    `SEND_STATUS` tinyint(2) NOT NULL DEFAULT 0 COMMENT '供应商画像同步任务发送状态(0:发送失败,1:发送成功)',
    `CONSUME_STATUS` tinyint(2) NOT NULL DEFAULT 0 COMMENT '同步任务消费状态(0:未完全同步成功,1:完全同步成功)',
    `CONSUME_MAX_RETRIES` bigint(20) NOT NULL DEFAULT 1 COMMENT '同步任务最大消费次数',
    `BASE_TASK` tinyint(2) NOT NULL DEFAULT 0 COMMENT '供应商基本信息任务是否已完成(0:未完成;1:已完成,NULL:直接查表不需要统计)',
    `ICON_TASK` tinyint(2) NOT NULL DEFAULT 0 COMMENT '统计图标任务是否已完成(0:未完成;1:已完成,NULL:直接查表不需要统计)',
    `CO_UNIT_TASK` tinyint(2) NOT NULL DEFAULT 0 COMMENT '统计合作单位任务是否已完成(0:未完成;1:已完成,NULL:直接查表不需要统计)',
    `COURSE_TASK` tinyint(2) NOT NULL DEFAULT 0 COMMENT '统计美的历程任务是否已完成(0:未完成;1:已完成,NULL:直接查表不需要统计)',
    `RISK_TASK` tinyint(2) NOT NULL DEFAULT 0 COMMENT '统计风险雷达任务是否已完成(0:未完成;1:已完成,NULL:直接查表不需要统计)',
    `AUCTION_TASK` tinyint(2) NOT NULL DEFAULT 0 COMMENT '统计招投标信息任务是否已完成(0:未完成;1:已完成,NULL:直接查表不需要统计)',
    `BOOKING_TASK` tinyint(2) DEFAULT NULL COMMENT '统计红黄牌任务是否已完成(0:未完成;1:已完成,NULL:直接查表不需要统计)',
    `ASSE_TASK` tinyint(2) NOT NULL DEFAULT 0 COMMENT '统计供应商考核任务是否已完成(0:未完成;1:已完成,NULL:直接查表不需要统计)',
    `SCORE_TASK` tinyint(2) DEFAULT NULL COMMENT '统计绩效评价任务是否已完成(0:未完成;1:已完成,NULL:直接查表不需要统计)',
    `LEVEL_TASK` tinyint(2) DEFAULT NULL COMMENT '统计供应商分级任务是否已完成(0:未完成;1:已完成,NULL:直接查表不需要统计)',
    `CATE_TASK` tinyint(2) NOT NULL DEFAULT 0 COMMENT '统计品类编码数量任务是否已完成(0:未完成;1:已完成,NULL:直接查表不需要统计)',
    `DET_TASK` tinyint(2) DEFAULT NULL COMMENT '统计采购金额任务是否已完成(0:未完成;1:已完成,NULL:直接查表不需要统计)',
    `WORD_TASK` tinyint(2) DEFAULT NULL COMMENT '统计词云任务是否已完成(0:未完成;1:已完成,NULL:直接查表不需要统计)',
    `CREATED_BY` varchar(30) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '创建人账号',
    `CREATION_DATE` datetime NOT NULL COMMENT '创建时间',
    `LAST_UPDATED_BY` varchar(30) COLLATE utf8mb4_unicode_ci NOT NULL COMMENT '最后更新人账号',
    `LAST_UPDATE_DATE` datetime NOT NULL COMMENT '最后更新时间',
    `CREATED_FULL_NAME` varchar(250) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '创建人姓名',
    `LAST_UPDATED_FULL_NAME` varchar(250) COLLATE utf8mb4_unicode_ci DEFAULT NULL COMMENT '最后更新人姓名',
    `DELETE_FLAG` tinyint(2) NOT NULL DEFAULT 0 COMMENT '是否删除 0不删除 1删除',
    `VERSION` bigint(20) NOT NULL DEFAULT 0 COMMENT '版本号',
    `ATTRIBUTE1` varchar(240) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
    `ATTRIBUTE2` varchar(240) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
    `ATTRIBUTE3` varchar(240) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
    `ATTRIBUTE4` varchar(240) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
    `ATTRIBUTE5` varchar(240) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
    `ATTRIBUTE6` varchar(240) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
    `ATTRIBUTE7` varchar(240) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
    `ATTRIBUTE8` varchar(240) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
    `ATTRIBUTE9` varchar(240) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
    `ATTRIBUTE10` varchar(240) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
    `ATTRIBUTE11` varchar(240) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
    `ATTRIBUTE12` varchar(240) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
    `ATTRIBUTE13` varchar(240) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
    `ATTRIBUTE14` varchar(240) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
    `ATTRIBUTE15` varchar(240) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
    PRIMARY KEY (`KANBAN_ID`),
    UNIQUE KEY `srm_pos_vendor_portrait_schedule_kanban_BUSINESS_KEY_uindex` (`BUSINESS_KEY`)
  ) ENGINE=InnoDB AUTO_INCREMENT=190401 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='供应商画像定时任务看板表'
  ```

- **重新执行**：根据传入的字符串，获取对应的执行任务实例并重新执行。

  ```java
  @Override
  public Boolean syncVendorPortraitTask(VendorPortraitTaskKanbanBO kanbanBO) {
      logger.info("根据业务唯一ID, 同步供应商画像定时任务: kanbanBO={}", kanbanBO);
  
      // 根据主键ID, 查找供应商画像定时任务看板
      VendorPortraitTaskKanbanDTO kanbanDTO = new VendorPortraitTaskKanbanDTO();
      kanbanDTO.setBusinessKey(kanbanBO.getBusinessKey());
      List<VendorPortraitTaskKanban> oneKanbanList = queryKanbansByParams(kanbanDTO);
      Assert.notEmpty(oneKanbanList, "找不到对应的供应商画像定时任务看板!");
  
      // 根据定时任务类型, 获取对应的枚举类
      ChainTaskEnum chainTaskEnum = ChainTaskEnum.getChainTaskEnum(kanbanBO.getTaskType());
      Assert.notNull(chainTaskEnum, "找不到对应的定时任务类型!");
  
      // 构造执行上下文
      ChainTaskContext context = new ChainTaskContext(oneKanbanList.get(0));
  
      // 构造同步任务
      ChainTask chainTask = new ChainTaskFactory.ChainTaskBuilder().addChainTask(ChainTaskFactory.getChainTask(chainTaskEnum)).build();
  
      // 执行同步任务
      if(chainTask.execute(context)) {
          markKanbanIsFullySynced(context);
          logger.info("供应商画像链式同步任务执行成功! kanban={}", JSONObject.toJSONString(oneKanbanList.get(0)));
          return true;
      }
  
      // 保存失败执行结果到MongoDB
      saveFailReasons2Mongo(context);
  
      return false;
  }
  ```

##### R | Result

供应商画像 + 定时任务看板已完成。

- 通过分析供应商画像需求，绘制业务时序图。
- 抽象基于缓存线程池的异步式任务，以及可初始化上下文的同步式任务模型。
- 以工厂 + 建造者 + 责任链模式构造执行链，结合使用 EsJob + Kafka + MongoDB 中间件，解决任务单点定时、分布式高性能消费，易于定位异常及迅速恢复的问题。

#### 条目销售出库

##### S | Situation

供方反馈系统响应扫码速度过慢（专门用手机计时，记录延迟有 4.55 s），扫码枪扫完一整板的货，系统才开始对异常条码报错，导致如果一板出现问题条码的话，就需要这一整板重新扫过，以定位问题条码来处理，影响了供方出货的效率。

##### T | Task

目前，OEM 供方有 2 个，日班和夜班一共有 2 条产线，根据视频中的操作速度，大概是 4~5 个 / 1s，所以也就是并发数为 5 * 2 = 10 的 QPS，分摊到 3 台服务器的话，每台服务器需要让接口满足 300 ms 以下的延迟，因此，在不增加服务器的情况下，尽量让接口的延迟足够低。

##### A | Action

根据截图，找到对应的接口，然后在测试环境模拟跑一遍接口，把接口路过的 SQL 日志都收集起来，统一分析，最终发现有几处索引是没有添加的，分别是：

1. psi_base_barcode：条码表，314.67w+，16 c 32 G MySQL， 优化前 Druid SQL 监控【执行时间】显示 1000 ms 左右，优化后 Druid SQL 监控显示 35 ms 左右。

   ```sql
   ALTER TABLE psi_base_barcode ADD INDEX psi_base_barcode_n2(CUS_COMPANY_CODE, PRODUCT_CODE);
   ```

2. psi_base_packing_relation：箱包关系表，315.28w，16 c 32 G MySQL， 优化前 Druid SQL 监控【执行时间】显示 650 ms 左右，优化后 Druid SQL 监控显示 32 ms 左右。

   ```sql
   -- 4、判断条码是否已出库：增加【CARTON_BARCODE】和【BARCODE】索引有提升
   SELECT COUNT(1)
   FROM psi_sales_stock_out
   WHERE (CARTON_BARCODE = '331100007920401110191W' OR BARCODE = '331100007920401110191W');
   ```

3. psi_sales_stock_out：已出库条码表，840.58w，16 c 32 G MySQL，优化前 Druid SQL 监控【执行时间】显示  2290ms 左右，优化后 Druid SQL 监控显示 40 ms 左右。

   ```sql
   -- Add Index： explain => index_merge，Using union(psi_sales_stock_out_n1,psi_sales_stock_out_n2); Using where
   ALTER TABLE psi_sales_stock_out ADD INDEX psi_sales_stock_out_n1(CARTON_BARCODE);
   ALTER TABLE psi_sales_stock_out ADD INDEX psi_sales_stock_out_n2(BARCODE);
   ```

4. 已扫过的条码，加入 Redis 缓存，防止重复被扫，下次遇到在缓存中有的就直接返回即可。

5. Redis 分布式锁控制出库时不被重复出库，然后从缓存中拿取已经扫过的条码，来更新条码为失效状态，然后删除缓存中的条码。

##### R | Result

最终通过使用 Druid 监控，发现关键 SQL 的耗时已经满足要求了，psi_base_barcode 提效 96.51%，psi_base_packing_relation 提效 95.08%，psi_sales_stock_out 提效 98.25%。

#### 中科院接口

1. 通过分布式锁，实现寻源、进销存、品质单点定时，通过使用 Netty 通信聚合订单信息到中台，中台提供 MD5 验签 + TCP 传输的接口对接中科院。

##### S | Situation

中科院的国家工业互联网-大数据中心，需要收集中小企业的运行监测数据，包括统计企业订单数、下线完工数、询价报价数。

##### T | Task

由于中科院的客户端要求使用 NettyClient，所以这边也是采用了 Netty 作为传输的框架，使用 TCP 协议进行接口传输。

##### A | Action

###### 1）需求分析 | 寻源云

定时 01：00：00 启动，统计发布寻源需求企业数 `sou_requirement_head`（7726+）、询价企业数 `sou_inquiry_head`（140+）、迅即还

##### R | Result

通过落地 SpringCloud，拆分品质云单体为 BASE、ESB、OEM、APP 等多个微服务，降低 OEM 下线扫码所在服务器的平均负载约 33%，有效避免生产车间停线事件的发生。



























